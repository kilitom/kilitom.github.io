<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Kilitom">
    <meta name="description" content="书中自有颜如玉,书中自有黄金屋">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Kilitom</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.0.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Kilitom</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Kilitom</div>
        <div class="logo-desc">
            
            书中自有颜如玉,书中自有黄金屋
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/kilitom/kilitom.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/kilitom/kilitom.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title"></h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-08-10
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><strong>3.1、认识类集（理解）</strong></p>
<p>如果现在要想保存多个对象，肯定使用对象数组完成，但是对象数组本身有一个最大的问题在于其数据的长度，所以后来使用了链表完成了动态对象数组的开发，可是链表的开发难度实在是很大，而且如果一个链表要想真正去使用，只依靠之前所编写的还不够，还需要进行一些代码的调优。</p>
<p>而在JDK<br>1.2之后正式引入了类集的概念，类集是一种动态的对象数组，属于各个数据结构的实现类，在整个类集之中主要的组成是一些核心的操作接口：<strong>Collection、List、Set、Map、Iterator、Enumeration</strong>。</p>
<p><strong>3.2、单值保存的最大父接口：Collection（重点）</strong></p>
<p>所谓的单值保存指的是每一次操作只会保存一个对象，就好像之前的链表程序一样，每一次只保存了一个对象，在Collection接口之中定义了如下的一些操作方法。</p>
<table>
<thead>
<tr>
<th><strong>No.</strong></th>
<th><strong>方法名称</strong></th>
<th><strong>类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><strong>public boolean add(E e)</strong></td>
<td><strong>普通</strong></td>
<td><strong>数据增加</strong></td>
</tr>
<tr>
<td>2</td>
<td>public void clear()</td>
<td>普通</td>
<td>清除数据</td>
</tr>
<tr>
<td>3</td>
<td>public boolean contains(Object o)</td>
<td>普通</td>
<td>查找数据是否存在</td>
</tr>
<tr>
<td>4</td>
<td>public boolean isEmpty()</td>
<td>普通</td>
<td>判断是否为空集合</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td><strong>public Iterator&lt;E&gt; iterator()</strong></td>
<td><strong>普通</strong></td>
<td><strong>为Iterator接口实例化</strong></td>
</tr>
<tr>
<td>6</td>
<td>public boolean remove(Object o)</td>
<td>普通</td>
<td>删除数据</td>
</tr>
<tr>
<td>7</td>
<td>public int size()</td>
<td>普通</td>
<td>取得集合的个数</td>
</tr>
<tr>
<td>8</td>
<td>public Object[] toArray()</td>
<td>普通</td>
<td>将集合变为对象数组</td>
</tr>
</tbody></table>
<p>在Collection接口之中一共定义了15个方法，在所有的方法之中，只有两个方法最为常用：add()、iterator()。不过从开发上讲，很少会去直接使用Collection，都会使用Collection的两个子接口：List、Set。</p>
<p><strong>3.3、允许重复的子接口：List（重点，80%）</strong></p>
<p>List是Collection的一个最为常用的子接口，首先这个接口的定义如下：</p>
<table>
<thead>
<tr>
<th>public interface List&lt;E&gt; extends Collection&lt;E&gt;</th>
</tr>
</thead>
</table>
<p>但是List接口对Collection接口进行了大量的扩充，但是扩充之后的主要方法：</p>
<table>
<thead>
<tr>
<th><strong>No.</strong></th>
<th><strong>方法名称</strong></th>
<th><strong>类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>public E get(int index)</td>
<td>普通</td>
<td>取得指定索引位置上的数据</td>
</tr>
<tr>
<td>2</td>
<td>public E set(int index, E element)</td>
<td>普通</td>
<td>修改指定索引位置上的数据</td>
</tr>
<tr>
<td>3</td>
<td>public ListIterator&lt;E&gt; listIterator()</td>
<td>普通</td>
<td>为ListIterator接口实例化</td>
</tr>
</tbody></table>
<p>但是以上的三个方法，只是针对于List接口起作用，而List接口有两个常用子类：ArrayList、Vector。</p>
<p><strong>3.3.1、新的子类：ArrayList，95%</strong></p>
<p>ArrayList是List子接口使用最多的一个子类，而这个类的定义如下：</p>
<table>
<thead>
<tr>
<th>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements <strong>List&lt;E&gt;</strong>, RandomAccess, Cloneable, Serializable</th>
</tr>
</thead>
</table>
<p>按照面向对象的概念来讲，现在使用ArrayList主要的目的是为List接口实例化，所有的操作方法都以List接口为主。</p>
<p><strong>范例：</strong>使用ArrayList进行List接口的功能验证</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.ArrayList; <strong>import</strong> java.util.List; <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { List&lt;String&gt; all = <strong>new</strong> ArrayList&lt;String&gt;() ; all.add(“Hello”) ; all.add(“Hello”) ; // 内容重复了 all.add(“World”) ; <strong>for</strong> (<strong>int</strong> x = 0; x &lt; all.size(); x++) { String str = all.get(x) ; // get()方法只有List接口有 System.<em>out</em>.print(str + “、”); } } }</th>
</tr>
</thead>
</table>
<p>在使用代码的时候可以发现，List集合之中即使存在了重复数据，也可以正常的保存，而且数据保存的顺序就是存入数据的顺序。</p>
<p><strong>范例：</strong>使用List集合修改之前的程序</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.ArrayList; <strong>import</strong> java.util.List; <strong>interface</strong> Animal { // 动物 <strong>public</strong> String getName() ; <strong>public int</strong> getAge() ; } <strong>class</strong> Zoo { <strong>private</strong> List&lt;Animal&gt; animals = <strong>new</strong> ArrayList&lt;Animal&gt;() ; // 多个动物 <strong>public void</strong> add(Animal ani) { // 增加动物 <strong>this</strong>.animals.add(ani) ; // 增加动物 } <strong>public void</strong> delete(Animal ani) { <strong>this</strong>.animals.remove(ani) ; // 需要equals() } <strong>public</strong> List&lt;Animal&gt; search(String keyWord) { List&lt;Animal&gt; result = <strong>new</strong> ArrayList&lt;Animal&gt;() ; <strong>for</strong> (<strong>int</strong> x = 0 ; x &lt; **this**.animals.size() ; x ++) { Animal ani = **this**.animals.get(x) ; **if** (ani.getName().contains(keyWord)) { // 满足 result.add(ani) ; } } **return** result ; } } **class** Dog **implements** Animal { **private** String name ; **private int** age ; **public** Dog(String name,**int** age) { **this**.name = name ; **this**.age = age ; } **public** String getName() { **return this**.name ; } **public int** getAge() { **return this**.age ; } **public boolean** equals(Object obj) { **if** (**this** == obj) { **return true** ; } **if** (obj == **null**) { **return false** ; } **if** (!(obj **instanceof** Dog)) { **return false** ; } Dog dog = (Dog) obj ; **if** (**this**.name.equals(dog.name) &amp;&amp; **this**.age == dog.age) { **return true** ; } **return false** ; } **public** String toString() { **return** “〖狗的信息〗名字：” + **this**.name + “，年龄：” + **this**.age ; } } **class** Tiger **implements** Animal { **private** String name ; **private int** age ; **public** Tiger(String name,**int** age) { **this**.name = name ; **this**.age = age ; } **public** String getName() { **return this**.name ; } **public int** getAge() { **return this**.age ; } **public boolean** equals(Object obj) { **if** (**this** == obj) { **return true** ; } **if** (obj == **null**) { **return false** ; } **if** (!(obj **instanceof** Tiger)) { **return false** ; } Tiger t = (Tiger) obj ; **if** (**this**.name.equals(t.name) &amp;&amp; **this**.age == t.age) { **return true** ; } **return false** ; } **public** String toString() { **return** “〖老虎的信息〗名字：” + **this**.name + “，年龄：” + **this**.age ; } } **public class** TestDemo { **public static void** main(String args[]) { Zoo zoo = **new** Zoo() ; // 动物园 zoo.add(**new** Dog(“花狗”,1)) ; zoo.add(**new** Dog(“黄狗”,1)) ; zoo.add(**new** Dog(“黑狗”,1)) ; zoo.add(**new** Dog(“斑点狗”,1)) ; zoo.add(**new** Tiger(“斑点虎”,2)) ; zoo.add(**new** Tiger(“黑虎”,2)) ; zoo.add(**new** Tiger(“花虎”,2)) ; zoo.delete(**new** Dog(“斑点狗”,1)) ; // 删除 List&lt;Animal&gt; result = zoo.search(“斑点”) ; <strong>for</strong> (<strong>int</strong> x = 0 ; x &lt; result.size() ; x ++) { System.<em>out</em>.println(result.get(x)) ; } } }</th>
</tr>
</thead>
</table>
<p>至少此时的程序不再需要自己去开发链表了，所有的链表的实现类都有了。</p>
<p><strong>3.3.2、旧的子类：Vector，5%</strong></p>
<p>Vector类是在JDK<br>1.0的时候就推出的一个最早的实现动态数组的操作类，实际上对于今天而言，有许多的类上依然还是在使用着Vector，不过从实际的开发来讲，现在设计的一些程序都是针对于接口的操作了。</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.List; <strong>import</strong> java.util.Vector; <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { List&lt;String&gt; all = <strong>new</strong> Vector&lt;String&gt;() ; all.add(“Hello”) ; all.add(“Hello”) ; // 内容重复了 all.add(“World”) ; <strong>for</strong> (<strong>int</strong> x = 0; x &lt; all.size(); x++) { String str = all.get(x) ; // get()方法只有List接口有 System.<em>out</em>.print(str + “、”); } } }</th>
</tr>
</thead>
</table>
<p>因为所有的操作都是针对于接口完成的，接口定义的方法不变，子类随便变。</p>
<p><strong>面试题：</strong>请解释ArrayList和Vector的区别？</p>
<table>
<thead>
<tr>
<th><strong>No.</strong></th>
<th><strong>区别</strong></th>
<th><strong>ArrayList</strong></th>
<th><strong>Vector</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>推出时间</td>
<td>JDK 1.2</td>
<td>JDK 1.0</td>
</tr>
<tr>
<td>2</td>
<td>性能</td>
<td>采用异步处理方式，性能更高</td>
<td>采用同步处理方式，性能相对较低</td>
</tr>
<tr>
<td>3</td>
<td>安全性</td>
<td>非线程安全</td>
<td>线程安全</td>
</tr>
<tr>
<td>4</td>
<td>输出</td>
<td>Iterator、ListIterator、foreach</td>
<td>Iterator、ListIterator、foreach、Enumeration</td>
</tr>
</tbody></table>
<p>从实际开发而言，几乎都是开发异步程序，所以首选的肯定是ArrayList子类。</p>
<p><strong>3.4、不允许重复的子接口：Set（重点），20%</strong></p>
<p>Set也是一个Collection较为常用的子接口，这个接口的定义如下：</p>
<table>
<thead>
<tr>
<th>public interface Set&lt;E&gt; extends Collection&lt;E&gt;</th>
</tr>
</thead>
</table>
<p>在Collection接口定义了15个方法，但是Set子接口并不像List子接口那样对Collection接口进行了大量的扩充，而是完整的继承了下来，那么就证明了在Set子接口之中是肯定无法使用get()方法的。</p>
<p>那么在Set子接口之中常用的两个子类：HashSet、TreeSet，下面分别说明。</p>
<p><strong>3.4.1、散列存放的子类：HashSet，80%</strong></p>
<p>Hash（哈希）属于一种算法，这种算法的核心意义指的是找空保存算法，所以只要一看见hash第一反应就是说没有顺序的保存。</p>
<p><strong>范例：</strong>观察Set接口使用</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.HashSet; <strong>import</strong> java.util.Set; <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { Set&lt;String&gt; all = <strong>new</strong> HashSet&lt;String&gt;() ; all.add(“Hello”) ; all.add(“Hello”) ; // 内容重复了 all.add(“World”) ; System.<em>out</em>.println(all); } }</th>
</tr>
</thead>
</table>
<p>保存数据再输出之后可以发现，重复的数据没有了，并且其本身的保存也是没有任何顺序的。</p>
<p><strong>3.4.2、排序存放的子类：TreeSet，20%</strong></p>
<p>如果现在希望Set集合之中保存的数据有顺序，那么就通过TreeSet进行Set接口的实例化。</p>
<p><strong>范例：</strong>使用TreeSet</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.Set; <strong>import</strong> java.util.TreeSet; <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { Set&lt;String&gt; all = <strong>new</strong> TreeSet&lt;String&gt;() ; all.add(“D”) ; all.add(“A”) ; // 内容重复了 all.add(“B”) ; all.add(“B”) ; all.add(“C”) ; System.<em>out</em>.println(all); } }</th>
</tr>
</thead>
</table>
<p>现在发现所有保存的数据没有重复且有序排列。</p>
<p><strong>3.4.3、关于TreeSet排序的说明（重点）</strong></p>
<p>通过之前的程序可以发现，使用TreeSet实例化Set接口之中，所有保存的数据都是有序的，那么在这种情况下，那么如果说使用的是一个自定义的类呢？</p>
<p>那么这个时候如果这个类对象要进行排序的话，则这个类必须实现Comparable接口，设置比较规则。但是在这种情况下有一点必须注意：一旦使用了Comparable之后，类之中的所有属性都必须写进排序规则。</p>
<p><strong>范例：</strong>自定义类排序</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.Set; <strong>import</strong> java.util.TreeSet; <strong>class</strong> Person <strong>implements</strong> Comparable&lt;Person&gt; { <strong>private</strong> String name ; <strong>private int</strong> age ; <strong>public</strong> Person(String name,<strong>int</strong> age) { <strong>this</strong>.name = name ; <strong>this</strong>.age = age ; } @Override <strong>public</strong> String toString() { <strong>return</strong> “姓名：” + <strong>this</strong>.name + “，年龄：” + <strong>this</strong>.age + “\n” ; } @Override <strong>public int</strong> compareTo(Person o) { <strong>if</strong> (<strong>this</strong>.age &gt; o.age) { <strong>return</strong> 1 ; } <strong>else if</strong> (<strong>this</strong>.age &lt; o.age) { **return** -1 ; } **else** { **return this**.name.compareTo(o.name); } } } **public class** TestDemo { **public static void** main(String[] args) **throws** Exception { Set&lt;Person&gt; all = <strong>new</strong> TreeSet&lt;Person&gt;() ; all.add(<strong>new</strong> Person(“张三”,20)) ; all.add(<strong>new</strong> Person(“张三”,20)) ; // 全部重复 all.add(<strong>new</strong> Person(“李四”,20)) ; // 年龄重复 all.add(<strong>new</strong> Person(“王五”,19)) ; all.add(<strong>new</strong> Person(“赵六”,21)) ; System.<em>out</em>.println(all); }}</th>
</tr>
</thead>
</table>
<p>TreeSet子类依靠Comparable中compareTo()方法的返回值是否为0来判断是否为重复元素。</p>
<p><strong>3.4.4、关于重复元素的说明</strong></p>
<p>那么TreeSet依靠Comparable进行重复元素判断，那么HashSet可以吗？发现以上的程序换为了HashSet之后，该有的重复还是有，因为从真正的意义上来讲，判断重复元素依靠的不是Comparable（只有排序的时候才依靠Comparable），所有的重复元素的判断依靠于Object类的两个方法：</p>
<p>· <strong>hash码：</strong>public int hashCode()；</p>
<p>· <strong>对象比较：</strong>public boolean equals(Object obj)。</p>
<p>在进行对象比较的过程之中，首先会先使用hashCode()与已保存在集合之中的对象的hashCode()进行比较，如果代码相同，则再使用equals()方法进行属性的依次判断，如果全部相同，则为相同元素。</p>
<p>那么为了保证每一个对象的hashCode()不一样，需要设计一组数学公式才可以，会吗？</p>
<p><strong>范例：</strong>重复元素</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.HashSet; <strong>import</strong> java.util.Set; <strong>class</strong> Person { <strong>private</strong> String name ; <strong>private int</strong> age ; <strong>public</strong> Person(String name,<strong>int</strong> age) { <strong>this</strong>.name = name ; <strong>this</strong>.age = age ; } @Override <strong>public</strong> String toString() { <strong>return</strong> “姓名：” + <strong>this</strong>.name + “，年龄：” + <strong>this</strong>.age + “\n” ; } @Override <strong>public int</strong> hashCode() { <strong>final int</strong> prime = 31; <strong>int</strong> result = 1; result = prime * result + age; result = prime * result + ((name == <strong>null</strong>) ? 0 : name.hashCode()); <strong>return</strong> result; } @Override <strong>public boolean</strong> equals(Object obj) { <strong>if</strong> (<strong>this</strong> == obj) <strong>return true</strong>; <strong>if</strong> (obj == <strong>null</strong>) <strong>return false</strong>; <strong>if</strong> (getClass() != obj.getClass()) <strong>return false</strong>; Person other = (Person) obj; <strong>if</strong> (age != other.age) <strong>return false</strong>; <strong>if</strong> (name == <strong>null</strong>) { <strong>if</strong> (other.name != <strong>null</strong>) <strong>return false</strong>; } <strong>else if</strong> (!name.equals(other.name)) <strong>return false</strong>; <strong>return true</strong>; } } <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { Set&lt;Person&gt; all = <strong>new</strong> HashSet&lt;Person&gt;() ; all.add(<strong>new</strong> Person(“张三”,20)) ; all.add(<strong>new</strong> Person(“张三”,20)) ; // 全部重复 all.add(<strong>new</strong> Person(“李四”,20)) ; // 年龄重复 all.add(<strong>new</strong> Person(“王五”,19)) ; all.add(<strong>new</strong> Person(“赵六”,21)) ; System.<em>out</em>.println(all); } }</th>
</tr>
</thead>
</table>
<p>至此，Object类之中的全部方法就讲解完成了。</p>
<p><strong>3.5、集合的输出操作（重点）</strong></p>
<p>在之前所介绍的都属于单值集合的基本操作，可是对于集合有一个最为重要的问题就是如何进行集合内容的输出操作，而这个问题在Java的类集框架之中给出了四种输出方式：Iterator、ListIterator、Enumeration、foreach。</p>
<p><strong>3.5.1、迭代输出：Iterator（核心），95%</strong></p>
<p>Iterator是最为常用的集合输出接口，在这个接口中一共定义了三个方法，但只有两个有真正用处：</p>
<p><strong>· 判断是否有下一个元素：public boolean hasNext()；</strong></p>
<p><strong>· 取得下一个元素：public E next()。</strong></p>
<p>在Iterator接口之中存在了一个remove()方法，但是这个方法真没用。而且在之前学习的Scanner也是Iterator的子类。</p>
<p>但是如何取得Iterator接口的实例化对象呢？这一操作在Collection接口就已经明确定义了，因为Collection继承了一个Iterable接口，在这个接口下定义了一个方法：public<br>Iterator&lt;T&gt;<br>iterator()，取得Iterator接口的实例化对象，但是与之前在IO操作部分学习的一样，OutputStream实现了Closeable和Flushable两个接口，但是这两个接口属于新的接口，和这两个接口一样，Iterable接口也是在JDK<br>1.5的时候出现的，那么基本上也不会去关心这两个接口，因为Collection接口中也已经明确定义了iterator()方法。</p>
<p><strong>范例：</strong>使用Iterator输出集合数据</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.ArrayList; <strong>import</strong> java.util.Iterator; <strong>import</strong> java.util.List; <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { List&lt;String&gt; all = <strong>new</strong> ArrayList&lt;String&gt;(); all.add(“Hello”); all.add(“Hello”); // 内容重复了 all.add(“World”); Iterator&lt;String&gt; iter = all.iterator(); <strong>while</strong> (iter.hasNext()) { // 判断是否有下一个元素 String str = iter.next() ; System.<em>out</em>.print(str + “、”); } } }</th>
</tr>
</thead>
</table>
<p><strong>以后只要是见到了集合的输出操作，永远都使用Iterator接口完成。</strong></p>
<p><strong>3.5.2、双向迭代输出：ListIterator（了解），0.09%</strong></p>
<p>Iterator可以完成的是由前向后的单向输出操作，如果现在希望可以完成由前向后，和由后向前输出的话，那么就可以利用ListIterator接口完成，此接口是Iterator的子接口，在ListIterator接口主要使用以下两个扩充方法：</p>
<p>· 判断是否有前一个元素：public boolean hasPrevious()；</p>
<p>· 取出前一个元素：public E previous()。</p>
<p>但是如果要想取得ListIterator接口的实例化对象，Collection没有这样的方法支持，这个方法在List接口之中存在：public<br>ListIterator&lt;E&gt; listIterator()。</p>
<p><strong>范例：</strong>执行双向迭代</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.ArrayList; <strong>import</strong> java.util.List; <strong>import</strong> java.util.ListIterator; <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { List&lt;String&gt; all = <strong>new</strong> ArrayList&lt;String&gt;(); all.add(“Hello”); all.add(“Hello”); // 内容重复了 all.add(“World”); ListIterator&lt;String&gt; iter = all.listIterator(); System.<em>out</em>.print(“由前向后输出：”); <strong>while</strong> (iter.hasNext()) { // 判断是否有下一个元素 String str = iter.next() ; System.<em>out</em>.print(str + “、”); } System.<em>out</em>.print(“\n由后向前输出：”); <strong>while</strong> (iter.hasPrevious()) { String str = iter.previous() ; System.<em>out</em>.print(str + “、”); } } }</th>
</tr>
</thead>
</table>
<p>但是对于由后向前的输出操作，在进行之前一定要首先发生由前向后的输出。由于此输出接口只有List可以使用，所以在开发之中几乎不会出现。</p>
<p><strong>3.5.3、废弃的接口：Enumeration（重点），4.9%</strong></p>
<p>Enumeration是一个最早的输出接口，最早称为枚举输出，在JDK<br>1.0的时候就已经推出了，并且在JDK<br>1.5的时候将其功能进行了扩充，主要就是增加了泛型，在Enumeration接口里面只定义了两个方法：</p>
<p>· <strong>判断是否有下一个元素：</strong>public boolean hasMoreElements()；</p>
<p>· <strong>取得当前元素：</strong>public E nextElement()；</p>
<p>不过要想取得Enumeration的实例化对象，不能依靠Collection接口了，只能够依靠Vector类完成，在Vector子类之中定义了如下一个方法：public<br><strong>Enumeration&lt;E&gt;</strong> elements()。</p>
<p><strong>范例：</strong>使用Enumeration进行输出</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.Enumeration; <strong>import</strong> java.util.Vector; <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { Vector&lt;String&gt; all = <strong>new</strong> Vector&lt;String&gt;(); all.add(“Hello”); all.add(“Hello”); // 内容重复了 all.add(“World”); Enumeration&lt;String&gt; enu = all.elements(); <strong>while</strong> (enu.hasMoreElements()) { String str = enu.nextElement(); System.<em>out</em>.print(str + “、”); } } }</th>
</tr>
</thead>
</table>
<p>从开发而言，首先考虑绝对不是Enumeration，考虑的肯定是Iterator，只有在必须使用的时候才用它。</p>
<p><strong>3.5.4、JDK 1.5的支持：foreach（理解），0.01%</strong></p>
<p>对于foreach输出除了可以进行数组内容的输出之外，也可以针对于集合完成输出。</p>
<p><strong>范例：</strong>使用foreach</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.ArrayList; <strong>import</strong> java.util.List; <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { List&lt;String&gt; all = <strong>new</strong> ArrayList&lt;String&gt;(); all.add(“Hello”); all.add(“Hello”); // 内容重复了 all.add(“World”); <strong>for</strong> (String str : all) { System.<em>out</em>.print(str + “、”); } } }</th>
</tr>
</thead>
</table>
<p>使用foreach并不是一个被广泛认可的操作代码形式。</p>
<p><strong>3.6、偶对象保存：Map接口（重点）</strong></p>
<p>偶对象指的是一对对象，即：两个对象要同时保存。这两个对象是按照了“key<br>=value”的形式进行定义的，即：可以通过key找到对应的value数据，就好象电话号码本一样，例如，电话号码本之中保存了如下的信息：</p>
<p>· key = 张三，value = 123456；</p>
<p>· key = 李四，value = 234567；</p>
<p>现在如果要想找到张三的电话，那么肯定根据张三的key，取得对应的value，，而如果现在要想找王五的电话，由于没有王五这个key，所以返回的结果就是null。</p>
<p>Map就是实现这样一种操作的数据结构，这个接口之中定义的主要操作方法如下。</p>
<table>
<thead>
<tr>
<th><strong>No.</strong></th>
<th><strong>方法名称</strong></th>
<th><strong>类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><strong>public V put(K key, V value)</strong></td>
<td><strong>普通</strong></td>
<td><strong>向集合之中保存数据</strong></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>public V get(Object key)</strong></td>
<td><strong>普通</strong></td>
<td><strong>通过指定的key取得对应的value</strong></td>
</tr>
<tr>
<td>3</td>
<td>public Set&lt;K&gt; keySet()</td>
<td>普通</td>
<td>将Map中的所有key以Set集合的方式返回</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><strong>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</strong></td>
<td><strong>普通</strong></td>
<td><strong>将Map集合变为Set集合</strong></td>
</tr>
</tbody></table>
<p>在Map接口之中有两个常用的子类：HashMap、Hashtable。</p>
<p><strong>3.6.1、新的子类：HashMap，95%</strong></p>
<p>HashMap是Map接口之中使用最多的一个子类，这个子类的定义如下：</p>
<table>
<thead>
<tr>
<th>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements <strong>Map&lt;K,V&gt;</strong>, Cloneable, Serializable</th>
</tr>
</thead>
</table>
<p>下面就直接通过HashMap演示Map接口中各个主要方法的作用。</p>
<p><strong>范例：</strong>验证Map方法</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.HashMap; <strong>import</strong> java.util.Map; <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { Map&lt;Integer, String&gt; map = <strong>new</strong> HashMap&lt;Integer, String&gt;(); map.put(3, “张三”); map.put(<strong>null</strong>, “无名氏”); map.put(3, “李四”); // key重复，value会被新内容覆盖 map.put(1, “王五”); map.put(0, “赵六”); System.<em>out</em>.println(map.get(3)); System.<em>out</em>.println(map.get(<strong>null</strong>)); } }</th>
</tr>
</thead>
</table>
<p>通过这一代码可以发现，Map和Collection在操作上的不同：</p>
<p><strong>· Collection接口设置完的内容目的是为了输出；</strong></p>
<p><strong>· Map接口设置完内容的目的是为了查找。</strong></p>
<p><strong>范例：</strong>取得全部的key，全部的key通过Set集合返回</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.HashMap; <strong>import</strong> java.util.Iterator; <strong>import</strong> java.util.Map; <strong>import</strong> java.util.Set; <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { Map&lt;Integer, String&gt; map = <strong>new</strong> HashMap&lt;Integer, String&gt;(); map.put(3, “张三”); map.put(<strong>null</strong>, “无名氏”); map.put(3, “李四”); // key重复，value会被新内容覆盖 map.put(1, “王五”); map.put(0, “赵六”); Set&lt;Integer&gt; set = map.keySet() ;// 取得全部的key Iterator&lt;Integer&gt; iter = set.iterator() ; <strong>while</strong> (iter.hasNext()) { Integer key = iter.next() ; System.<em>out</em>.println(key + “ –&gt; “ + map.get(key)); } } }</th>
</tr>
</thead>
</table>
<p><strong>3.6.2、旧的子类：Hashtable，5%</strong></p>
<p>Hashtable是在JDK 1.0的时候推出的一个数据结构类，在JDK<br>1.2之后，让Hashtable实现了一个Map接口，所以用户在使用的时候依然采用子类为接口实例化的方法进行，那么只要接口的方法不变，实际上不管使用那一个子类都一样。</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.Hashtable; <strong>import</strong> java.util.Map; <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { Map&lt;Integer, String&gt; map = <strong>new</strong> Hashtable&lt;Integer, String&gt;(); map.put(3, “张三”); map.put(3, “李四”); // key重复，value会被新内容覆盖 map.put(1, “王五”); map.put(0, “赵六”); System.<em>out</em>.println(map.get(3)); System.<em>out</em>.println(map.get(10)); } }</th>
</tr>
</thead>
</table>
<p>这个时候在使用Hashtable子类的时候，里面的数据不能有null。</p>
<p><strong>面试题：</strong>请解释HashMap和Hashtable的区别？</p>
<table>
<thead>
<tr>
<th><strong>No.</strong></th>
<th><strong>区别</strong></th>
<th><strong>HashMap</strong></th>
<th><strong>Hashtable</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>推出时间</td>
<td>JDK 1.2</td>
<td>JDK 1.0</td>
</tr>
<tr>
<td>2</td>
<td>性能</td>
<td>采用异步处理方式，性能更高</td>
<td>采用同步处理方式，性能相对较低</td>
</tr>
<tr>
<td>3</td>
<td>安全性</td>
<td>非线程安全</td>
<td>线程安全</td>
</tr>
<tr>
<td>4</td>
<td>设置null</td>
<td>允许将key或value设置为null</td>
<td>不允许出现null，否则出现空指向异常</td>
</tr>
</tbody></table>
<p><strong>3.6.3、关于Map集合的输出问题（核心）</strong></p>
<p>对于集合操作，在之前就一直强调：只要是集合的输出都使用Iterator完成，但是对于现在的Map集合就麻烦了，因为Map接口之中并没有提供像Collection接口那样的iterator()方法，所以如何使用Iterator输出Map集合呢？</p>
<p>如果要想真正的去思考Map接口通过Iterator输出，那么首先需要来观察一个Map.Entry接口，此接口定义如下：</p>
<table>
<thead>
<tr>
<th>public <strong>static</strong> interface Map**.**Entry&lt;K,V&gt;</th>
</tr>
</thead>
</table>
<p>很明显，这是一个在Map接口之中使用static定义的一个内部接口。而且通过Map接口的定义也可以发现此内部接口的存在。</p>
<p>而在Map.Entry这个内部接口之中还存在有以下的两个常用方法：</p>
<p>· 取得当前的key：public K getKey()；</p>
<p>· 取得当前的value：public V getValue()。</p>
<p>下面通过一个图形来对比一下Collection和Map接口保存的数据形式。</p>
<p>通过以上的对比可以发现，在Map集合和Collection集合之中保存的最大区别：Collection直接保存的是要操作对象，而Map集合是将保存的key和value变成了一个Map.Entry对象，通过这个对象包装了key和value后保存的，所以根据这一特征，就可以给出<strong>Map使用Iterator输出的操作步骤：</strong></p>
<p><strong>· 使用Map接口中的entrySet()方法，将Map集合变为Set集合；</strong></p>
<p><strong>· 取得了Set接口实例之后就可以利用iterator()方法取得Iterator的实例化对象；</strong></p>
<p><strong>· 使用Iterator迭代找到每一个Map.Entry对象，并进行key和value的分离。</strong></p>
<p><strong>范例：</strong>使用Iterator输出Map集合</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.Hashtable; <strong>import</strong> java.util.Iterator; <strong>import</strong> java.util.Map; <strong>import</strong> java.util.Set; <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { Map&lt;Integer, String&gt; map = <strong>new</strong> Hashtable&lt;Integer, String&gt;(); map.put(3, “张三”); map.put(3, “李四”); // key重复，value会被新内容覆盖 map.put(1, “王五”); map.put(0, “赵六”); Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set = map.entrySet(); Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iter = set.iterator(); <strong>while</strong> (iter.hasNext()) { Map.Entry&lt;Integer, String&gt; me = iter.next(); System.<em>out</em>.println(me.getKey() + “，” + me.getValue()); } } }</th>
</tr>
</thead>
</table>
<p>这种代码在日后的所有开发之中一定会出现，所以必须会。</p>
<p><strong>面试题：</strong>现在在一个List集合之中保存了多个String对象，要求将这个List集合变为Set集合，而后再将这个Set集合之中的全部数据保存在Map集合的value里面，而Map集合的key使用UUID生成，最后将Map中的数据进行迭代输出。</p>
<p><strong>相关说明：</strong></p>
<p>1、 在Collection接口之中存在一个增加一组集合的方法：public boolean<br>addAll(Collection&lt;? extends E&gt; c)；</p>
<p>2、<br>UUID是一种算法，在Java中有指定的类，这个类可以根据时间戳生成一个几乎不会重复的字符串；</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.ArrayList; <strong>import</strong> java.util.HashMap; <strong>import</strong> java.util.HashSet; <strong>import</strong> java.util.Iterator; <strong>import</strong> java.util.List; <strong>import</strong> java.util.Map; <strong>import</strong> java.util.Set; <strong>import</strong> java.util.UUID; <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { List&lt;String&gt; list = <strong>new</strong> ArrayList&lt;String&gt;(); list.add(“Hello”); list.add(“Hello”); list.add(“World”); Set&lt;String&gt; set = <strong>new</strong> HashSet&lt;String&gt;(); set.addAll(list); // 将List集合加到Set之中 Map&lt;UUID, String&gt; map = <strong>new</strong> HashMap&lt;UUID, String&gt;(); Iterator&lt;String&gt; iter = set.iterator(); <strong>while</strong> (iter.hasNext()) { map.put(UUID.<em>randomUUID</em>(), iter.next()); } // 数据保存到Map集合 Iterator&lt;Map.Entry&lt;UUID, String&gt;&gt; iterMap = map.entrySet().iterator(); <strong>while</strong> (iterMap.hasNext()) { Map.Entry&lt;UUID, String&gt; me = iterMap.next(); System.<em>out</em>.println(me.getKey() + “ –&gt; “ + me.getValue()); } } }</th>
</tr>
</thead>
</table>
<p>就是把几个集合互相折腾了一番。</p>
<p><strong>3.6.4、关于Map中保存key的说明</strong></p>
<p>通过程序可以发现，之前的Map集合之中都是使用了系统类作为了Map的key，那么实际上用户也可以使用自定义的类作为key出现，可是如果要想作为key的类必须注意一点：因为key属于查找操作，所以要想找到符合的key，那么作为key所在的类就必须覆写Object类之中的两个方法：hashCode()、equals()。</p>
<p><strong>范例：</strong>自定义类作为key</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.HashMap; <strong>import</strong> java.util.Map; <strong>class</strong> Person { <strong>private</strong> String name; <strong>public</strong> Person(String name) { <strong>this</strong>.name = name; } @Override <strong>public</strong> String toString() { <strong>return</strong> “姓名：” + <strong>this</strong>.name; } @Override <strong>public int</strong> hashCode() { <strong>final int</strong> prime = 31; <strong>int</strong> result = 1; result = prime * result + ((name == <strong>null</strong>) ? 0 : name.hashCode()); <strong>return</strong> result; } @Override <strong>public boolean</strong> equals(Object obj) { <strong>if</strong> (<strong>this</strong> == obj) <strong>return true</strong>; <strong>if</strong> (obj == <strong>null</strong>) <strong>return false</strong>; <strong>if</strong> (getClass() != obj.getClass()) <strong>return false</strong>; Person other = (Person) obj; <strong>if</strong> (name == <strong>null</strong>) { <strong>if</strong> (other.name != <strong>null</strong>) <strong>return false</strong>; } <strong>else if</strong> (!name.equals(other.name)) <strong>return false</strong>; <strong>return true</strong>; } } <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { Map&lt;Person, String&gt; map = <strong>new</strong> HashMap&lt;&gt;(); map.put(<strong>new</strong> Person(“张三”), <strong>new</strong> String(“zs”)); System.<em>out</em>.println(map.get(<strong>new</strong> Person(“张三”))); } }</th>
</tr>
</thead>
</table>
<p>但是这种程序也只是作为学习之中的概念出现，而在实际的开发之中，永远都是String作为key，因为最方便。</p>
<p><strong>3.7、Stack类（理解）</strong></p>
<p>Stack是栈，栈是一种先进后出的数据结构，Stack类的定义如下：</p>
<table>
<thead>
<tr>
<th>public class Stack&lt;E&gt; extends Vector&lt;E&gt;</th>
</tr>
</thead>
</table>
<p>可以发现Stack类属于Vector的子类，但是使用的时候却不使用Vector类定义的方法，而使用Stack类自己的方法：</p>
<p>· 入栈操作：public E push(E item)；</p>
<p>· 出栈操作：public E pop()；</p>
<p><strong>范例：</strong>观察栈的基本操作</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.Stack; <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { Stack&lt;String&gt; all = <strong>new</strong> Stack&lt;&gt;(); all.add(“A”); all.add(“B”); all.add(“C”); System.<em>out</em>.println(all.pop()); System.<em>out</em>.println(all.pop()); System.<em>out</em>.println(all.pop()); System.<em>out</em>.println(all.pop()); // 没数据了，出现EmptyStackException } }</th>
</tr>
</thead>
</table>
<p>对于栈这一概念在自己编写的代码之中使用不多，不过以后的学习都会出现栈的概念，例如：在Android开发之中，多个Activity之间的互相调用和返回就是利用了栈。</p>
<p><strong>3.8、Collections类（了解）</strong></p>
<p>Collections是专门提供的一个集合的工具类，并没有实现Collection接口，但是在这个类之中，有许多的操作方法，可以方便的进行集合的操作（根本没用）。</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.ArrayList; <strong>import</strong> java.util.Collections; <strong>import</strong> java.util.List; <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { List&lt;String&gt; all = <strong>new</strong> ArrayList&lt;String&gt;(); Collections.<em>addAll</em>(all, “A”, “B”, “C”); System.<em>out</em>.println(all); Collections.<em>reverse</em>(all) ; System.<em>out</em>.println(all); } }</th>
</tr>
</thead>
</table>
<p><strong>面试题：</strong>请解释Collection和Collections的区别？</p>
<p>· Collection是一个接口，用于定义集合操作的标准；</p>
<p>· Collections是一个工具类，可以操作任意的集合对象。</p>
<p><strong>3.9、属性操作类：Properties（理解）</strong></p>
<p>属性一般都是指的是针对于字符串数据，并且所有的字符串数据都会按照“key =<br>value”的形式保存，属性操作类主要是针对于属性文件完成的。Properties类本身是Hashtable的子类：</p>
<table>
<thead>
<tr>
<th>public class Properties extends Hashtable&lt;Object,Object&gt;</th>
</tr>
</thead>
</table>
<p>但是在使用方法上操作的并不是由Map接口定义的方法，使用Properties自己的方法：</p>
<p>· 设置属性：public Object setProperty(String key, String value)；</p>
<p>· 取得属性：public String getProperty(String key)，如果没有指定的key返回null；</p>
<p>· 取得属性：public String getProperty(String key, String<br>defaultValue)，如果没有指定的key，返回默认值。</p>
<p><strong>范例：</strong>观察属性的设置和取得</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.util.Properties; <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { Properties pros = <strong>new</strong> Properties(); pros.setProperty(“BJ”, “ BeiJing “); pros.setProperty(“SH”, “上海”); System.<em>out</em>.println(pros.getProperty(“BJ”)); System.<em>out</em>.println(pros.getProperty(“TJ”)); System.<em>out</em>.println(pros.getProperty(“TJ”, “没有发现”)); } }</th>
</tr>
</thead>
</table>
<p>但是使用Properties类最方便的特点是可以直接将这些属性以OutputStream的方式或InputStream的方式输出或读取：</p>
<p>· 向输出流中输出属性：public void store(OutputStream out, String comments)<br>throws IOException；</p>
<p>· 从输入流中读取属性：public void load(InputStream inStream) throws<br>IOException。</p>
<p><strong>范例：</strong>将属性保存到文件之中，一般保存属性文件的后缀都是“*.properties”</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.io.File; <strong>import</strong> java.io.FileOutputStream; <strong>import</strong> java.util.Properties; <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { Properties pros = <strong>new</strong> Properties(); pros.setProperty(“BJ”, “ BeiJing “); pros.setProperty(“SH”, “上海”); pros.store(<strong>new</strong> FileOutputStream(<strong>new</strong> File(“D:” + File.<em>separator</em> + “area.properties”)), “Area Info”); } }</th>
</tr>
</thead>
</table>
<p><strong>范例：</strong>通过属性文件读取内容</p>
<table>
<thead>
<tr>
<th><strong>package</strong> cn.mldn.demo; <strong>import</strong> java.io.File; <strong>import</strong> java.io.FileInputStream; <strong>import</strong> java.util.Properties; <strong>public class</strong> TestDemo { <strong>public static void</strong> main(String[] args) <strong>throws</strong> Exception { Properties pros = <strong>new</strong> Properties(); pros.load(<strong>new</strong> FileInputStream(<strong>new</strong> File(“D:” + File.<em>separator</em> + “area.properties”))); System.<em>out</em>.println(pros.getProperty(“BJ”)); System.<em>out</em>.println(pros.getProperty(“TJ”)); System.<em>out</em>.println(pros.getProperty(“TJ”, “没有发现”)); } }</th>
</tr>
</thead>
</table>
<p>在日后的开发之中，一些框架会帮助用户自动的编写读取属性的操作，所以用户以后最关心的只是修改属性文件的工作，这一点在日后的Struts、Spring中都会见到。</p>
<p><strong>4、总结</strong></p>
<p>1、 Collection负责输出、Map负责查找；</p>
<p>2、 集合的输出就使用Iterator完成。</p>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Kilitom</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://kilitom.github.io/2020/08/10/lei-ji-kuang-jia/">https://kilitom.github.io/2020/08/10/lei-ji-kuang-jia/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Kilitom</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/08/10/jdbc/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            3.1、JDBC的简介（理解）
JDBC是Java数据库连接服务，主要是一个由Java程序操作数据库的执行标准，所以在这个JDBC的开发包java.sql包之中，所有的组成几乎都是接口，那么不同的数据库如果要想使用java开发，就必须实现这
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-08-10
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Kilitom
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/08/10/mian-xiang-dui-xiang-05/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            3.1、继承性（重点）继承性是面向对象的第二大主要特征。
3.1.1、继承问题的引出任何的概念出现都有其自己的目的以及可以结局的问题范畴，那么下面首先编写两个程序：Person类、Student类。



Person.java：
Stud
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-08-10
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Kilitom
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="/about" target="_blank">Kilitom</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/kilitom" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:942709413@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=942709413" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 942709413" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
