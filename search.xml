<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java集合</title>
      <link href="/2020/08/11/java-ji-he/"/>
      <url>/2020/08/11/java-ji-he/</url>
      
        <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><pre><code>ArrayList LinkedList  HashSet  HashMap主要接口:Collection  List  Set  Maplist.size();//获取集合长度list.get();//获取某个索引的元素list.add();//添加元素</code></pre><h2 id="队列分两种结构"><a href="#队列分两种结构" class="headerlink" title="队列分两种结构"></a>队列分两种结构</h2><pre><code>循环数组: 查询快,增删慢链表结构: 插入删除快,查询慢collection顺序是无序的</code></pre><h2 id="Set集合-继承-Collection接口"><a href="#Set集合-继承-Collection接口" class="headerlink" title="Set集合 继承 Collection接口"></a>Set集合 继承 Collection接口</h2><pre><code>元素不能重复add()添加元素remove()删除元素size()集合大小不能通过索引添加元素不能通过索引删除元素存储的数据是无序的</code></pre><h2 id="Map接口-不继承Collection接口-HashSet散列表结构存储"><a href="#Map接口-不继承Collection接口-HashSet散列表结构存储" class="headerlink" title="Map接口 不继承Collection接口(HashSet散列表结构存储,"></a>Map接口 不继承Collection接口(HashSet散列表结构存储,</h2><pre><code> TreeMap使用数状结构,允许快速检索) 用与维护键值对key不可重复 value可以重复</code></pre><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><h5 id="put-Object-key-Object-value-添加元素"><a href="#put-Object-key-Object-value-添加元素" class="headerlink" title="put(Object key,Object value) 添加元素"></a>put(Object key,Object value) 添加元素</h5><h5 id="enterSet-获取键值对集合"><a href="#enterSet-获取键值对集合" class="headerlink" title="enterSet() 获取键值对集合"></a>enterSet() 获取键值对集合</h5><p><img src="/2020/08/11/java-ji-he/clip_image001.png" alt="enterSet() 遍历"></p><h5 id="keySet-获取键集合"><a href="#keySet-获取键集合" class="headerlink" title="keySet() 获取键集合"></a>keySet() 获取键集合</h5><p><img src="/2020/08/11/java-ji-he/clip_image002.png" alt="keySet()遍历"></p><h5 id="values-获取值的集合"><a href="#values-获取值的集合" class="headerlink" title="values()  获取值的集合"></a>values()  获取值的集合</h5><p><img src="/2020/08/11/java-ji-he/clip_image003.png" alt="values() 遍历"></p><h5 id="TreeSet不能存空键"><a href="#TreeSet不能存空键" class="headerlink" title="TreeSet不能存空键"></a>TreeSet不能存空键</h5><h5 id="Collection和Arrays是辅助类"><a href="#Collection和Arrays是辅助类" class="headerlink" title="Collection和Arrays是辅助类"></a>Collection和Arrays是辅助类</h5><h5 id="Array-sort-升序排序"><a href="#Array-sort-升序排序" class="headerlink" title="Array.sort()升序排序"></a>Array.sort()升序排序</h5><h2 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h2><h5 id="Iterator遍历List集合"><a href="#Iterator遍历List集合" class="headerlink" title="Iterator遍历List集合"></a>Iterator遍历List集合</h5><h5 id="Interator无序-子接口ListIterator有序"><a href="#Interator无序-子接口ListIterator有序" class="headerlink" title="Interator无序 子接口ListIterator有序"></a>Interator无序 子接口ListIterator有序</h5><p><img src="/2020/08/11/java-ji-he/clip_image004.png" alt="Iterator遍历"></p><h2 id="在集合中常见的数据结构-掌握"><a href="#在集合中常见的数据结构-掌握" class="headerlink" title="在集合中常见的数据结构(掌握)"></a>在集合中常见的数据结构(掌握)</h2><pre><code>  ArrayXxx:底层数据结构是数组，查询快，增删慢  LinkedXxx:底层数据结构是链表，查询慢，增删快  HashXxx:底层数据结构是哈希表。依赖两个方法：hashCode()和equals()  TreeXxx:底层数据结构是二叉树。两种方式排序：自然排序和比较器排序</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常</title>
      <link href="/2020/08/10/java-yi-chang/"/>
      <url>/2020/08/10/java-yi-chang/</url>
      
        <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常发生的原因"><a href="#异常发生的原因" class="headerlink" title="异常发生的原因"></a>异常发生的原因</h2><pre><code>用户输入了非法数据。要打开的文件不存在。网络通信时连接中断，或者JVM内存溢出</code></pre><h2 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h2><h3 id="Erreo-错误"><a href="#Erreo-错误" class="headerlink" title="Erreo(错误)"></a>Erreo(错误)</h3><pre><code>Error（错误）：JVM系统内部错误、资源耗尽等严重情况</code></pre><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><pre><code>因编程错误或偶然的外在因素导致的一般性问题所有的异常类是从 java.lang.Exception 类继承的子类Exception 类是 Throwable 类的子类比如：IOException，RuntimeException</code></pre><h5 id="public-String-getMessage-返回关于发生的异常的详细信息"><a href="#public-String-getMessage-返回关于发生的异常的详细信息" class="headerlink" title="public String getMessage()返回关于发生的异常的详细信息"></a>public String getMessage()返回关于发生的异常的详细信息</h5><h5 id="public-void-printStackTrace-打印toString-结果和栈层次到System-err，即错误输出流"><a href="#public-void-printStackTrace-打印toString-结果和栈层次到System-err，即错误输出流" class="headerlink" title="public void printStackTrace()打印toString()结果和栈层次到System.err，即错误输出流"></a>public void printStackTrace()打印toString()结果和栈层次到System.err，即错误输出流</h5><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h3><pre><code>try&#123;   // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123;  // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123;  // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123;  // 程序代码&#125;</code></pre><h3 id="throws-throw"><a href="#throws-throw" class="headerlink" title="throws/throw"></a>throws/throw</h3><pre><code>如果一个方法没有捕获一个检查性异常，那么该方法必须使用 throws 关键字来声明throws 关键字放在方法签名的尾部也可以使用 throw 关键字抛出一个异常一个方法可以声明抛出多个异常，多个异常之间用逗号隔开</code></pre><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><pre><code>finally 关键字用来创建在 try 代码块后面执行的代码块。无论是否发生异常，finally 代码块中的代码总会被执行。在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。finally 代码块出现在 catch 代码块最后try&#123;  // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123;  // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123;  // 程序代码&#125;finally&#123;  // 程序代码&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类之间的关系</title>
      <link href="/2020/08/07/java-chou-xiang-lei-jie-kou-nei-bu-lei/"/>
      <url>/2020/08/07/java-chou-xiang-lei-jie-kou-nei-bu-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h5 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h5><pre><code>在面向对象的概念中，所有的对象都是通过类来表述，但并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一类具体的对象，这样的类就是抽象类。</code></pre><h5 id="抽象类需要注意以下几点："><a href="#抽象类需要注意以下几点：" class="headerlink" title="抽象类需要注意以下几点："></a>抽象类需要注意以下几点：</h5><pre><code>abstract放在class前，指明该类是抽象类；abstract放在方法声明中，则该方法是抽象方法，抽象方法没有方法体；一个抽象类可以含有多个抽象方法，也可以含有已实现的方法。</code></pre><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h5 id="接口概述"><a href="#接口概述" class="headerlink" title="接口概述"></a>接口概述</h5><pre><code>Java是单继承的语言，利用接口可以模拟多继承；接口是对抽象类的进一步抽象，是方法声明和常量的定义集合；接口是一种行为规范，是一种“契约”；</code></pre><h5 id="具体格式如下所示："><a href="#具体格式如下所示：" class="headerlink" title="具体格式如下所示："></a>具体格式如下所示：</h5><pre><code>&lt;访问符&gt; interface 接口名 &#123;    [访问符] &lt;返回类型&gt; 方法名([参数列表])；    ......&#125;</code></pre><h6 id="注意：在定义接口的时候，接口中的所有方法和常量自动定义为public；接口中定义的变量默认是public-static-final-型，且必须赋初值-。"><a href="#注意：在定义接口的时候，接口中的所有方法和常量自动定义为public；接口中定义的变量默认是public-static-final-型，且必须赋初值-。" class="headerlink" title="注意：在定义接口的时候，接口中的所有方法和常量自动定义为public；接口中定义的变量默认是public static final 型，且必须赋初值 。"></a>注意：在定义接口的时候，接口中的所有方法和常量自动定义为public；接口中定义的变量默认是public static final 型，且必须赋初值 。</h6><h5 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h5><pre><code>接口的使用通过“implements”关键字来实现，示例代码如下 public class MyClass implements MyInterface &#123;    public void add(int x, int y) &#123;        // do something    &#125;    public void volume(int x, int y, int z) &#123;        // do something    &#125;&#125;</code></pre><h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><pre><code>通过实现多个接口来实现多重继承，示例代码如下 ：public class MyClass2 implements MyInterface, MultiInterface&#123;    ......//实现多个接口中的所有方法&#125;</code></pre><table><thead><tr><th></th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>相同点</td><td>只被继承  不能通过new方式实例化变量可以引用具体实现类的实例</td><td></td></tr><tr><td>不同点属性</td><td>可以定义任意属性可以重新定义或赋值</td><td>默认是常量,用public static final修饰的,必须赋初值</td></tr><tr><td>不同点方法</td><td>可以由抽象方法和已实现的方法</td><td>方法均只有方法声明吗,没有方法体;不存在以实现的方法</td></tr><tr><td>不同点继承</td><td>extends来表示继承抽象类只能继承一个父类继承抽象类的同时必须实现抽象类中的所有方法</td><td>implements来实现接口;实现接口的同时实现接口中的所有方法</td></tr><tr><td>不同点静态</td><td>可以有静态代码块和静态方法</td><td>不能有静态代码块和静态方法</td></tr><tr><td>总结</td><td>接口不是类   单继承的多实现</td><td></td></tr></tbody></table><h6 id="抽象类的子类可以是一个抽象类也可以是一个具体实现类"><a href="#抽象类的子类可以是一个抽象类也可以是一个具体实现类" class="headerlink" title="抽象类的子类可以是一个抽象类也可以是一个具体实现类"></a>抽象类的子类可以是一个抽象类也可以是一个具体实现类</h6><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h5 id="1-成员内部类"><a href="#1-成员内部类" class="headerlink" title="1.成员内部类"></a>1.成员内部类</h5><h5 id="成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式："><a href="#成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：" class="headerlink" title="　　成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式："></a>　　成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> radius <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token keyword">double</span> radius<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>radius <span class="token operator">=</span> radius<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">class</span> <span class="token class-name">Draw</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//内部类</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drawSahpe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"drawshape"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h5 id="2-局部内部类"><a href="#2-局部内部类" class="headerlink" title="2.局部内部类"></a>2.局部内部类</h5><h5 id="局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。"><a href="#局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。" class="headerlink" title="　　局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。"></a>　　局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">People</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">People</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Man</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> People <span class="token function">getWoman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">People</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//局部内部类</span>            <span class="token keyword">int</span> age <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h5 id="3-匿名内部类"><a href="#3-匿名内部类" class="headerlink" title="3.匿名内部类"></a>3.匿名内部类</h5><h5 id="匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听代码："><a href="#匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听代码：" class="headerlink" title="　　匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听代码："></a>　　匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听代码：</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>View v<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类之间的关系</title>
      <link href="/2020/08/06/java-lei-zhi-jian-de-guan-xi/"/>
      <url>/2020/08/06/java-lei-zhi-jian-de-guan-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><pre><code>父类---&gt;子类超类---&gt;派生类关键字:extends</code></pre><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><pre><code>当一个子类继承了一个父类时，可以在子类中直接使用父类的属性和方法。如果父类的方法无法满足子类的需求，则可以在子类中对父类的方法进行改造，也称作重写（override）。重写是Java多态性的另一种体现。</code></pre><h5 id="重写的原则"><a href="#重写的原则" class="headerlink" title="重写的原则"></a>重写的原则</h5><pre><code>重写的方法的签名必须要和被重写的方法的签名完全匹配；重写的方法的返回值必须和被重写的方法的返回一致或者是其子类；重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类；私有方法不能被重写子类重写父类方法的过程中，可访问性只能一样或变的更公开。</code></pre><h5 id="子类向父类的转换为向上转型"><a href="#子类向父类的转换为向上转型" class="headerlink" title="子类向父类的转换为向上转型"></a>子类向父类的转换为向上转型</h5><h5 id="向上转型语法"><a href="#向上转型语法" class="headerlink" title="向上转型语法"></a>向上转型语法</h5><pre><code>父类型 引用变名=new 子类型();</code></pre><h6 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h6><pre><code>子类转父类规则将一个父类的引用指向子类对象,称为向上转型,自动进行类型转换此时通过父类引用变量调用的是子类覆盖或继承父类的方法,不是父类的方法此时通过父类型引用变量无法调用子类特有的方法</code></pre><h5 id="super关键字-代表父类对象-通过使用super关键字可以访问父类属性或方法-也可以在子类构造方法中调用父类的构造方法以便初始化父类继承的属性"><a href="#super关键字-代表父类对象-通过使用super关键字可以访问父类属性或方法-也可以在子类构造方法中调用父类的构造方法以便初始化父类继承的属性" class="headerlink" title="super关键字:代表父类对象,通过使用super关键字可以访问父类属性或方法,也可以在子类构造方法中调用父类的构造方法以便初始化父类继承的属性."></a>super关键字:代表父类对象,通过使用super关键字可以访问父类属性或方法,也可以在子类构造方法中调用父类的构造方法以便初始化父类继承的属性.</h5><h5 id="final关键字-不可改变的一旦定义不能改变"><a href="#final关键字-不可改变的一旦定义不能改变" class="headerlink" title="final关键字:不可改变的一旦定义不能改变"></a>final关键字:不可改变的一旦定义不能改变</h5><table><thead><tr><th>重载</th><th>重写</th></tr></thead><tbody><tr><td>同一类中多态的体现</td><td>不同类中多态的体现</td></tr><tr><td>定义:同一类中,方法名相同 参数个数 类型 顺序不同</td><td>定义:父类中方法,不能满足子类的要求.子类对此方法进行改造 方法名相同 参数个数 类型 顺序也相同</td></tr><tr><td>返回类型不影响重载</td><td>重写方法返回值类型必须与父类一致</td></tr><tr><td></td><td>父类中方法需要抛出异常子类必定抛出异常</td></tr></tbody></table><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><h6 id="所有类的顶级父类"><a href="#所有类的顶级父类" class="headerlink" title="所有类的顶级父类"></a>所有类的顶级父类</h6><table><thead><tr><th>方法名</th><th>功能说明</th></tr></thead><tbody><tr><td>boolean equals(Object obj)</td><td>比较两个类变量所指向的是否为同一个对象，是则返回true</td></tr><tr><td>Class getClass()</td><td>获取当前对象所属类的信息，返回Class对象</td></tr><tr><td>String toString()</td><td>将调用toString()方法的对象转换成字符串</td></tr><tr><td>Object clone()</td><td>生成当前对象的一个备份，并返回这个副本</td></tr><tr><td>int hashCode()</td><td>返回该对象的哈希代码值</td></tr></tbody></table><pre><code>equals：（引用类型会对equals重写比较内容而不是比较地址）     public boolean equals(Object obj) &#123;            return (this == obj);        &#125;    ==：①比较基本数据类型②比较引用类型的地址</code></pre><h5 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h5><pre><code>    Object类中定义了public String toString()方法，其返回值是String类型，描述当前对象的有关信息，在进行String与其他类型数据（引用类型）的连接操作时 ，将自动调用该对象类的toString()方法，默认情况下toString()方法返回的字符串格式是“类名@哈希码”，一般情况下需要重写toString()方法。toString()方法实例    重新定义Person类，并重写其toString()方法public class Person &#123;    // 姓名    public String name;    // 年龄    private int age;    // 性别    private String gender;    //get或set等方法省略    public String toString()&#123;        return getClass().getName()+&quot;[name =         &quot;+name+&quot;,age = &quot;+age+&quot;,gender = &quot;+gender+&quot;]&quot;;    &#125;    public static void main(String[] args) &#123;        Person tom = new Person(&quot;tom&quot;, 23, &quot;male&quot;);        System.out.println(tom);    &#125;&#125;</code></pre><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><pre><code>多态的重要表现就是方法的重写存在的三个必要条件:    继承    重写    父类引用指向子类对象</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象</title>
      <link href="/2020/08/05/java-mian-xiang-dui-xiang/"/>
      <url>/2020/08/05/java-mian-xiang-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><pre><code>封装就是把对象的属性（状态）和方法（行为）结合在一起，并尽可能隐蔽对象的内部细节，成为一个不可分割的独立单位（即对象），对外形成一个边界，只保留有限的对外接口使之与外部发生联系。</code></pre><h2 id="封装的原则"><a href="#封装的原则" class="headerlink" title="封装的原则"></a>封装的原则</h2><pre><code>使对象以外的部分不能随意存取对象的内部数据，从而有效的避免了外部错误对它的“交叉感染”。数据隐藏特性提升了系统安全性，使软件错误能够局部化，减少查错和排错的难度。 </code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><pre><code>继承是软件重用的一种形式</code></pre><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><pre><code>多态是指在父类中定义的属性或方法被子类继承之后，可以具有不同的表现行为。</code></pre><h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><pre><code>类是对象的模板,对象是类的实例</code></pre><h5 id="类由属性和方法构成"><a href="#类由属性和方法构成" class="headerlink" title="类由属性和方法构成"></a>类由属性和方法构成</h5><pre><code>对象--&gt;成员变量--&gt;属性 类的方法是对象执行操作的一种规范</code></pre><h5 id="Java中声明类的格式"><a href="#Java中声明类的格式" class="headerlink" title="Java中声明类的格式"></a>Java中声明类的格式</h5><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span>访问符<span class="token punctuation">]</span> <span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> <span class="token keyword">class</span> <span class="token operator">&lt;</span>类名<span class="token operator">></span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>         <span class="token punctuation">[</span>属性<span class="token punctuation">]</span>         <span class="token punctuation">[</span>方法<span class="token punctuation">]</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h5 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h5><pre><code>声明一个变量创建该对象,并把该对象的引用赋给声明好的变量.这是通过new运算符实现的</code></pre><h5 id="创建对象的三种方式"><a href="#创建对象的三种方式" class="headerlink" title="创建对象的三种方式"></a>创建对象的三种方式</h5><pre class=" language-java"><code class="language-java">Rectangle rect1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Rectangle rect2<span class="token punctuation">;</span>rect2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Rectangle rect3 <span class="token operator">=</span> null<span class="token punctuation">;</span>rect3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><pre><code>构造方法在对象被创建时用来初始化对象；与类名相同没有返回类型；构造方法是初始化一个对象的内部状态。</code></pre><h6 id="如果在类中没有定义任何的构造方法，则编译器将会自动加上一个无参构造方法-；一旦创建了自己的构造方法，缺省的构造方法将不复存在，如果需要则手动添加无参构造方法。"><a href="#如果在类中没有定义任何的构造方法，则编译器将会自动加上一个无参构造方法-；一旦创建了自己的构造方法，缺省的构造方法将不复存在，如果需要则手动添加无参构造方法。" class="headerlink" title="如果在类中没有定义任何的构造方法，则编译器将会自动加上一个无参构造方法 ；一旦创建了自己的构造方法，缺省的构造方法将不复存在，如果需要则手动添加无参构造方法。"></a>如果在类中没有定义任何的构造方法，则编译器将会自动加上一个无参构造方法 ；一旦创建了自己的构造方法，缺省的构造方法将不复存在，如果需要则手动添加无参构造方法。</h6><h5 id="this调用的是本类中的对象或者方法"><a href="#this调用的是本类中的对象或者方法" class="headerlink" title="this调用的是本类中的对象或者方法"></a>this调用的是本类中的对象或者方法</h5><h5 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h5><pre class=" language-java"><code class="language-java">Rectangle rectangle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span></code></pre><h5 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h5><pre><code>方法是类行为的体现，其他对象可以根据类的方法对类进行访问。类的方法包括方法的说明和方法的实现两部分 ，格式如下所示：[access]  [modifiers] &lt;return_type&gt; methodName ([&lt;argu_list&gt;])  &#123;&#125;</code></pre><h6 id="方法的返回类型是该方法运行后返回值的数据类型；如果方法没有返回值，则方法的返回类型为void。"><a href="#方法的返回类型是该方法运行后返回值的数据类型；如果方法没有返回值，则方法的返回类型为void。" class="headerlink" title="方法的返回类型是该方法运行后返回值的数据类型；如果方法没有返回值，则方法的返回类型为void。"></a>方法的返回类型是该方法运行后返回值的数据类型；如果方法没有返回值，则方法的返回类型为void。</h6><h5 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h5><pre><code>当分配完一个对象后，可以使用点操作符“.”来实现对属性和方法的访问：对象名.属性;//访问对象的属性对象名.方法名();//访问对象的方法</code></pre><h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><h5 id="按值传递-将要传递的参数的值传递给被调方法，被调方法通过创建一份新的内存拷贝来存储传递的值，然后在内存拷贝上进行数值操作，所以按值传递不会改变原始参数的值。"><a href="#按值传递-将要传递的参数的值传递给被调方法，被调方法通过创建一份新的内存拷贝来存储传递的值，然后在内存拷贝上进行数值操作，所以按值传递不会改变原始参数的值。" class="headerlink" title="按值传递 ,将要传递的参数的值传递给被调方法，被调方法通过创建一份新的内存拷贝来存储传递的值，然后在内存拷贝上进行数值操作，所以按值传递不会改变原始参数的值。"></a>按值传递 ,将要传递的参数的值传递给被调方法，被调方法通过创建一份新的内存拷贝来存储传递的值，然后在内存拷贝上进行数值操作，所以按值传递不会改变原始参数的值。</h5><h5 id="引用传递-也称为传地址方法调用时实际参数传递的是对象-这时实际参数与形式参数指向同一个地址-在方法执行中-对形式参数的操作实际上就是对实际参数的操作所以会改变实际参数的值。"><a href="#引用传递-也称为传地址方法调用时实际参数传递的是对象-这时实际参数与形式参数指向同一个地址-在方法执行中-对形式参数的操作实际上就是对实际参数的操作所以会改变实际参数的值。" class="headerlink" title="引用传递,也称为传地址方法调用时实际参数传递的是对象,这时实际参数与形式参数指向同一个地址,在方法执行中,对形式参数的操作实际上就是对实际参数的操作所以会改变实际参数的值。"></a>引用传递,也称为传地址方法调用时实际参数传递的是对象,这时实际参数与形式参数指向同一个地址,在方法执行中,对形式参数的操作实际上就是对实际参数的操作所以会改变实际参数的值。</h5><h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><pre><code>在Java程序中，如果同一个类中存在两个方法同名，方法的签名(参数个数、参数类型、类型排列次序)上也一样，将无法编译通过。但在Java中多个方法重名是允许的，只要保证方法签名不同即可，这种特性称为方法重载（overload）。</code></pre><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><pre><code>方法名相同；参数列表（个数、类型、顺序）不同；</code></pre><h6 id="注意：返回值不影响方法重载。构造方法也可以重载-。"><a href="#注意：返回值不影响方法重载。构造方法也可以重载-。" class="headerlink" title="注意：返回值不影响方法重载。构造方法也可以重载 。"></a>注意：返回值不影响方法重载。构造方法也可以重载 。</h6><h2 id="封装-1"><a href="#封装-1" class="headerlink" title="封装"></a>封装</h2><pre><code>隐藏类的实现细节让使用者只能通过程序员规定的方法来访问数据可以方便的加入存取控制语句,限制不合理操作</code></pre><h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><pre><code>Java中定义了private（私有的）、protected（受保护的）和public（公共的）的访问修饰符，同时也定义了一个缺省的访问级别，用于声明类、属性、方法的访问权限。明确访问修饰符的限制是用好“封装”的关键 ：</code></pre><h5 id="public-可以被同一个项目中所有类访问-具有项目可见性-这是最大的访问权限"><a href="#public-可以被同一个项目中所有类访问-具有项目可见性-这是最大的访问权限" class="headerlink" title="public:可以被同一个项目中所有类访问,具有项目可见性,这是最大的访问权限"></a>public:可以被同一个项目中所有类访问,具有项目可见性,这是最大的访问权限</h5><h5 id="protected-可以被同一个包中的类访问-被同一个项目中不同包中的子类访问"><a href="#protected-可以被同一个包中的类访问-被同一个项目中不同包中的子类访问" class="headerlink" title="protected:可以被同一个包中的类访问,被同一个项目中不同包中的子类访问"></a>protected:可以被同一个包中的类访问,被同一个项目中不同包中的子类访问</h5><h5 id="default-成员变量和方法只能被同一个包里的类访问-具有包可见性"><a href="#default-成员变量和方法只能被同一个包里的类访问-具有包可见性" class="headerlink" title="default:成员变量和方法只能被同一个包里的类访问,具有包可见性"></a>default:成员变量和方法只能被同一个包里的类访问,具有包可见性</h5><h5 id="private-成员变量和方法只能在类内被访问-具有类可见性-。"><a href="#private-成员变量和方法只能在类内被访问-具有类可见性-。" class="headerlink" title="private:成员变量和方法只能在类内被访问,具有类可见性.。"></a>private:成员变量和方法只能在类内被访问,具有类可见性.。</h5><table><thead><tr><th>访问控制</th><th>privata成员</th><th>省缺成员</th><th>protected成员</th><th>public成员</th></tr></thead><tbody><tr><td>同一类中成员</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一包中其他成员</td><td>×</td><td>√</td><td>√</td><td>√</td></tr><tr><td>不同包中子类</td><td>×</td><td>×</td><td>√</td><td>√</td></tr><tr><td>不同包中非子类</td><td>×</td><td>×</td><td>×</td><td>√</td></tr></tbody></table><h2 id="静态变量和方法"><a href="#静态变量和方法" class="headerlink" title="静态变量和方法"></a>静态变量和方法</h2><pre><code>“实例相关”的成员描述的是单个实例的状态和方法，其使用必须要通过类的实例来完成;“类相关”是在类的成员前面加上“static”关键字，从而直接通过类名就可以访问 。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2020/08/04/java-ji-chu/"/>
      <url>/2020/08/04/java-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><h3 id="Java中标识符的命名必须满足以下原则："><a href="#Java中标识符的命名必须满足以下原则：" class="headerlink" title="Java中标识符的命名必须满足以下原则："></a>Java中标识符的命名必须满足以下原则：</h3><pre><code>标识符必须以字母、下划线（_）或美元符（$）开头，后面可以跟字母、数字、下划线或美元符标识符可以包含数字，但不能以数字开头除下划线“_”和“$”符号外，标识符中不包含任何特殊字符，如空格标识符区分大小写，比如，“abc”和“Abc”是两个不同的标识符对于标识符的长度没有限制不能使用Java关键字作为标识符 例如 static public void  main</code></pre><h2 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h2><pre><code>Java中分隔符分为两类：没有意义的空白符 拥有确定含义的普通分隔符</code></pre><table><thead><tr><th align="left">普通分隔符</th><th align="left">名称</th><th align="left">功能说明</th></tr></thead><tbody><tr><td align="left">{}</td><td align="left">大括号</td><td align="left">用来定义程序块，类，方法以及局部范围;</td></tr><tr><td align="left">[]</td><td align="left">中括号</td><td align="left">用来进行数组的声明，也可用来表示撤销对数组的引用;</td></tr><tr><td align="left">()</td><td align="left">小括号</td><td align="left">在定义和调用方法时用来容纳参数表，在控制语句或强制类型转换组成的表达式中用来表示执行或计算的优先级 ;</td></tr><tr><td align="left">;</td><td align="left">分号</td><td align="left">用来表示一条语句的结束 ;在for控制语句中用来将圆括号内的语法连接起来;</td></tr><tr><td align="left">,</td><td align="left">逗号</td><td align="left">在变量声明中，用于分割变量表中的各个变量;在for控制语句中用来将圆括号内的语法连接起来;</td></tr><tr><td align="left">:</td><td align="left">冒号</td><td align="left">说明语句标号。例如在三元运算符中使用;</td></tr></tbody></table><h2 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a>基本数据类型：</h2><h4 id="（1）数值型："><a href="#（1）数值型：" class="headerlink" title="（1）数值型："></a>（1）数值型：</h4><pre><code>  1）整数类型（byte、short、int、long）  2)浮点类型（float、double）  注:long a=1234567890L(末尾加“L”、“l”),否则默认为int型；  float b=2.3f(末尾加“F”、“f”),否则默认为double型；  八进制必须以0（零） 开头；十六必须进制以0X或0x开头（零X或零x）。</code></pre><h4 id="（2）字符型：char型"><a href="#（2）字符型：char型" class="headerlink" title="（2）字符型：char型"></a>（2）字符型：char型</h4><pre><code> 注：每个字符在unicode表中都有相对应的位置，如a在unicode表中的位置是97.  转义字符（是字符就要加单引号）：\ddd:1-3为8进制数据所表示的字符，如\123                               \uxxxx:4位16进制数据所表示的字符，如\u0052                               \&#39;:单引号字符                               \\:反斜杠字符                               \t:垂直制表符，将光标移到下一个制表符的位置                               \r:回车                               \n:换行                               \b:退格                               \f:换页</code></pre><h4 id="（3）布尔型（boolean）"><a href="#（3）布尔型（boolean）" class="headerlink" title="（3）布尔型（boolean）:"></a>（3）布尔型（boolean）:</h4><pre><code> 又称为逻辑类型，只有true和false两个值，表示真和假。</code></pre><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><h4 id="1-常量：在程序执行过程中，其值不能被改变的量。"><a href="#1-常量：在程序执行过程中，其值不能被改变的量。" class="headerlink" title="1.常量：在程序执行过程中，其值不能被改变的量。"></a>1.常量：在程序执行过程中，其值不能被改变的量。</h4><pre><code> (1)常量的声明（定义常量）：1)final 数据类型 常量名称[=值];如final int a=5;    注:1）常量通常也被称为final变量 2）用final定义“成员变量（全局变量）”时，必须立刻设初值，否则会产生编译错误。</code></pre><h4 id="2-变量：在程序执行过程中，其值能被改变的量。"><a href="#2-变量：在程序执行过程中，其值能被改变的量。" class="headerlink" title="2.变量：在程序执行过程中，其值能被改变的量。"></a>2.变量：在程序执行过程中，其值能被改变的量。</h4><pre><code>(1)成员变量（全局变量）：定义在类中；成员变量又分为静态变量和实例变量； 1）静态变量（有static关键字）：有效范围跨类，甚至可达整个程序中（应用程序由若干个类构成）。 2）实例变量（无static关键字）：有效范围当前类。(2)局部变量：定义在方法中。   注：当局部变量名与成员变量名相通时，成员变量将在此方法中暂时失效。</code></pre><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h5 id="1-赋值运算符（-）"><a href="#1-赋值运算符（-）" class="headerlink" title="(1)赋值运算符（=）"></a>(1)赋值运算符（=）</h5><pre><code> 例：int a=3;(将3赋给a)     int b=a+c;(将a+c的和赋给b)     x=y=z=5;(将5的值赋给x、y、z，不建议使用)</code></pre><h5 id="2-算术运算符（-（加）、-（减）、-（乘）、-（除）、-（取余））"><a href="#2-算术运算符（-（加）、-（减）、-（乘）、-（除）、-（取余））" class="headerlink" title="(2)算术运算符（+（加）、-（减）、*（乘）、/（除）、%（取余））"></a>(2)算术运算符（+（加）、-（减）、*（乘）、/（除）、%（取余））</h5><pre><code> 例：12.45f*15=27.45;     45-30=15;     5*3=15;     6/2=3;     12%10=2;</code></pre><h5 id="3-自增、自减运算符（-、–）-操作员必须是一个整型或浮点型变量"><a href="#3-自增、自减运算符（-、–）-操作员必须是一个整型或浮点型变量" class="headerlink" title="(3)自增、自减运算符（++、–）:操作员必须是一个整型或浮点型变量"></a>(3)自增、自减运算符（++、–）:操作员必须是一个整型或浮点型变量</h5><pre><code> 例：假设a=5;以自增为例。     b=++a;//此时a先加1，再赋值给b,所以b=6;     b=a++;//此时a直接赋给b,之后加1，所以b=5;</code></pre><h5 id="4-比较运算符（大于-gt-、小于-lt-、等于-、大于等于-gt-、小于等于-lt-、不等于-）"><a href="#4-比较运算符（大于-gt-、小于-lt-、等于-、大于等于-gt-、小于等于-lt-、不等于-）" class="headerlink" title="(4)比较运算符（大于(&gt;)、小于(&lt;)、等于(==)、大于等于(&gt;=)、小于等于(&lt;=)、不等于(!=)）"></a>(4)比较运算符（大于(&gt;)、小于(&lt;)、等于(==)、大于等于(&gt;=)、小于等于(&lt;=)、不等于(!=)）</h5><pre><code> 例：4&gt;5,结果为false.     4!=5,结果为true. 注：结果为布尔值</code></pre><h5 id="5-逻辑运算符（与-amp-amp-、-amp-、或-、非-）"><a href="#5-逻辑运算符（与-amp-amp-、-amp-、或-、非-）" class="headerlink" title="(5)逻辑运算符（与(&amp;&amp;、&amp;)、或(||)、非(!)）"></a>(5)逻辑运算符（与(&amp;&amp;、&amp;)、或(||)、非(!)）</h5><pre><code> 与：同真为真 或：一真为真 注：1）结果都为布尔值（flase、true）     2）短路运算符（&amp;&amp;）：第一个为假，就不再判断第二个。        非短路运算符（&amp;）：第一个为假，依然判断第二个，相比之下更浪费时间。</code></pre><h5 id="6-三元运算符（条件式？值1：值2）：等价于if…-else语句"><a href="#6-三元运算符（条件式？值1：值2）：等价于if…-else语句" class="headerlink" title="(6)三元运算符（条件式？值1：值2）：等价于if…..else语句"></a>(6)三元运算符（条件式？值1：值2）：等价于if…..else语句</h5><pre><code> 例：int y=a&gt;b?x+1:x-1;    含义：如果a&gt;b成立，y=x+1;否则y=x-1；</code></pre><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h5 id="（1）隐式类型转换（自动类型转换）"><a href="#（1）隐式类型转换（自动类型转换）" class="headerlink" title="（1）隐式类型转换（自动类型转换）"></a>（1）隐式类型转换（自动类型转换）</h5><pre><code> 例：int a=3;     float x=a;     执行结果为3.0</code></pre><h5 id="（2）显式类型转换（强制类型转换）"><a href="#（2）显式类型转换（强制类型转换）" class="headerlink" title="（2）显式类型转换（强制类型转换）"></a>（2）显式类型转换（强制类型转换）</h5><pre><code>例：int a=(int)4.25;    执行结果为：4</code></pre><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h5 id="分支语句-if-else-switch"><a href="#分支语句-if-else-switch" class="headerlink" title="分支语句 if-else , switch"></a>分支语句 if-else , switch</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span>     statement1<span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token keyword">else</span>      statement2<span class="token punctuation">;</span><span class="token punctuation">]</span> <span class="token keyword">switch</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token string">'value1'</span><span class="token operator">:</span>       statement1<span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token string">'value2 '</span><span class="token operator">:</span>       statement2<span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>     <span class="token keyword">case</span> <span class="token string">'valueN'</span><span class="token operator">:</span>       statementN<span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>   <span class="token punctuation">[</span><span class="token keyword">default</span><span class="token operator">:</span>defaultStatement<span class="token punctuation">;</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h5 id="迭代语句-while-do-while-for"><a href="#迭代语句-while-do-while-for" class="headerlink" title="迭代语句 while , do-while , for"></a>迭代语句 while , do-while , for</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    statement<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">do</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    statement<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span>initialization；condition；update<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     statements<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h5 id="转移语句-break-continue-return"><a href="#转移语句-break-continue-return" class="headerlink" title="转移语句 break , continue , return"></a>转移语句 break , continue , return</h5><pre><code>   break语句：在循环中用于立即从当前循环终止控制；   continue语句：从其调用处跳至循环的开始处；   return语句 ：其之后的语句将不再执行；   Java中没有goto语句，在多层循环时，可以用break、continue实现goto语句的功能。</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre><code>属于引用数据类型;由类型相同的元素组成的有顺序的数据集合;数组的长度是固定的,不能扩展;可以存储基本数据库类型或对象;</code></pre><h5 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h5><pre><code>data_type[] varName;或data_type varName[];示例:int a[];double b[];</code></pre><h5 id="利用new来为数组型变量分配内存空间"><a href="#利用new来为数组型变量分配内存空间" class="headerlink" title="利用new来为数组型变量分配内存空间"></a>利用new来为数组型变量分配内存空间</h5><pre><code>a= new int[10];double b = new double[10];</code></pre><h5 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h5><pre><code>静态初始化int[] k = &#123;1,2,3,4&#125;或int k[] = new int&#123;1,2,3,4&#125;动态初始化int array = new int[2];array[0] = 1;array[1] = 2;</code></pre><h5 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h5><pre><code>使用循环语句进行复制    使用循环语句遍历源数组每个元素，赋值给目标数组对应位置。使用clone()方法    在Java中，Object类是所有类的父类，其clone()方法一般用于创建并返回此对象的一个副本，Java中认为一切都是“对象”，所以使用该方法也可以实现数组的复制。使用System.arraycopy方法    arraycopy()方法是System类的一个静态方法（并且是本地方法，效率非常高），其可以方便的实现数组拷贝功能System.arraycopy()方法的结构如下：    System.arraycopy(from, fromIndex, to, toIndex, count)</code></pre><h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h5><h6 id="如果一维数组元素的数据类型还是一维数组的话，这种数组就被称为二维数组。二维数组定义语法如下："><a href="#如果一维数组元素的数据类型还是一维数组的话，这种数组就被称为二维数组。二维数组定义语法如下：" class="headerlink" title="如果一维数组元素的数据类型还是一维数组的话，这种数组就被称为二维数组。二维数组定义语法如下："></a>如果一维数组元素的数据类型还是一维数组的话，这种数组就被称为二维数组。二维数组定义语法如下：</h6><pre><code>    data_type[ ][ ] varName;</code></pre><h6 id="动态初始化二维数组"><a href="#动态初始化二维数组" class="headerlink" title="动态初始化二维数组"></a>动态初始化二维数组</h6><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 定义二维数组</span>   <span class="token keyword">int</span><span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">[</span> <span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>             array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 把1,2,3,4分别赋给array[i][j]</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h5 id="Scanner类-获取控制台输入。它是一个工具类，属于java-util包。"><a href="#Scanner类-获取控制台输入。它是一个工具类，属于java-util包。" class="headerlink" title="Scanner类:获取控制台输入。它是一个工具类，属于java.util包。"></a>Scanner类:获取控制台输入。它是一个工具类，属于java.util包。</h5><pre><code>用法：Scanner console = new Scanner(System.in);//定义一个Scanner类方法: console.nextInt();//输入整数      console.nextLine();//输入字符串      console.nextDouble() ;//输入小数</code></pre><h5 id="Random类-实现的随机算法是伪随机，也就是有规则的随机"><a href="#Random类-实现的随机算法是伪随机，也就是有规则的随机" class="headerlink" title="Random类:实现的随机算法是伪随机，也就是有规则的随机"></a>Random类:实现的随机算法是伪随机，也就是有规则的随机</h5><pre><code>用法：Random random = new Random();方法： random.nextInt();//随机整数      random.nextInt(int n);//随机返回[0，n)之间的整数      random. nextDouble();//随机返回[0.0,1.0)之间的小数</code></pre><h5 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h5><pre><code>Math.random()是令系统随机选取大于等于 0.0 且小于 1.0 的伪随机 double 值公式：Math.random()*(n-m)+m，生成大于等于m小于n的随机数；Math.abs();//绝对值Math.sqrt();//立方根Math.max();//两者之间较大的Math.min();//两者之间较小的Math.random();//随机数Math.pow();//幂Math.ceil();//向上取整Math.floor();//向下取整Math.round();//四舍五入</code></pre><h2 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h2><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><pre><code>charAt(int index)//返回执行下标index对应的字符concat(String str)//连接两个字符串返回组合后的字符串endsWith(String suffix)//判断字符是否以suffix结尾 true/falsestartWith(String suffix)//判断字符是否以suffix开头 true/falseequals(Obgect obj)//判断两个字符是否相等,true/falseindexOf(String suffix)//返回字串suffix对应的下标lastindexOf(String suffix)//返回字串suffix最后一次出现的位置length()//返回字符串的长度matches(String regex)//判断字符串是否与正则表达式相等replace(char oldChar,char newChar)//字符串中旧的字串oldChar替换为新的字串newCharsplit(String regex)//按regex对应字符串进行拆分,返回子字符数组substring(int beginIndex,int endIndex)//截取指示下标范围内的字串返回子字符串[)trim()//去空格</code></pre><h5 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h5><pre><code>StringBuilder:不支持并发操作,线程不安全,不适合多线程使用StringBuffer:支持并发操作,线程安全,适合多线程使用</code></pre><h6 id="总结-若操作少量的数据可以使用String-若操作大量数据且要求数据线程安全的情况下-必须使用StringBuffer-其他情况使用StringBuilder"><a href="#总结-若操作少量的数据可以使用String-若操作大量数据且要求数据线程安全的情况下-必须使用StringBuffer-其他情况使用StringBuilder" class="headerlink" title="总结:若操作少量的数据可以使用String;若操作大量数据且要求数据线程安全的情况下,必须使用StringBuffer;其他情况使用StringBuilder."></a>总结:若操作少量的数据可以使用String;若操作大量数据且要求数据线程安全的情况下,必须使用StringBuffer;其他情况使用StringBuilder.</h6>]]></content>
      
      
      <categories>
          
          <category> Java学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门</title>
      <link href="/2020/08/03/java-ru-men/"/>
      <url>/2020/08/03/java-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="了解Java"><a href="#了解Java" class="headerlink" title="了解Java"></a>了解Java</h1><h2 id="Java特点"><a href="#Java特点" class="headerlink" title="Java特点"></a>Java特点</h2><ol><li><pre><code>1. ​简单性2. ​面向对象性3. ​分布式4. ​健壮性5. ​高性能6. ​多线程7. ​动态性</code></pre></li></ol><h2 id="Java运行环境"><a href="#Java运行环境" class="headerlink" title="Java运行环境"></a>Java运行环境</h2><h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><ul><li><pre><code>- ​    JAVA_HOME  ​        JAVA_HOME=JDK的安装路径(自己的安装路径C:\Program Files\Java\jdk1.8.0_151) - ​    Path(系统在任何路径都可以识别 java, javac命令)  ​        Path=%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin (系统自带的路径不要删掉)- ​    CLASSPATH  ​        JAVA加载类路径，只有类在classpath中，java命令才能识别，在路径前加了个  &quot;.&quot;表示  ​        当前路径  CLASSPATH=.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</code></pre></li></ul><h3 id="JDK-java-开发-工具包-opt-jdk-or-opt-jdk-1-6-01"><a href="#JDK-java-开发-工具包-opt-jdk-or-opt-jdk-1-6-01" class="headerlink" title="JDK java 开发 工具包 /opt/jdk or /opt/jdk_1.6.01"></a>JDK java 开发 工具包 /opt/jdk or /opt/jdk_1.6.01</h3><ul><li><pre><code>- ​    |-- bin 开发工具(命令：java,javac,jar,javad,jar,rmic,jps...)- ​    |-- lib 开发工具的核心实现(tools.jar)- ​    |-- src.zip API的源文件 System.java- ​    |-- jre JRE Java运行环境- ​    |-- lib (rt.jar) Java API(应用编程接口，系统类库)- ​    |  (java 提供的现成组件) System.class String.class ...- ​    |-- bin (java_vm)JVM Java虚拟机</code></pre></li></ul><h3 id="JDK、JRE、JVM之间的关系"><a href="#JDK、JRE、JVM之间的关系" class="headerlink" title="JDK、JRE、JVM之间的关系"></a>JDK、JRE、JVM之间的关系</h3><ul><li><pre><code>- ​    JDK(Java Developer     Kit) Java开发工具包- ​    JRE(Java Runtime     Environment)Java运行环境- ​    JVM(Java Virtual     Machine) Java虚拟机</code></pre></li></ul><h3 id="三者关系："><a href="#三者关系：" class="headerlink" title="三者关系："></a>三者关系：</h3><ul><li><pre><code>- ​    JDK=JRE+Java开发工具- ​    JRE=JVM+Java类库- ​    JDK包含JRE，JRE包含JVM</code></pre></li></ul><h2 id="Java运行原理"><a href="#Java运行原理" class="headerlink" title="Java运行原理"></a>Java运行原理</h2><ul><li><pre><code>- ​Java文件类型- ​.java  Java源文件- ​.class  二进制字节码文件</code></pre></li></ul><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><ol><li><pre><code>1. ​首先，编写.java文件，通过javac命令将.java文件编译成.class文件（字节码文件）。编译过程只能简单的检查语错误；2. ​其次，java命令去执行.class文件。3. ​类加载器会进行代码装载，如果类需要跨网络，类加载器将执行安全检查；4. ​字节码校验器将校验代码格式和对象类型转换，并检查是否发生越权访问；5. ​即时编译器会将字节码转换成机器码，如果系统没有即时编译器，java解释器会处理并执行字节码类</code></pre></li></ol><h4 id="一个Java程序的基本结构："><a href="#一个Java程序的基本结构：" class="headerlink" title="一个Java程序的基本结构："></a>一个Java程序的基本结构：</h4><pre class=" language-java"><code class="language-java">    <span class="token keyword">package</span>  xxx<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// package 包，此类的路径</span>    <span class="token keyword">import</span>  xxx<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>Xxxx<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//引入其他类</span>    <span class="token comment" spellcheck="true">//类名称：书写格式：首字母大写，若类名由多个单词组成每个单词的首字母大写</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">XxxXxx</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* main方法  */</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String <span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 方法体</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>​    例子：HelloWorld.java</p><pre class=" language-Java"><code class="language-Java">public class HelloWorld&#123;/*第一个Java程序*它将打印字符串Hello World*/    public static void main(String []args)&#123;        System.out.println("Hello World");//打印Hello World    &#125;&#125;</code></pre><h5 id="编译源文件："><a href="#编译源文件：" class="headerlink" title="编译源文件："></a>编译源文件：</h5><pre><code>javac HelloWorld.java </code></pre><h5 id="执行class文件"><a href="#执行class文件" class="headerlink" title="执行class文件"></a>执行class文件</h5><pre><code>java HelloWorld</code></pre><h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><ol><li><pre><code>1. 行注释  // 对某代码进行注释2. 块注释  /*… …*/ 注释多行代码或用于说明文件、方法。数据结构等3. 文档注释  /**… …*/用于生成HTML格式的代码报告。必须收发室在类、域、构造函数、方法，以及字段定义之间。</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
