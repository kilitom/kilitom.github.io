{"meta":{"title":"Kilitom","subtitle":"Kilitomの博客","description":"书中自有颜如玉,书中自有黄金屋","author":"Kilitom","url":"https://kilitom.github.io","root":"/"},"pages":[{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2020-08-10T00:06:31.190Z","comments":true,"path":"404.html","permalink":"https://kilitom.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-08-10T00:05:07.174Z","comments":true,"path":"about/index.html","permalink":"https://kilitom.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-08-09T13:32:30.000Z","updated":"2020-08-10T00:05:22.586Z","comments":true,"path":"categories/index.html","permalink":"https://kilitom.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2018-09-30T09:25:30.000Z","updated":"2020-08-10T00:05:40.989Z","comments":true,"path":"contact/index.html","permalink":"https://kilitom.github.io/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2020-08-10T00:05:55.522Z","comments":true,"path":"friends/index.html","permalink":"https://kilitom.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2020-08-10T00:06:10.206Z","comments":true,"path":"tags/index.html","permalink":"https://kilitom.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaIO流","slug":"JavaIO流","date":"2020-08-11T12:23:20.000Z","updated":"2020-08-12T06:14:19.948Z","comments":true,"path":"2020/08/11/JavaIO流/","link":"","permalink":"https://kilitom.github.io/2020/08/11/JavaIO%E6%B5%81/","excerpt":"","text":"文件File类方法 方法名 功能说明 File(String pathname) 构造方法，用于创建一个指定路径名的File对象 boolean canRead() 判断文件或目录是否可读 boolean createNewFile() 自动创建一个File对象指定文件名的空文件，只有在指定文件名文件不存在的时候才能成功 boolean delete() 删除File对象对应的文件或目录 boolean exists() 判断File对象对应的文件或目录是否存在 String getAbsolutePath() 获取File对象对应的文件或目录的绝对路径 String getName() 获取File对象对应的文件或目录的名称 String getPath() 获取File对象对应的文件或目录的路径 boolean isDirectory() 判断File对象指向的是否为一个目录 boolean isFile() 判断File对象指向的是否为一个文件 long length() 返回File对象对应的文件的大小，单位为字节 boolean mkdir() 新建一个File对象所定义的一个路径，如果新建成功，返回true,否则返回false，此时File对象必须是目录对象 boolean renameTo(File dest) 重命名File对象对应的文件，如果命名成功，返回true，否则返回false long lastModified() 返回此File对象的最后一次被修改的时间 相对路径 ../../文件名 绝对路径 盘符://xx/xx/文件名 I/O流字符流(Writer Reader) 16位的Unicode FileReader 从InputStreamReader类继承而来 按字符读取流中数据 FileWriter 从OutputStreamReader类继承而来 按字符向流中写入数据 字节流(OutputStream InputStream) 8位的byte流 字符流和字节流主要的区别： 字节流没有使用到缓冲区，而字符流使用了； 处理各种数据都可以通过字节流完成，而在处理中文的时候使用字符流会更好。 输入流 只能读 不能写 输出流 只能写 不能读 对象流序列化 序列化是一种将对象以一连串字节描述的过程:(输出流) 反序列化 反序列化是一种将这些字节重组成一个对象的过程:(输入流)","categories":[{"name":"Java学习笔记","slug":"Java学习笔记","permalink":"https://kilitom.github.io/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"https://kilitom.github.io/tags/Java/"}]},{"title":"Java集合","slug":"Java集合","date":"2020-08-11T12:23:20.000Z","updated":"2020-08-12T06:32:14.541Z","comments":true,"path":"2020/08/11/Java集合/","link":"","permalink":"https://kilitom.github.io/2020/08/11/Java%E9%9B%86%E5%90%88/","excerpt":"","text":"集合 ArrayList LinkedList HashSet HashMap 主要接口:Collection List Set Map list.size();//获取集合长度 list.get();//获取某个索引的元素 list.add();//添加元素 队列分两种结构 循环数组: 查询快,增删慢 链表结构: 插入删除快,查询慢 collection顺序是无序的 Set集合 继承 Collection接口 元素不能重复 add()添加元素 remove()删除元素 size()集合大小 不能通过索引添加元素 不能通过索引删除元素 存储的数据是无序的 Map接口 不继承Collection接口(HashSet散列表结构存储, TreeMap使用数状结构,允许快速检索) 用与维护键值对key不可重复 value可以重复 常用方法put(Object key,Object value) 添加元素enterSet() 获取键值对集合 keySet() 获取键集合 values() 获取值的集合 TreeSet不能存空键Collection和Arrays是辅助类Array.sort()升序排序Iterator迭代器Iterator遍历List集合Interator无序 子接口ListIterator有序 在集合中常见的数据结构(掌握) ArrayXxx:底层数据结构是数组，查询快，增删慢 LinkedXxx:底层数据结构是链表，查询慢，增删快 HashXxx:底层数据结构是哈希表。依赖两个方法：hashCode()和equals() TreeXxx:底层数据结构是二叉树。两种方式排序：自然排序和比较器排序 面试题：请解释Collection和Collections的区别？ Collection是一个接口，用于定义集合操作的标准；Collections是一个工具类，可以操作任意的集合对象。","categories":[{"name":"Java学习笔记","slug":"Java学习笔记","permalink":"https://kilitom.github.io/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"https://kilitom.github.io/tags/Java/"}]},{"title":"Java异常","slug":"Java异常","date":"2020-08-10T12:23:20.000Z","updated":"2020-08-12T06:42:09.900Z","comments":true,"path":"2020/08/10/Java异常/","link":"","permalink":"https://kilitom.github.io/2020/08/10/Java%E5%BC%82%E5%B8%B8/","excerpt":"","text":"异常异常发生的原因 用户输入了非法数据。 要打开的文件不存在。 网络通信时连接中断，或者JVM内存溢出 ThrowableErreo(错误) Error（错误）：JVM系统内部错误、资源耗尽等严重情况 Exception 因编程错误或偶然的外在因素导致的一般性问题 所有的异常类是从 java.lang.Exception 类继承的子类 Exception 类是 Throwable 类的子类 比如：IOException，RuntimeException public String getMessage()返回关于发生的异常的详细信息public void printStackTrace()打印toString()结果和栈层次到System.err，即错误输出流捕获异常try/catchtry&#123; // 程序代码 &#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码 &#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码 &#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码 &#125; throws/throw 如果一个方法没有捕获一个检查性异常，那么该方法必须使用 throws 关键字来声明 throws 关键字放在方法签名的尾部 也可以使用 throw 关键字抛出一个异常 一个方法可以声明抛出多个异常，多个异常之间用逗号隔开 finallyfinally 关键字用来创建在 try 代码块后面执行的代码块。 无论是否发生异常，finally 代码块中的代码总会被执行。 在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。 finally 代码块出现在 catch 代码块最后 try&#123; // 程序代码 &#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码 &#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码 &#125;finally&#123; // 程序代码 &#125;","categories":[{"name":"Java学习笔记","slug":"Java学习笔记","permalink":"https://kilitom.github.io/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"https://kilitom.github.io/tags/Java/"}]},{"title":"Java抽象类丶接口丶内部类","slug":"Java抽象类接口内部类","date":"2020-08-07T11:23:20.000Z","updated":"2020-08-12T06:18:57.853Z","comments":true,"path":"2020/08/07/Java抽象类接口内部类/","link":"","permalink":"https://kilitom.github.io/2020/08/07/Java%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"","text":"抽象类抽象类 在面向对象的概念中，所有的对象都是通过类来表述，但并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一类具体的对象，这样的类就是抽象类。 抽象类需要注意以下几点： abstract放在class前，指明该类是抽象类；abstract放在方法声明中，则该方法是抽象方法，抽象方法没有方法体；一个抽象类可以含有多个抽象方法，也可以含有已实现的方法。 接口接口概述 Java是单继承的语言，利用接口可以模拟多继承；接口是对抽象类的进一步抽象，是方法声明和常量的定义集合；接口是一种行为规范，是一种“契约”; 具体格式如下所示：&lt;访问符&gt; interface 接口名 &#123; [访问符] &lt;返回类型&gt; 方法名([参数列表])； ...... &#125; 注意：在定义接口的时候，接口中的所有方法和常量自动定义为public；接口中定义的变量默认是public static final 型，且必须赋初值 。 接口的使用接口的使用通过“implements”关键字来实现，示例代码如下 public class MyClass implements MyInterface &#123; public void add(int x, int y) &#123; // do something &#125; public void volume(int x, int y, int z) &#123; // do something &#125; &#125; 多重继承通过实现多个接口来实现多重继承，示例代码如下 ： public class MyClass2 implements MyInterface, MultiInterface&#123; ......//实现多个接口中的所有方法 &#125; 抽象类 接口 相同点 只被继承 不能通过new方式实例化变量可以引用具体实现类的实例 不同点属性 可以定义任意属性可以重新定义或赋值 默认是常量,用public static final修饰的,必须赋初值 不同点方法 可以由抽象方法和已实现的方法 方法均只有方法声明吗,没有方法体;不存在以实现的方法 不同点继承 extends来表示继承抽象类只能继承一个父类继承抽象类的同时必须实现抽象类中的所有方法 implements来实现接口;实现接口的同时实现接口中的所有方法 不同点静态 可以有静态代码块和静态方法 不能有静态代码块和静态方法 总结 接口不是类 单继承的多实现 抽象类的子类可以是一个抽象类也可以是一个具体实现类 内部类1.成员内部类 成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：class Circle &amp;#123; double radius = 0; public Circle(double radius) &amp;#123; this.radius = radius; &amp;#125; class Draw &amp;#123; //内部类 public void drawSahpe() &amp;#123; System.out.println(\"drawshape\"); &amp;#125; &amp;#125; &amp;#125; 2.局部内部类 局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。class People&amp;#123; public People() &amp;#123; &amp;#125; &amp;#125; class Man&amp;#123; public Man()&amp;#123; &amp;#125; public People getWoman()&amp;#123; class Woman extends People&amp;#123; //局部内部类 int age =0; &amp;#125; return new Woman(); &amp;#125; &amp;#125; 3.匿名内部类#### 匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听代码： new OnClickListener() &amp;#123; @Override public void onClick(View v) &amp;#123; // TODO Auto-generated method stub &amp;#125; &amp;#125;","categories":[{"name":"Java学习笔记","slug":"Java学习笔记","permalink":"https://kilitom.github.io/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"https://kilitom.github.io/tags/Java/"}]},{"title":"Java类之间的关系","slug":"Java类之间的关系","date":"2020-08-06T11:23:20.000Z","updated":"2020-08-12T06:35:35.843Z","comments":true,"path":"2020/08/06/Java类之间的关系/","link":"","permalink":"https://kilitom.github.io/2020/08/06/Java%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","excerpt":"","text":"继承 父类—&gt;子类 超类—&gt;派生类 关键字:extends 重写 当一个子类继承了一个父类时，可以在子类中直接使用父类的属性和方法。如果父类的方法无法满足子类的需求， 则可以在子类中对父类的方法进行改造，也称作重写（override）。重写是Java多态性的另一种体现。 重写的原则 重写的方法的签名必须要和被重写的方法的签名完全匹配； 重写的方法的返回值必须和被重写的方法的返回一致或者是其子类； 重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类； 私有方法不能被重写 子类重写父类方法的过程中，可访问性只能一样或变的更公开。 子类向父类的转换为向上转型向上转型语法 父类型 引用变名=new 子类型(); 规则 子类转父类规则 将一个父类的引用指向子类对象,称为向上转型,自动进行类型转换 此时通过父类引用变量调用的是子类覆盖或继承父类的方法,不是父类的方法 此时通过父类型引用变量无法调用子类特有的方法 super关键字:代表父类对象,通过使用super关键字可以访问父类属性或方法,也可以在子类构造方法中调用父类的构造方法以便初始化父类继承的属性.final关键字:不可改变的一旦定义不能改变 重载 重写 同一类中多态的体现 不同类中多态的体现 定义:同一类中,方法名相同 参数个数 类型 顺序不同 定义:父类中方法,不能满足子类的要求.子类对此方法进行改造 方法名相同 参数个数 类型 顺序也相同 返回类型不影响重载 重写方法返回值类型必须与父类一致 父类中方法需要抛出异常子类必定抛出异常 Object类所有类的顶级父类 方法名 功能说明 boolean equals(Object obj) 比较两个类变量所指向的是否为同一个对象，是则返回true Class getClass() 获取当前对象所属类的信息，返回Class对象 String toString() 将调用toString()方法的对象转换成字符串 Object clone() 生成当前对象的一个备份，并返回这个副本 int hashCode() 返回该对象的哈希代码值 equals：（引用类型会对equals重写比较内容而不是比较地址） public boolean equals(Object obj) &#123; return (this == obj); &#125; ==：①比较基本数据类型②比较引用类型的地址 toString()方法 Object类中定义了public String toString()方法，其返回值是String类型，描述当前对象的有关信息， 在进行String与其他类型数据（引用类型）的连接操作时 ，将自动调用该对象类的toString()方法， 默认情况下toString()方法返回的字符串格式是“类名@哈希码”，一般情况下需要重写toString()方法。 toString()方法实例 重新定义Person类，并重写其toString()方法 public class Person &#123; // 姓名 public String name; // 年龄 private int age; // 性别 private String gender; //get或set等方法省略 public String toString()&#123; return getClass().getName()+&quot;[name = &quot;+name+&quot;,age = &quot;+age+&quot;,gender = &quot;+gender+&quot;]&quot;; &#125; public static void main(String[] args) &#123; Person tom = new Person(&quot;tom&quot;, 23, &quot;male&quot;); System.out.println(tom); &#125; &#125; 多态 多态的重要表现就是方法的重写 存在的三个必要条件: 继承 重写 父类引用指向子类对象","categories":[{"name":"Java学习笔记","slug":"Java学习笔记","permalink":"https://kilitom.github.io/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"https://kilitom.github.io/tags/Java/"}]},{"title":"Java面向对象","slug":"Java面向对象","date":"2020-08-05T11:23:20.000Z","updated":"2020-08-12T06:39:02.134Z","comments":true,"path":"2020/08/05/Java面向对象/","link":"","permalink":"https://kilitom.github.io/2020/08/05/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"面向对象封装 封装就是把对象的属性（状态）和方法（行为）结合在一起，并尽可能隐蔽对象的内部细节，成为一个 不可分割的独立单位（即对象），对外形成一个边界，只保留有限的对外接口使之与外部发生联系。 封装的原则 使对象以外的部分不能随意存取对象的内部数据，从而有效的避免了外部错误对它的“交叉感染”。 数据隐藏特性提升了系统安全性，使软件错误能够局部化，减少查错和排错的难度。 继承 继承是软件重用的一种形式 多态 多态是指在父类中定义的属性或方法被子类继承之后，可以具有不同的表现行为。 类与对象类 类是对象的模板,对象是类的实例 类由属性和方法构成 对象–&gt;成员变量–&gt;属性 类的方法是对象执行操作的一种规范 Java中声明类的格式[访问符] [修饰符] class &lt;类名>&amp;#123; [属性] [方法] &amp;#125; 对象的创建 声明一个变量 创建该对象,并把该对象的引用赋给声明好的变量.这是通过new运算符实现的 创建对象的三种方式Rectangle rect1 = new Rectangle(); Rectangle rect2; rect2 = new Rectangle(); Rectangle rect3 = null; rect3 = new Rectangle(); 构造方法 构造方法在对象被创建时用来初始化对象； 与类名相同 没有返回类型； 构造方法是初始化一个对象的内部状态。 如果在类中没有定义任何的构造方法，则编译器将会自动加上一个无参构造方法 ；一旦创建了自己的构造方法，缺省的构造方法将不复存在，如果需要则手动添加无参构造方法。 this调用的是本类中的对象或者方法对象的初始化Rectangle rectangle = new Rectangle(3,5) 类的方法 方法是类行为的体现，其他对象可以根据类的方法对类进行访问。类的方法包括方法的说明和方法的实现两部分 ， 格式如下所示： [access] [modifiers] methodName ([]) {} 方法的返回类型是该方法运行后返回值的数据类型；如果方法没有返回值，则方法的返回类型为void。使用对象 当分配完一个对象后，可以使用点操作符“.”来实现对属性和方法的访问： 对象名.属性;//访问对象的属性 对象名.方法名();//访问对象的方法 参数传递按值传递 ,将要传递的参数的值传递给被调方法，被调方法通过创建一份新的内存拷贝来存储传递的值，然后在内存拷贝上进行数值操作，所以按值传递不会改变原始参数的值。引用传递,也称为传地址方法调用时实际参数传递的是对象,这时实际参数与形式参数指向同一个地址,在方法执行中,对形式参数的操作实际上就是对实际参数的操作所以会改变实际参数的值。方法重载重载 在Java程序中，如果同一个类中存在两个方法同名，方法的签名(参数个数、参数类型、类型排列次序)上也一样， 将无法编译通过。但在Java中多个方法重名是允许的，只要保证方法签名不同即可，这种特性称为方法重载（overload）。 原则 方法名相同； 参数列表（个数、类型、顺序）不同； 注意：返回值不影响方法重载。构造方法也可以重载 。 封装 隐藏类的实现细节 让使用者只能通过程序员规定的方法来访问数据 可以方便的加入存取控制语句,限制不合理操作 访问修饰符 Java中定义了private（私有的）、protected（受保护的）和public（公共的）的访问修饰符，同时也定义了一个 缺省的访问级别，用于声明类、属性、方法的访问权限。明确访问修饰符的限制是用好“封装”的关键 ： public:可以被同一个项目中所有类访问,具有项目可见性,这是最大的访问权限protected:可以被同一个包中的类访问,被同一个项目中不同包中的子类访问default:成员变量和方法只能被同一个包里的类访问,具有包可见性private:成员变量和方法只能在类内被访问,具有类可见性.。 访问控制 privata成员 省缺成员 protected成员 public成员 同一类中成员 √ √ √ √ 同一包中其他成员 × √ √ √ 不同包中子类 × × √ √ 不同包中非子类 × × × √ 静态变量和方法 “实例相关”的成员描述的是单个实例的状态和方法，其使用必须要通过类的实例来完成; “类相关”是在类的成员前面加上“static”关键字，从而直接通过类名就可以访问 。","categories":[{"name":"Java学习笔记","slug":"Java学习笔记","permalink":"https://kilitom.github.io/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"https://kilitom.github.io/tags/Java/"}]},{"title":"MySQL数据库语句","slug":"MySQL数据库语句","date":"2020-08-05T11:23:20.000Z","updated":"2020-08-13T12:15:00.263Z","comments":true,"path":"2020/08/05/MySQL数据库语句/","link":"","permalink":"https://kilitom.github.io/2020/08/05/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"#显示服务器下的所有数据库 SHOW DATABASES;#注意事项：1多行命令存在时，运行时--&gt;右击运行【运行已选择】 #新建查询一定记得保存 USE world;#在某个数据库执行操作 SHOW TABLE;#显示当前数据库下的表 #创建新的数据库 CREATE DATABASE day01 CHARACTER SET utf8 COLLATE utf8_general_ci; #查看当前数据库支持的编码和校对规则 SHOW CHARACTER SET; #查看某个数据库信息 SHOW CREATE DATABASE db_name; #修改数据库 ALTER DATABASE db_name CHARACTER SET sharset_name COLLATE collation_name; Int(10)与int(10):值的范围相等 长度代表的是数值显示的最大长度 varcher:可变长度的字符串 char固定长度的字符串0~255 char(2) #追加列 alter table table_name ADD #修改列数据类型 alter table table_name MODIFY table_name datetype #改列名 alter table table_name CHANGE old_name new_name #删除列 alter table table_name DROP table_name #修改表名 alter table table_name RENAME TO new_table_name RENAME TABLE table TO new_table #建表后，再设置主键 ALTER TABLE dept ADD PRIMARY KEY(deptno) ; #删除主键约束： ALTER TABLE dept DROP PRIMARY KEY; 建表时，设置主键且自增CREATE TABLE dept ( deptno int(11) auto_increment, dname varchar(14) , loc varchar(13) , PRIMARY KEY (deptno) ) ; CREATE TABLE dept ( deptno int(11) PRIMARY KEY auto_increment, dname varchar(14) , loc varchar(13) ); #设置自增 AUTO_INCREMENT #设置主键后，再添加主键自增 ALTER TABLE table MODIFY column datatype auto_increment; #删除主键且自增： ALTER TABLE table MODIFY column datatype ; ALTER TABLE tablename drop primary key ; #非空约束 NOT NULL #添加非空约束： ALTER TABLE table MODIFY column datatype NOT NULL; #删除非空约束： ALTER TABLE table MODIFY [COLUMN] column datatype; 唯一约束 UNIQUE 保证约束的列的值唯一且不重复 #添加非空约束： ALTER TABLE table ADD UNIQUE [unique_index_name] (column[,column2,column3,……]); 注： unique_index_name 唯一约束名可省略不写。省略不写生成的约束索引名与列名相同。 #删除非空约束： ALTER TABLE table DROP index unique_index_name; 在建表语句中设置外键： CREATE TABLE tablename( id int, …… column datatype, constraint 外键名 foreign key(column) references tablename2(column)); #建表后设置外键： ALTER TABLE tablename ADD CONSTRAINT 外键名 foreign key (column) references tablename2(column); MySQL约束 检查约束 check MySQL目前不支持 非空约束 not null 唯一约束 unique 主键约束 primary key 外键约束 foreign key 参照完整性约束 作用保持数据一致 完整性 主键所在的表是主表 外键所在的表是从表 处理级联问题 on delete cascade 主表某数据删除时，与主表数据相关的从表的数据也一起删除 on update cascade 主表某数据修改时，与主表数据相关的从表的数据也一起修改 on delete set null 主表某数据删除时，与主表数据相关的从表的数据的外键列为NULL 索引 自动创建: 主键或唯一约束后系统自动创建手动创建: 用户可以在其它列上创建索引，以加快表查询速度，提高效率。 创建索引 CREATE INDEX index ON table (column[, column]...); ALTER TABLE tbl_name ADD INDEX index_name (column list); ALTER TABLE tbl_name ADD UNIQUE index_name (column list); ALTER TABLE tbl_name ADD PRIMARY KEY index_name (column list); 删除索引 DROP INDEX index on tablename; ALTER TABLE tablename drop INDEX index; ALTER TABLE tbl_name DROP UNIQUE index_name (column list); ALTER TABLE tbl_name DROP PRIMARY KEY index_name (column list); 为什么创建索引 列中数据值分布范围很广 列经常在 WHERE 子句或连接条件中出现 表经常被访问而且数据量很大 下列情况不要创建索引: 表很小 列不经常作为连接条件或出现在WHERE子句中 表经常更新 主键 外键 索引的区别 主键 外键 索引 定义 不重复不能为空唯一标识 是另一个表的主键可以重复可以为空 没有重复值可以有一个空值 作用 保证数据完整性 与其他表建立联系 提高查询排序的速度 个数 主键只能有一个 一个表可以有多个外键 一个表可以有多个唯一索引 复制表结构 CREATE TABLE &#39;新表名&#39; LIKE &#39;旧表名&#39; 复制表结构和数据 INSERT INTO &#39;新表&#39; SELECT * FROM &#39;旧表&#39;;","categories":[{"name":"MySQL学习笔记","slug":"MySQL学习笔记","permalink":"https://kilitom.github.io/categories/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"-数据库","slug":"数据库","permalink":"https://kilitom.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Java基础","slug":"Java基础","date":"2020-08-04T05:23:20.000Z","updated":"2020-08-12T06:30:26.628Z","comments":true,"path":"2020/08/04/Java基础/","link":"","permalink":"https://kilitom.github.io/2020/08/04/Java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Java基础标识符Java中标识符的命名必须满足以下原则： 标识符必须以字母、下划线（_）或美元符（$）开头，后面可以跟字母、数字、下划线或美元符 标识符可以包含数字，但不能以数字开头 除下划线“_”和“$”符号外，标识符中不包含任何特殊字符，如空格 标识符区分大小写，比如，“abc”和“Abc”是两个不同的标识符 对于标识符的长度没有限制 不能使用Java关键字作为标识符 例如 static public void main 分隔符 Java中分隔符分为两类： 没有意义的空白符 拥有确定含义的普通分隔符 普通分隔符 名称 功能说明 {} 大括号 用来定义程序块，类，方法以及局部范围; [] 中括号 用来进行数组的声明，也可用来表示撤销对数组的引用; () 小括号 在定义和调用方法时用来容纳参数表，在控制语句或强制类型转换组成的表达式中用来表示执行或计算的优先级 ; ; 分号 用来表示一条语句的结束 ;在for控制语句中用来将圆括号内的语法连接起来; , 逗号 在变量声明中，用于分割变量表中的各个变量;在for控制语句中用来将圆括号内的语法连接起来; : 冒号 说明语句标号。例如在三元运算符中使用; 基本数据类型：（1）数值型： 1）整数类型（byte、short、int、long）2)浮点类型（float、double） 注:long a=1234567890L(末尾加“L”、“l”),否则默认为int型； float b=2.3f(末尾加“F”、“f”),否则默认为double型； 八进制必须以0（零） 开头；十六必须进制以0X或0x开头（零X或零x）。 （2）字符型：char型 注：每个字符在unicode表中都有相对应的位置，如a在unicode表中的位置是97.转义字符（是字符就要加单引号）：\\ddd:1-3为8进制数据所表示的字符，如\\123 \\uxxxx:4位16进制数据所表示的字符，如\\u0052 &#39;:单引号字符 \\:反斜杠字符 \\t:垂直制表符，将光标移到下一个制表符的位置 \\r:回车 \\n:换行 \\b:退格 \\f:换页 （3）布尔型（boolean）: 又称为逻辑类型，只有true和false两个值，表示真和假。 变量与常量1.常量：在程序执行过程中，其值不能被改变的量。 (1)常量的声明（定义常量）：1)final 数据类型 常量名称[=值];如final int a=5; 注:1）常量通常也被称为final变量 2）用final定义“成员变量（全局变量）”时，必须立刻设初值，否则会产生编译错误。 2.变量：在程序执行过程中，其值能被改变的量。 (1)成员变量（全局变量）：定义在类中；成员变量又分为静态变量和实例变量； 1）静态变量（有static关键字）：有效范围跨类，甚至可达整个程序中（应用程序由若干个类构成）。 2）实例变量（无static关键字）：有效范围当前类。 (2)局部变量：定义在方法中。 注：当局部变量名与成员变量名相通时，成员变量将在此方法中暂时失效。 运算符(1)赋值运算符（=） 例：int a=3;(将3赋给a) int b=a+c;(将a+c的和赋给b) x=y=z=5;(将5的值赋给x、y、z，不建议使用) (2)算术运算符（+（加）、-（减）、*（乘）、/（除）、%（取余）） 例：12.45f15=27.45; 45-30=15; 53=15; 6/2=3; 12%10=2; (3)自增、自减运算符（++、–）:操作员必须是一个整型或浮点型变量 例：假设a=5;以自增为例。 b=++a;//此时a先加1，再赋值给b,所以b=6; b=a++;//此时a直接赋给b,之后加1，所以b=5; (4)比较运算符（大于(&gt;)、小于(&lt;)、等于(==)、大于等于(&gt;=)、小于等于(&lt;=)、不等于(!=)） 例：4&gt;5,结果为false. 4!=5,结果为true. 注：结果为布尔值 (5)逻辑运算符（与(&amp;&amp;、&amp;)、或(||)、非(!)） 与：同真为真 或：一真为真 注：1）结果都为布尔值（flase、true） 2）短路运算符（&amp;&amp;）：第一个为假，就不再判断第二个。 非短路运算符（&amp;）：第一个为假，依然判断第二个，相比之下更浪费时间。 (6)三元运算符（条件式？值1：值2）：等价于if…..else语句 例：int y=a&gt;b?x+1:x-1; 含义：如果a&gt;b成立，y=x+1;否则y=x-1； 数据类型转换（1）隐式类型转换（自动类型转换） 例：int a=3; float x=a; 执行结果为3.0 （2）显式类型转换（强制类型转换） 例：int a=(int)4.25; 执行结果为：4 流程控制分支语句 if-else , switchif(condition) statement1; [else statement2; ] switch(expression)&amp;#123; case 'value1': statement1; break; case 'value2 ': statement2; break; case 'valueN': statementN; break; [default:defaultStatement;] &amp;#125; 迭代语句 while , do-while , forwhile(condition)&amp;#123; statement; &amp;#125; do&amp;#123; statement; &amp;#125; while(condition) for(initialization；condition；update)&amp;#123; statements; &amp;#125; 转移语句 break , continue , return break语句：在循环中用于立即从当前循环终止控制；continue语句：从其调用处跳至循环的开始处；return语句 ：其之后的语句将不再执行；ava中没有goto语句，在多层循环时，可以用break、continue实现goto语句的功能。 数组 属于引用数据类型; 由类型相同的元素组成的有顺序的数据集合; 数组的长度是固定的,不能扩展; 可以存储基本数据库类型或对象; 一维数组data_type[] varName; 或 data_type varName[]; 示例: int a[]; double b[]; 利用new来为数组型变量分配内存空间a= new int[10]; double b = new double[10]; 数组初始化静态初始化 int[] k = &#123;1,2,3,4&#125; 或 int k[] = new int&#123;1,2,3,4&#125; 动态初始化 int array = new int[2]; array[0] = 1; array[1] = 2; 数组拷贝 使用循环语句进行复制 使用循环语句遍历源数组每个元素，赋值给目标数组对应位置。 使用clone()方法 在Java中，Object类是所有类的父类，其clone()方法一般用于创建并返回此对象的一个副本， Java中认为一切都是“对象”，所以使用该方法也可以实现数组的复制。 使用System.arraycopy方法 arraycopy()方法是System类的一个静态方法（并且是本地方法，效率非常高），其可以方便 的实现数组拷贝功能System.arraycopy()方法的结构如下： System.arraycopy(from, fromIndex, to, toIndex, count) 二维数组 如果一维数组元素的数据类型还是一维数组的话，这种数组就被称为二维数组。二维数组定义语法如下： data_type[ ][ ] varName;动态初始化二维数组 // 定义二维数组 int[ ][ ] array = new int[2][2]; for (int i = 0; i &lt; array.length; i++) &amp;#123; for (int j = 0; j &lt; array[i].length; j++) &amp;#123; array[i][j] = j + 2 * i + 1; // 把1,2,3,4分别赋给array[i][j] &amp;#125; &amp;#125; 工具类Scanner类:获取控制台输入。它是一个工具类，属于java.util包。 用法：Scanner console = new Scanner(System.in);//定义一个Scanner类 方法: console.nextInt();//输入整数 console.nextLine();//输入字符串 console.nextDouble() ;//输入小数 Random类:实现的随机算法是伪随机，也就是有规则的随机 用法：Random random = new Random(); 方法： random.nextInt();//随机整数 random.nextInt(int n);//随机返回[0，n)之间的整数 random. nextDouble();//随机返回[0.0,1.0)之间的小数 Math类 Math.random()是令系统随机选取大于等于 0.0 且小于 1.0 的伪随机 double 值 公式：Math.random()*(n-m)+m，生成大于等于m小于n的随机数； Math.abs();//绝对值 Math.sqrt();//立方根 Math.max();//两者之间较大的 Math.min();//两者之间较小的 Math.random();//随机数 Math.pow();//幂 Math.ceil();//向上取整 Math.floor();//向下取整 Math.round();//四舍五入 String字符串常用方法 charAt(int index)//返回执行下标index对应的字符 concat(String str)//连接两个字符串返回组合后的字符串 endsWith(String suffix)//判断字符是否以suffix结尾 true/false startWith(String suffix)//判断字符是否以suffix开头 true/false equals(Obgect obj)//判断两个字符是否相等,true/false indexOf(String suffix)//返回字串suffix对应的下标 lastindexOf(String suffix)//返回字串suffix最后一次出现的位置 length()//返回字符串的长度 matches(String regex)//判断字符串是否与正则表达式相等 replace(char oldChar,char newChar)//字符串中旧的字串oldChar替换为新的字串newChar split(String regex)//按regex对应字符串进行拆分,返回子字符数组 substring(int beginIndex,int endIndex)//截取指示下标范围内的字串返回子字符串[) trim()//去空格 线程安全性 StringBuilder:不支持并发操作,线程不安全,不适合多线程使用 StringBuffer:支持并发操作,线程安全,适合多线程使用总结:若操作少量的数据可以使用String;若操作大量数据且要求数据线程安全的情况下,必须使用StringBuffer;其他情况使用StringBuilder.","categories":[{"name":"Java学习笔记","slug":"Java学习笔记","permalink":"https://kilitom.github.io/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"https://kilitom.github.io/tags/Java/"}]},{"title":"Java入门","slug":"Java入门","date":"2020-08-03T11:23:20.000Z","updated":"2020-08-12T06:41:05.017Z","comments":true,"path":"2020/08/03/Java入门/","link":"","permalink":"https://kilitom.github.io/2020/08/03/Java%E5%85%A5%E9%97%A8/","excerpt":"","text":"了解JavaJava特点 简单性 面向对象性 分布式 健壮性 高性能 多线程 动态性 Java运行环境环境变量配置 ​ JAVA_HOME ​ JAVA_HOME=JDK的安装路径(自己的安装路径C:\\Program Files\\Java\\jdk1.8.0_151) ​ Path(系统在任何路径都可以识别 java, javac命令)​ Path=%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin (系统自带的路径不要删掉) ​ CLASSPATH​ JAVA加载类路径，只有类在classpath中，java命令才能识别，在路径前加了个 “.”表示​ 当前路径 CLASSPATH=.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar JDK java 开发 工具包 /opt/jdk or /opt/jdk_1.6.01 ​ |– bin 开发工具(命令：java,javac,jar,javad,jar,rmic,jps…) ​ |– lib 开发工具的核心实现(tools.jar) ​ |– src.zip API的源文件 System.java ​ |– jre JRE Java运行环境 ​ |– lib (rt.jar) Java API(应用编程接口，系统类库) ​ | (java 提供的现成组件) System.class String.class … ​ |– bin (java_vm)JVM Java虚拟机 JDK、JRE、JVM之间的关系 ​ JDK(Java Developer Kit) Java开发工具包 ​ JRE(Java Runtime Environment)Java运行环境 ​ JVM(Java Virtual Machine) Java虚拟机 三者关系： ​ JDK=JRE+Java开发工具 ​ JRE=JVM+Java类库 ​ JDK包含JRE，JRE包含JVM Java运行原理 Java文件类型 .java Java源文件 .class 二进制字节码文件 编译过程 首先，编写.java文件，通过javac命令将.java文件编译成.class文件（字节码文件）。编译过程 只能简单的检查语错误； 其次，java命令去执行.class文件。 类加载器会进行代码装载，如果类需要跨网络，类加载器将执行安全检查； 字节码校验器将校验代码格式和对象类型转换，并检查是否发生越权访问； 即时编译器会将字节码转换成机器码，如果系统没有即时编译器，java解释器会处理并执行字节码类 一个Java程序的基本结构： package xxx; // package 包，此类的路径 import xxx.xxx.Xxxx; //引入其他类 //类名称：书写格式：首字母大写，若类名由多个单词组成每个单词的首字母大写 public class XxxXxx&amp;#123; /* main方法 */ public static void main(String []args) &amp;#123; // 方法体 &amp;#125; &amp;#125; Hello World​ 例子：HelloWorld.java ​```Javapublic class HelloWorld{/*第一个Java程序*它将打印字符串Hello World*/ public static void main(String []args){ System.out.println(“Hello World”);//打印Hello World }} ##### 编译源文件： javac HelloWorld.java ##### 执行class文件 java HelloWorld ##### 注释 &gt; 1. 行注释 // 对某代码进行注释 &gt; 2. 块注释 /*… …*/ 注释多行代码或用于说明文件、方法。数据结构等 &gt; 3. 文档注释 /**… …*/用于生成HTML格式的代码报告。必须收发室在类、域、构造函数、方法，以及字段定义之间。","categories":[{"name":"Java学习笔记","slug":"Java学习笔记","permalink":"https://kilitom.github.io/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"https://kilitom.github.io/tags/Java/"}]}],"categories":[{"name":"Java学习笔记","slug":"Java学习笔记","permalink":"https://kilitom.github.io/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"MySQL学习笔记","slug":"MySQL学习笔记","permalink":"https://kilitom.github.io/categories/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"https://kilitom.github.io/tags/Java/"},{"name":"-数据库","slug":"数据库","permalink":"https://kilitom.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}