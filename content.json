{"meta":{"title":"Kilitom","subtitle":"Kilitomの博客","description":"书中自有颜如玉,书中自有黄金屋","author":"Kilitom","url":"https://kilitom.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-08-09T13:32:30.000Z","updated":"2020-08-10T00:05:22.586Z","comments":true,"path":"categories/index.html","permalink":"https://kilitom.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-08-10T00:05:07.174Z","comments":true,"path":"about/index.html","permalink":"https://kilitom.github.io/about/index.html","excerpt":"","text":""},{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2020-08-10T00:06:31.190Z","comments":true,"path":"404.html","permalink":"https://kilitom.github.io/404.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2020-08-10T00:05:55.522Z","comments":true,"path":"friends/index.html","permalink":"https://kilitom.github.io/friends/index.html","excerpt":"","text":""},{"title":"contact","date":"2018-09-30T09:25:30.000Z","updated":"2020-08-10T00:05:40.989Z","comments":true,"path":"contact/index.html","permalink":"https://kilitom.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2020-08-10T00:06:10.206Z","comments":true,"path":"tags/index.html","permalink":"https://kilitom.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java集合","slug":"Java集合","date":"2020-08-11T12:23:20.000Z","updated":"2020-08-11T06:03:41.439Z","comments":true,"path":"2020/08/11/java-ji-he/","link":"","permalink":"https://kilitom.github.io/2020/08/11/java-ji-he/","excerpt":"","text":"集合ArrayList LinkedList HashSet HashMap 主要接口:Collection List Set Map list.size();//获取集合长度 list.get();//获取某个索引的元素 list.add();//添加元素 队列分两种结构循环数组: 查询快,增删慢 链表结构: 插入删除快,查询慢 collection顺序是无序的 Set集合 继承 Collection接口元素不能重复 add()添加元素 remove()删除元素 size()集合大小 不能通过索引添加元素 不能通过索引删除元素 存储的数据是无序的 Map接口 不继承Collection接口(HashSet散列表结构存储, TreeMap使用数状结构,允许快速检索) 用与维护键值对key不可重复 value可以重复 常用方法put(Object key,Object value) 添加元素enterSet() 获取键值对集合 keySet() 获取键集合 values() 获取值的集合 TreeSet不能存空键Collection和Arrays是辅助类Array.sort()升序排序Iterator迭代器Iterator遍历List集合Interator无序 子接口ListIterator有序 在集合中常见的数据结构(掌握) ArrayXxx:底层数据结构是数组，查询快，增删慢 LinkedXxx:底层数据结构是链表，查询慢，增删快 HashXxx:底层数据结构是哈希表。依赖两个方法：hashCode()和equals() TreeXxx:底层数据结构是二叉树。两种方式排序：自然排序和比较器排序","categories":[{"name":"Java学习笔记","slug":"Java学习笔记","permalink":"https://kilitom.github.io/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"https://kilitom.github.io/tags/Java/"}]},{"title":"Java异常","slug":"Java异常","date":"2020-08-10T12:23:20.000Z","updated":"2020-08-10T12:49:15.406Z","comments":true,"path":"2020/08/10/java-yi-chang/","link":"","permalink":"https://kilitom.github.io/2020/08/10/java-yi-chang/","excerpt":"","text":"异常什么是异常异常是指由于程序中的错误而导致正常的程序流程中断的一种事件。如：除数为0，数组越界，文件找不到等都属于异常。 Java异常分类从理论的角度Java中异常分为两类，分别为 ： Error（错误）：JVM系统内部错误、资源耗尽等严重情况 Exception（异常）：因编程错误或偶然的外在因素导致的一般性问题，例如：对负数开平方根、空指针访问、试图读取不存在的文件、网络连接中断等。 从编程角度考虑可以将异常（Exception）分为以下两类 ：非检查型（unchecked）异常 ：是指编译器不要求强制处置的异常，该异常是因设计或实现方式不当导致的问题，是程序员的原因导致的，可以避免这种问题的产生 检查型(checked)异常 ：是指编译器要求必须处置的异常，是程序在运行时由于外界因素造成的一般性异常，该类异常是Exception类型及其子类（RuntimeException类及其子类除外） 从开发应用角度考虑可以将异常分为以下两类 ：系统异常：系统异常在性质上比应用异常更加严重，前者通常和应用逻辑无关，而是底层出现了问题，如数据库服务器的异常终止等。 应用异常：应用异常是由于违反了商业规则或者业务逻辑而导致的错误。例如，一个被锁定的用户试图登入应用。 Java异常体系 Java语言提供两种处理异常的机制：捕获异常 ：在程序运行过程中系统得到一个异常对象时，它将会沿着方法的调用栈逐层回溯，寻找处理这一异常的代码，找到处理这种类型异常的方法后，运行时系统把当前异常对象交给这个方法进行处理，该过程称为捕获(catch)异常。 声明抛出异常 ：当运行时系统得到一个异常对象，如果当前方法并不知道如何处理所出现的异常或者此时处理不合适，则可在定义方法时，声明抛出（throws）异常。 处理异常关键字try , catch ,finally ,throw和throws try: 可能引发异常的语句,监视异常的发生 catch: 对发生的异常进行捕获 finally :无论是否发生异常都会运行 throw:明确抛出一个异常 throws:方法声明抛出异常 自定义异常为了构建自己的业务异常逻辑, 提高用户体验 多重异常流程","categories":[{"name":"Java学习笔记","slug":"Java学习笔记","permalink":"https://kilitom.github.io/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"https://kilitom.github.io/tags/Java/"}]},{"title":"Java类之间的关系","slug":"Java抽象类接口内部类","date":"2020-08-07T11:23:20.000Z","updated":"2020-08-10T12:08:36.976Z","comments":true,"path":"2020/08/07/java-chou-xiang-lei-jie-kou-nei-bu-lei/","link":"","permalink":"https://kilitom.github.io/2020/08/07/java-chou-xiang-lei-jie-kou-nei-bu-lei/","excerpt":"","text":"抽象类抽象类在面向对象的概念中，所有的对象都是通过类来表述，但并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一类具体的对象，这样的类就是抽象类。 抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。 抽象类需要注意以下几点：abstract放在class前，指明该类是抽象类； abstract放在方法声明中，则该方法是抽象方法，抽象方法没有方法体； 一个抽象类可以含有多个抽象方法，也可以含有已实现的方法。 接口接口概述Java是单继承的语言，利用接口可以模拟多继承； 接口是对抽象类的进一步抽象，是方法声明和常量的定义集合； 接口是一种行为规范，是一种“契约”； 具体格式如下所示：&lt;访问符&gt; interface 接口名 &#123; [访问符] &lt;返回类型&gt; 方法名([参数列表])； ...... &#125; 注意：在定义接口的时候，接口中的所有方法和常量自动定义为public；接口中定义的变量默认是public static final 型，且必须赋初值 。 接口的使用接口的使用通过“implements”关键字来实现，示例代码如下 public class MyClass implements MyInterface &#123; public void add(int x, int y) &#123; // do something &#125; public void volume(int x, int y, int z) &#123; // do something &#125; &#125; 多重继承通过实现多个接口来实现多重继承，示例代码如下 ： public class MyClass2 implements MyInterface, MultiInterface&#123; ......//实现多个接口中的所有方法 &#125; 抽象类 接口 相同点 只被继承 不能通过new方式实例化变量可以引用具体实现类的实例 不同点属性 可以定义任意属性可以重新定义或赋值 默认是常量,用public static final修饰的,必须赋初值 不同点方法 可以由抽象方法和已实现的方法 方法均只有方法声明吗,没有方法体;不存在以实现的方法 不同点继承 extends来表示继承抽象类只能继承一个父类继承抽象类的同时必须实现抽象类中的所有方法 implements来实现接口;实现接口的同时实现接口中的所有方法 不同点静态 可以有静态代码块和静态方法 不能有静态代码块和静态方法 总结 接口不是类 单继承的多实现 抽象类的子类可以是一个抽象类也可以是一个具体实现类内部类1.成员内部类 成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：class Circle &amp;#123; double radius = 0; public Circle(double radius) &amp;#123; this.radius = radius; &amp;#125; class Draw &amp;#123; //内部类 public void drawSahpe() &amp;#123; System.out.println(\"drawshape\"); &amp;#125; &amp;#125; &amp;#125; 2.局部内部类 局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。class People&amp;#123; public People() &amp;#123; &amp;#125; &amp;#125; class Man&amp;#123; public Man()&amp;#123; &amp;#125; public People getWoman()&amp;#123; class Woman extends People&amp;#123; //局部内部类 int age =0; &amp;#125; return new Woman(); &amp;#125; &amp;#125; 3.匿名内部类 匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听代码：new OnClickListener() &amp;#123; @Override public void onClick(View v) &amp;#123; // TODO Auto-generated method stub &amp;#125; &amp;#125;","categories":[{"name":"Java学习笔记","slug":"Java学习笔记","permalink":"https://kilitom.github.io/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"https://kilitom.github.io/tags/Java/"}]},{"title":"Java类之间的关系","slug":"Java类之间的关系","date":"2020-08-06T11:23:20.000Z","updated":"2020-08-10T11:47:22.021Z","comments":true,"path":"2020/08/06/java-lei-zhi-jian-de-guan-xi/","link":"","permalink":"https://kilitom.github.io/2020/08/06/java-lei-zhi-jian-de-guan-xi/","excerpt":"","text":"继承父类---&gt;子类 超类---&gt;派生类 关键字:extends 重写当一个子类继承了一个父类时，可以在子类中直接使用父类的属性和方法。如果父类的方法无法满足子类的需求，则可以在子类中对父类的方法进行改造，也称作重写（override）。重写是Java多态性的另一种体现。 重写的原则重写的方法的签名必须要和被重写的方法的签名完全匹配； 重写的方法的返回值必须和被重写的方法的返回一致或者是其子类； 重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类； 私有方法不能被重写 子类重写父类方法的过程中，可访问性只能一样或变的更公开。 子类向父类的转换为向上转型向上转型语法父类型 引用变名=new 子类型(); 规则子类转父类规则 将一个父类的引用指向子类对象,称为向上转型,自动进行类型转换 此时通过父类引用变量调用的是子类覆盖或继承父类的方法,不是父类的方法 此时通过父类型引用变量无法调用子类特有的方法 super关键字:代表父类对象,通过使用super关键字可以访问父类属性或方法,也可以在子类构造方法中调用父类的构造方法以便初始化父类继承的属性.final关键字:不可改变的一旦定义不能改变 重载 重写 同一类中多态的体现 不同类中多态的体现 定义:同一类中,方法名相同 参数个数 类型 顺序不同 定义:父类中方法,不能满足子类的要求.子类对此方法进行改造 方法名相同 参数个数 类型 顺序也相同 返回类型不影响重载 重写方法返回值类型必须与父类一致 父类中方法需要抛出异常子类必定抛出异常 Object类所有类的顶级父类 方法名 功能说明 boolean equals(Object obj) 比较两个类变量所指向的是否为同一个对象，是则返回true Class getClass() 获取当前对象所属类的信息，返回Class对象 String toString() 将调用toString()方法的对象转换成字符串 Object clone() 生成当前对象的一个备份，并返回这个副本 int hashCode() 返回该对象的哈希代码值 equals：（引用类型会对equals重写比较内容而不是比较地址） public boolean equals(Object obj) &#123; return (this == obj); &#125; ==：①比较基本数据类型②比较引用类型的地址 toString()方法 Object类中定义了public String toString()方法，其返回值是String类型，描述当前对象的有关信息，在进行String与其他类型数据（引用类型）的连接操作时 ，将自动调用该对象类的toString()方法，默认情况下toString()方法返回的字符串格式是“类名@哈希码”，一般情况下需要重写toString()方法。 toString()方法实例 重新定义Person类，并重写其toString()方法 public class Person &#123; // 姓名 public String name; // 年龄 private int age; // 性别 private String gender; //get或set等方法省略 public String toString()&#123; return getClass().getName()+&quot;[name = &quot;+name+&quot;,age = &quot;+age+&quot;,gender = &quot;+gender+&quot;]&quot;; &#125; public static void main(String[] args) &#123; Person tom = new Person(&quot;tom&quot;, 23, &quot;male&quot;); System.out.println(tom); &#125; &#125; 多态多态的重要表现就是方法的重写 存在的三个必要条件: 继承 重写 父类引用指向子类对象","categories":[{"name":"Java学习笔记","slug":"Java学习笔记","permalink":"https://kilitom.github.io/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"https://kilitom.github.io/tags/Java/"}]},{"title":"Java面向对象","slug":"Java面向对象","date":"2020-08-05T11:23:20.000Z","updated":"2020-08-10T11:14:24.129Z","comments":true,"path":"2020/08/05/java-mian-xiang-dui-xiang/","link":"","permalink":"https://kilitom.github.io/2020/08/05/java-mian-xiang-dui-xiang/","excerpt":"","text":"面向对象封装封装就是把对象的属性（状态）和方法（行为）结合在一起，并尽可能隐蔽对象的内部细节，成为一个不可分割的独立单位（即对象），对外形成一个边界，只保留有限的对外接口使之与外部发生联系。 封装的原则使对象以外的部分不能随意存取对象的内部数据，从而有效的避免了外部错误对它的“交叉感染”。数据隐藏特性提升了系统安全性，使软件错误能够局部化，减少查错和排错的难度。 继承继承是软件重用的一种形式，它通过重用现有类的属性和方法，并增加新功能或修改现有功能来构建新的类。 多态多态是指在父类中定义的属性或方法被子类继承之后，可以具有不同的表现行为。这使得同一个属性或方法在父类及其各个子类中具有不同的语义。 类与对象类类是对象的模板,对象是类的实例 类由属性和方法构成对象的特征在类中表示为成员变量，称为类的属性。 类的方法是对象执行操作的一种规范。方法指定以何种方式操作对象的数据，是操作的实际实现。 Java中声明类的格式[访问符] [修饰符] class &lt;类名>&amp;#123; [属性] [方法] &amp;#125; 对象的创建声明一个变量 创建该对象,并把该对象的引用赋给声明好的变量.这是通过new运算符实现的 创建对象的三种方式Rectangle rect1 = new Rectangle(); Rectangle rect2; rect2 = new Rectangle(); Rectangle rect3 = null; rect3 = new Rectangle(); 构造方法构造方法是一种特殊的方法，在对象被创建时用来初始化对象； 它具有和它所在的类完全一样的名字； 构造方法和类的方法类似，只不过构造方法没有返回类型； 构造方法的任务是初始化一个对象的内部状态。 如果在类中没有定义任何的构造方法，则编译器将会自动加上一个无参构造方法 ；一旦创建了自己的构造方法，缺省的构造方法将不复存在，如果需要则手动添加无参构造方法。this调用的是本类中的对象或者方法对象的初始化Rectangle rectangle = new Rectangle(3,5) 类的方法方法是类行为的体现，其他对象可以根据类的方法对类进行访问。类的方法包括方法的说明和方法的实现两部分 ，格式如下所示： [access] [modifiers] &lt;return_type&gt; methodName ([&lt;argu_list&gt;]) &#123;&#125; 方法的返回类型是该方法运行后返回值的数据类型；如果方法没有返回值，则方法的返回类型为void。使用对象当分配完一个对象后，可以使用点操作符“.”来实现对属性和方法的访问： 对象名.属性;//访问对象的属性 对象名.方法名();//访问对象的方法 参数传递按值传递 ,将要传递的参数的值传递给被调方法，被调方法通过创建一份新的内存拷贝来存储传递的值，然后在内存拷贝上进行数值操作，所以按值传递不会改变原始参数的值。引用传递,也称为传地址方法调用时实际参数传递的是对象,这时实际参数与形式参数指向同一个地址,在方法执行中,对形式参数的操作实际上就是对实际参数的操作所以会改变实际参数的值。方法重载重载在Java程序中，如果同一个类中存在两个方法同名，方法的签名(参数个数、参数类型、类型排列次序)上也一样，将无法编译通过。但在Java中多个方法重名是允许的，只要保证方法签名不同即可，这种特性称为方法重载（overload）。 原则方法名相同； 参数列表（个数、类型、顺序）不同； 注意：返回值不影响方法重载。构造方法也可以重载 。封装Java中为了将数据有效的保护起来，提供了访问修饰符用来声明、控制属性、方法乃至类本身的访问，以实现隐藏一个类的实现细节，防止对封装数据未经授权的访问，此种形式称为“封装”。 引入封装，使用者只能通过事先定制好的方法来访问数据，可以方便的加入控制逻辑，限制对属性的不合理操作，有利于保证数据的完整性。 实现封装的关键是不让外界直接与对象属性交互，而是要通过指定的方法操作对象的属性，如下图所示： 访问修饰符Java中定义了private（私有的）、protected（受保护的）和public（公共的）的访问修饰符，同时也定义了一个缺省的访问级别，用于声明类、属性、方法的访问权限。明确访问修饰符的限制是用好“封装”的关键 ： 使用public访问修饰符，类的成员可被同一包或不同包中的所有类访问，也就是说，public访问修饰符可以使类的特性公用于任何类；使用protected访问修饰符允许类本身、同一包中的所有类和不同包中的子类访问；如果一个类或类的成员前没有任何访问修饰符时，它们获得缺省的访问权限，缺省的可以被同一包中的其他类访问；private访问修饰符是限制性最大的一种访问修饰符,被声明为private的成员只能被此类中的其他成员访问，不能在类外看到。 访问控制 privata成员 省缺成员 protected成员 public成员 同一类中成员 √ √ √ √ 同一包中其他成员 × √ √ √ 不同包中子类 × × √ √ 不同包中非子类 × × × √ 静态变量和方法“实例相关”的成员描述的是单个实例的状态和方法，其使用必须要通过类的实例来完成; “类相关”是在类的成员前面加上“static”关键字，从而直接通过类名就可以访问 。","categories":[{"name":"Java学习笔记","slug":"Java学习笔记","permalink":"https://kilitom.github.io/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"https://kilitom.github.io/tags/Java/"}]},{"title":"Java基础","slug":"Java基础","date":"2020-08-04T05:23:20.000Z","updated":"2020-08-10T10:33:43.814Z","comments":true,"path":"2020/08/04/java-ji-chu/","link":"","permalink":"https://kilitom.github.io/2020/08/04/java-ji-chu/","excerpt":"","text":"Java基础标识符Java中标识符的命名必须满足以下原则：标识符必须以字母、下划线（_）或美元符（$）开头，后面可以跟字母、数字、下划线或美元符 标识符可以包含数字，但不能以数字开头 除下划线“_”和“$”符号外，标识符中不包含任何特殊字符，如空格 标识符区分大小写，比如，“abc”和“Abc”是两个不同的标识符 对于标识符的长度没有限制 不能使用Java关键字作为标识符 例如 static public void main 分隔符Java中分隔符分为两类： 没有意义的空白符 拥有确定含义的普通分隔符 普通分隔符 名称 功能说明 {} 大括号 用来定义程序块，类，方法以及局部范围; [] 中括号 用来进行数组的声明，也可用来表示撤销对数组的引用; () 小括号 在定义和调用方法时用来容纳参数表，在控制语句或强制类型转换组成的表达式中用来表示执行或计算的优先级 ; ; 分号 用来表示一条语句的结束 ;在for控制语句中用来将圆括号内的语法连接起来; , 逗号 在变量声明中，用于分割变量表中的各个变量;在for控制语句中用来将圆括号内的语法连接起来; : 冒号 说明语句标号。例如在三元运算符中使用; 基本数据类型：（1）数值型： 1）整数类型（byte、short、int、long） 2)浮点类型（float、double） 注:long a=1234567890L(末尾加“L”、“l”),否则默认为int型； float b=2.3f(末尾加“F”、“f”),否则默认为double型； 八进制必须以0（零） 开头；十六必须进制以0X或0x开头（零X或零x）。 （2）字符型：char型 注：每个字符在unicode表中都有相对应的位置，如a在unicode表中的位置是97. 转义字符（是字符就要加单引号）：\\ddd:1-3为8进制数据所表示的字符，如\\123 \\uxxxx:4位16进制数据所表示的字符，如\\u0052 \\&#39;:单引号字符 \\\\:反斜杠字符 \\t:垂直制表符，将光标移到下一个制表符的位置 \\r:回车 \\n:换行 \\b:退格 \\f:换页 （3）布尔型（boolean）: 又称为逻辑类型，只有true和false两个值，表示真和假。 变量与常量1.常量：在程序执行过程中，其值不能被改变的量。 (1)常量的声明（定义常量）：1)final 数据类型 常量名称[=值];如final int a=5; 注:1）常量通常也被称为final变量 2）用final定义“成员变量（全局变量）”时，必须立刻设初值，否则会产生编译错误。 2.变量：在程序执行过程中，其值能被改变的量。(1)成员变量（全局变量）：定义在类中；成员变量又分为静态变量和实例变量； 1）静态变量（有static关键字）：有效范围跨类，甚至可达整个程序中（应用程序由若干个类构成）。 2）实例变量（无static关键字）：有效范围当前类。 (2)局部变量：定义在方法中。 注：当局部变量名与成员变量名相通时，成员变量将在此方法中暂时失效。 运算符(1)赋值运算符（=） 例：int a=3;(将3赋给a) int b=a+c;(将a+c的和赋给b) x=y=z=5;(将5的值赋给x、y、z，不建议使用) (2)算术运算符（+（加）、-（减）、*（乘）、/（除）、%（取余）） 例：12.45f*15=27.45; 45-30=15; 5*3=15; 6/2=3; 12%10=2; (3)自增、自减运算符（++、–）:操作员必须是一个整型或浮点型变量 例：假设a=5;以自增为例。 b=++a;//此时a先加1，再赋值给b,所以b=6; b=a++;//此时a直接赋给b,之后加1，所以b=5; (4)比较运算符（大于(&gt;)、小于(&lt;)、等于(==)、大于等于(&gt;=)、小于等于(&lt;=)、不等于(!=)） 例：4&gt;5,结果为false. 4!=5,结果为true. 注：结果为布尔值 (5)逻辑运算符（与(&amp;&amp;、&amp;)、或(||)、非(!)） 与：同真为真 或：一真为真 注：1）结果都为布尔值（flase、true） 2）短路运算符（&amp;&amp;）：第一个为假，就不再判断第二个。 非短路运算符（&amp;）：第一个为假，依然判断第二个，相比之下更浪费时间。 (6)三元运算符（条件式？值1：值2）：等价于if…..else语句 例：int y=a&gt;b?x+1:x-1; 含义：如果a&gt;b成立，y=x+1;否则y=x-1； 数据类型转换（1）隐式类型转换（自动类型转换） 例：int a=3; float x=a; 执行结果为3.0 （2）显式类型转换（强制类型转换）例：int a=(int)4.25; 执行结果为：4 流程控制分支语句 if-else , switchif(condition) statement1; [else statement2; ] switch(expression)&amp;#123; case 'value1': statement1; break; case 'value2 ': statement2; break; case 'valueN': statementN; break; [default:defaultStatement;] &amp;#125; 迭代语句 while , do-while , forwhile(condition)&amp;#123; statement; &amp;#125; do&amp;#123; statement; &amp;#125; while(condition) for(initialization；condition；update)&amp;#123; statements; &amp;#125; 转移语句 break , continue , return break语句：在循环中用于立即从当前循环终止控制； continue语句：从其调用处跳至循环的开始处； return语句 ：其之后的语句将不再执行； Java中没有goto语句，在多层循环时，可以用break、continue实现goto语句的功能。 数组属于引用数据类型; 由类型相同的元素组成的有顺序的数据集合; 数组的长度是固定的,不能扩展; 可以存储基本数据库类型或对象; 一维数组data_type[] varName; 或 data_type varName[]; 示例: int a[]; double b[]; 利用new来为数组型变量分配内存空间a= new int[10]; double b = new double[10]; 数组初始化静态初始化 int[] k = &#123;1,2,3,4&#125; 或 int k[] = new int&#123;1,2,3,4&#125; 动态初始化 int array = new int[2]; array[0] = 1; array[1] = 2; 数组拷贝使用循环语句进行复制 使用循环语句遍历源数组每个元素，赋值给目标数组对应位置。 使用clone()方法 在Java中，Object类是所有类的父类，其clone()方法一般用于创建并返回此对象的一个副本，Java中认为一切都是“对象”，所以使用该方法也可以实现数组的复制。 使用System.arraycopy方法 arraycopy()方法是System类的一个静态方法（并且是本地方法，效率非常高），其可以方便的实现数组拷贝功能System.arraycopy()方法的结构如下： System.arraycopy(from, fromIndex, to, toIndex, count) 二维数组如果一维数组元素的数据类型还是一维数组的话，这种数组就被称为二维数组。二维数组定义语法如下： data_type[ ][ ] varName; 动态初始化二维数组// 定义二维数组 int[ ][ ] array = new int[2][2]; for (int i = 0; i &lt; array.length; i++) &amp;#123; for (int j = 0; j &lt; array[i].length; j++) &amp;#123; array[i][j] = j + 2 * i + 1; // 把1,2,3,4分别赋给array[i][j] &amp;#125; &amp;#125; 工具类Scanner类:获取控制台输入。它是一个工具类，属于java.util包。用法：Scanner console = new Scanner(System.in);//定义一个Scanner类 方法: console.nextInt();//输入整数 console.nextLine();//输入字符串 console.nextDouble() ;//输入小数 Random类:实现的随机算法是伪随机，也就是有规则的随机用法：Random random = new Random(); 方法： random.nextInt();//随机整数 random.nextInt(int n);//随机返回[0，n)之间的整数 random. nextDouble();//随机返回[0.0,1.0)之间的小数 Math类Math.random()是令系统随机选取大于等于 0.0 且小于 1.0 的伪随机 double 值 公式：Math.random()*(n-m)+m，生成大于等于m小于n的随机数； Math.abs();//绝对值 Math.sqrt();//立方根 Math.max();//两者之间较大的 Math.min();//两者之间较小的 Math.random();//随机数 Math.pow();//幂 Math.ceil();//向上取整 Math.floor();//向下取整 Math.round();//四舍五入 String字符串常用方法charAt(int index)//返回执行下标index对应的字符 concat(String str)//连接两个字符串返回组合后的字符串 endsWith(String suffix)//判断字符是否以suffix结尾 true/false startWith(String suffix)//判断字符是否以suffix开头 true/false equals(Obgect obj)//判断两个字符是否相等,true/false indexOf(String suffix)//返回字串suffix对应的下标 lastindexOf(String suffix)//返回字串suffix最后一次出现的位置 length()//返回字符串的长度 matches(String regex)//判断字符串是否与正则表达式相等 replace(char oldChar,char newChar)//字符串中旧的字串oldChar替换为新的字串newChar split(String regex)//按regex对应字符串进行拆分,返回子字符数组 substring(int beginIndex,int endIndex)//截取指示下标范围内的字串返回子字符串[) trim()//去空格 线程安全性StringBuilder:不支持并发操作,线程不安全,不适合多线程使用 StringBuffer:支持并发操作,线程安全,适合多线程使用 总结:若操作少量的数据可以使用String;若操作大量数据且要求数据线程安全的情况下,必须使用StringBuffer;其他情况使用StringBuilder.","categories":[{"name":"Java学习笔记","slug":"Java学习笔记","permalink":"https://kilitom.github.io/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"https://kilitom.github.io/tags/Java/"}]},{"title":"Java入门","slug":"Java入门","date":"2020-08-03T11:23:20.000Z","updated":"2020-08-10T08:04:58.946Z","comments":true,"path":"2020/08/03/java-ru-men/","link":"","permalink":"https://kilitom.github.io/2020/08/03/java-ru-men/","excerpt":"","text":"了解JavaJava特点 1. ​简单性 2. ​面向对象性 3. ​分布式 4. ​健壮性 5. ​高性能 6. ​多线程 7. ​动态性 Java运行环境环境变量配置 - ​ JAVA_HOME ​ JAVA_HOME=JDK的安装路径(自己的安装路径C:\\Program Files\\Java\\jdk1.8.0_151) - ​ Path(系统在任何路径都可以识别 java, javac命令) ​ Path=%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin (系统自带的路径不要删掉) - ​ CLASSPATH ​ JAVA加载类路径，只有类在classpath中，java命令才能识别，在路径前加了个 &quot;.&quot;表示 ​ 当前路径 CLASSPATH=.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar JDK java 开发 工具包 /opt/jdk or /opt/jdk_1.6.01 - ​ |-- bin 开发工具(命令：java,javac,jar,javad,jar,rmic,jps...) - ​ |-- lib 开发工具的核心实现(tools.jar) - ​ |-- src.zip API的源文件 System.java - ​ |-- jre JRE Java运行环境 - ​ |-- lib (rt.jar) Java API(应用编程接口，系统类库) - ​ | (java 提供的现成组件) System.class String.class ... - ​ |-- bin (java_vm)JVM Java虚拟机 JDK、JRE、JVM之间的关系 - ​ JDK(Java Developer Kit) Java开发工具包 - ​ JRE(Java Runtime Environment)Java运行环境 - ​ JVM(Java Virtual Machine) Java虚拟机 三者关系： - ​ JDK=JRE+Java开发工具 - ​ JRE=JVM+Java类库 - ​ JDK包含JRE，JRE包含JVM Java运行原理 - ​Java文件类型 - ​.java Java源文件 - ​.class 二进制字节码文件 编译过程 1. ​首先，编写.java文件，通过javac命令将.java文件编译成.class文件（字节码文件）。编译过程只能简单的检查语错误； 2. ​其次，java命令去执行.class文件。 3. ​类加载器会进行代码装载，如果类需要跨网络，类加载器将执行安全检查； 4. ​字节码校验器将校验代码格式和对象类型转换，并检查是否发生越权访问； 5. ​即时编译器会将字节码转换成机器码，如果系统没有即时编译器，java解释器会处理并执行字节码类 一个Java程序的基本结构： package xxx; // package 包，此类的路径 import xxx.xxx.Xxxx; //引入其他类 //类名称：书写格式：首字母大写，若类名由多个单词组成每个单词的首字母大写 public class XxxXxx&amp;#123; /* main方法 */ public static void main(String []args) &amp;#123; // 方法体 &amp;#125; &amp;#125; Hello World​ 例子：HelloWorld.java public class HelloWorld&#123; /*第一个Java程序 *它将打印字符串Hello World */ public static void main(String []args)&#123; System.out.println(\"Hello World\");//打印Hello World &#125; &#125; 编译源文件：javac HelloWorld.java 执行class文件java HelloWorld 注释 1. 行注释 // 对某代码进行注释 2. 块注释 /*… …*/ 注释多行代码或用于说明文件、方法。数据结构等 3. 文档注释 /**… …*/用于生成HTML格式的代码报告。必须收发室在类、域、构造函数、方法，以及字段定义之间。","categories":[{"name":"Java学习笔记","slug":"Java学习笔记","permalink":"https://kilitom.github.io/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"https://kilitom.github.io/tags/Java/"}]}],"categories":[{"name":"Java学习笔记","slug":"Java学习笔记","permalink":"https://kilitom.github.io/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"https://kilitom.github.io/tags/Java/"}]}