{"meta":{"title":"Kilitom","subtitle":"Kilitomの博客","description":"书中自有颜如玉,书中自有黄金屋","author":"Kilitom","url":"https://kilitom.github.io","root":"/"},"pages":[{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2020-08-10T00:06:31.190Z","comments":true,"path":"404.html","permalink":"https://kilitom.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-08-10T00:05:07.174Z","comments":true,"path":"about/index.html","permalink":"https://kilitom.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-08-09T13:32:30.000Z","updated":"2020-08-10T00:05:22.586Z","comments":true,"path":"categories/index.html","permalink":"https://kilitom.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2018-09-30T09:25:30.000Z","updated":"2020-08-10T00:05:40.989Z","comments":true,"path":"contact/index.html","permalink":"https://kilitom.github.io/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2020-08-10T00:05:55.522Z","comments":true,"path":"friends/index.html","permalink":"https://kilitom.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2020-08-10T00:06:10.206Z","comments":true,"path":"tags/index.html","permalink":"https://kilitom.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"面向对象_06","date":"2020-08-10T14:21:51.353Z","updated":"2020-08-10T14:12:27.475Z","comments":true,"path":"2020/08/10/mian-xiang-dui-xiang-06/","link":"","permalink":"https://kilitom.github.io/2020/08/10/mian-xiang-dui-xiang-06/","excerpt":"","text":"3.1、匿名内部类（重点）内部类：在一个类的内部定义了另外的类，称为内部类，匿名内部类指的是没有名字的内部类。为了清楚内部类的主要作用，下面首先来观察如下的程序： 范例：思考程序的问题 interface Message { // 定义了一个接口 public void print() ; // 抽象方法 } class MessageImpl implements Message { // 定义接口的实现类 public void print() { System.out.println(“Hello World .”) ; } } class Demo { public static void get(Message msg) { // 接收接口对象 msg.print() ; } } public class TestDemo { public static void main(String args[]) { Message msg = new MessageImpl() ; // 子类为接口实例化 Demo.get(msg) ; // 传递msg对象 } } 以上的代码是属于正常的开发范畴，但是如果说现在MessageImpl这个子类只使用那么唯一的一次，有必要按照以上的方式进行定义吗？这个时候那么MessageImpl就没有什么意义了，但是可以利用匿名内部类的概念来解决此问题。匿名内部类是在抽象类和接口的基础之上所发展起来的一种应用。 interface Message { // 定义了一个接口 public void print() ; // 抽象方法 } class Demo { public static void get(Message msg) { // 接收接口对象 msg.print() ; } } public class TestDemo { public static void main(String args[]) { Demo.get(new Message() { // 匿名内部类 public void print() { System.out.println(“Hello World .”) ; } }) ; } } 对于匿名内部类的使用，暂时只需要记住它的语法即可，因为如果要想真正的去使用它，还需要一段时间的课程。 3.2、Object类（重点）在Java的定义之中，除了Object类之外，所有的类实际上都存在继承关系，即：如果现在定义了一个类，没有默认继承任何一个父类的话，则默认将继承Object类，以下两种类的最终定义效果是完全一样的。 class Person {} class Person extends Object {} 那么按照这样的方式理解，即：Object类可以接收所有类的实例化对象。 class Person {} public class TestDemo { public static void main(String args[]) { Object obj = new Person() ; Person per = (Person) obj ; } } 如果在日后的开发之中，一个操作可能接收所有类的对象，那么使用Object作为参数最合适。 除此之外，对于任意的一个简单Java类而言，理论上讲应该覆写Object类之中的三个方法： · 取得对象信息：public String toString()； · 对象比较：public boolean equals(Object obj)； · 取得哈希码：public int hashCode()。 3.2.1、取得对象信息：toString()在之前提示过，如果说现在一个对象直接输出，那么默认情况下输出的是一个对象的地址。 class Person {} public class TestDemo { public static void main(String args[]) { Person per = new Person() ; System.out.println(per) ; // Person@ 1f 6226 System.out.println(per.toString()) ; // Person@ 1f 6226 } } 现在可以清楚地方发现，如果直接输出一个类的对象，那么和这个对象调用toString()方法的结果是完全一样的，那么就可以得出一个结论：对象直接输出默认调用了Object类之中的toString()方法，但是默认的toString()方法有一个特点：为了适用于所有的子类，那么在toString()默认情况下就是输出了对象地址，当然，每一个子类也可以自己进行修改。 class Person { private String name ; private int age ; public Person(String name,int age) { this.name = name ; this.age = age ; } public String toString() { // 方法覆写 return “姓名：” + this.name + “，年龄：” + this.age ; } } public class TestDemo { public static void main(String args[]) { Person per = new Person(“张三”,20) ; System.out.println(per) ; // Person@ 1f 6226 } } 3.2.2、对象比较：equals()实际上对于equals()方法应该并不陌生了，这个方法在String类中见过，String是Object类的子类，所以String类的equals()方法就是覆写了Object类中的equals()方法，在Object类之中，默认的equals()方法实现比较的是两个对象的内存地址数值，但是并不符合于真正的对象比较需要。对象比较之前也写过，但是之前是自己定义了一个新的方法名称，今天可以给出标准的方法名称：equals()。 class Person { private String name ; private int age ; public Person(String name,int age) { this.name = name ; this.age = age ; } public String toString() { // 方法覆写 return “姓名：” + this.name + “，年龄：” + this.age ; } public boolean equals(Object obj) { if (this == obj) { return true ; } if (obj == null) { return false ; } if (! (obj instanceof Person)) { // 不是本类对象 return false ; } // 因为name和age属性是在Person类中定义，而Object类没有 Person per = (Person) obj ; if (this.name.equals(per.name) &amp;&amp; this.age == per.age) { return true ; } return false ; } } public class TestDemo { public static void main(String args[]) { Person per1 = new Person(“张三”,20) ; Person per2 = new Person(“张三”,20) ; System.out.println(per1.equals(“Hello”)) ; System.out.println(per1.equals(per2)) ; } } 3.2.3、使用Object接收所有的引用数据类型Object是所有类的父类，那么Object类可以接收所有类的对象，但是在Java设计的时候，考虑到引用数据类型的特殊性，所以Object类实际上是可以接收所有引用数据类型的数据，这就包括了数组、接口、类。 范例：使用Object类接收数组，数组和Object没有任何明确的定义关系 public class TestDemo { public static void main(String args[]) { Object obj = new int [] {1,2,3} ; // 接收数组 if (obj instanceof int []) { int [] data = (int []) obj ; // 向下转型 for (int x = 0 ; x &lt; data.length ; x ++) { System.out.println(data[x]) ; } } } } 范例：接收接口对象，从接口定义而言，它是不能去继承一个父类的，但是由于接口依然属于引用类型，所以即使没有继承类，也可以使用Object接收。 interface Message { } class MessageImpl implements Message { // 定义接口子类 public String toString() { return “New Message : Hello World .” ; } } public class TestDemo { public static void main(String args[]) { Message msg = new MessageImpl() ; // 向上转型 Object obj = msg ; // 使用Object接收接口对象，向上转型 Message temp = (Message) obj ; // 向下转型 System.out.println(temp) ; // toString() } } 从代码上讲，以上只能算是一个固定的操作概念，不过从实际来讲，因为有了Object类的出现，所以的操作的数据就可以达到统一，那么之前的链表程序，就应该变的很方便了，所有的数据都使用Object接收，所有的对象比较（删除、查找）都可以使用equals()。 3.3、包装类（重点）在Java的设计之中，一直提倡一个原则：一切皆对象，这个原则本身有一个漏洞 ——基本数据类型不是对象，所以这个原则就出现了问题。那么如果说现在这个问题由我们来解决，该如何做呢？ class Int { // 类 private int num ; // 基本型 public Int(int num) { this.num = num ; } public int intValue() { return this.num ; } } public class TestDemo { public static void main(String args[]) { Int temp = new Int(10) ; // 把基本类型变为类 int result = temp.intValue() ; System.out.println(result * result) ; } } 以上的操作是将基本类型变为了一个对象的形式进行操作了，但是这里面有一个问题：基本数值型数据是可以进行数学运算的，可是以上变为了类的形式，那么肯定无法直接计算了。而且以上的问题既然我们都可以想到方法去解决，那么java也一定早已解决，为此它专门提供了八种包装类：byte（Byte）、short（Short）、int（Integer）、long（Long）、float（Float）、double（Double）、boolean（Boolean）、char（Character），而这八种包装类又分为两大阵营： · 数值型（Number子类）：Byte、Short、Integer、Float、Double、Long； · 对象型（Object子类）：Boolean、Character。 可是对于Number的子类，就必须观察出Number类之中定义的方法：byteValue()、intValue()、doubleValue()、shortValue()、floatValue()、doubleValue()，就是从包装的类之中取得所包装的数值。 3.3.1、装箱与拆箱在基本数据类型和包装类之间的转换操作之中分为两个重要概念： · 装箱操作：将基本数据类型变为包装类，称为装箱，包装类的构造方法； · 拆箱操作：将包装类变为基本数据类型，称为拆箱，各个类的xxValue()方法。 范例：以int和Integer为例 public class TestDemo { public static void main(String args[]) { Integer var = new Integer(15) ; // 装箱 int result = var.intValue() ; // 拆箱 System.out.println(result * result) ; } } 范例：以double和Double为例 public class TestDemo { public static void main(String args[]) { Double var = new Double(15.5) ; // 装箱 double result = var.doubleValue() ; // 拆箱 System.out.println(result * result) ; } } 范例：以boolean和Boolean为例 public class TestDemo { public static void main(String args[]) { Boolean var = new Boolean(true) ; // 装箱 boolean result = var.booleanValue() ; // 拆箱 if (result) { System.out.println(“Hello World .”) ; } } } 以上的操作是在JDK 1.5之前所进行的必须的操作，但是到了JDK1.5之后，Java提供了自动的装箱和拆箱机制，并且包装类的对象可以自动的进行数学计算了。 public class TestDemo { public static void main(String args[]) { Integer var = 15 ; // 自动装箱 int result = var ; // 自动拆箱 System.out.println(++ var * result) ; } } public class TestDemo { public static void main(String args[]) { Boolean var = true ; // 自动装箱 if (var) { // 自动拆箱后操作 System.out.println(“Hello World .”) ; } } } 那么正是因为有了这样的自动装箱和拆箱的机制，所以Object也可以接收基本数据类型的数据。 public class TestDemo { public static void main(String args[]) { Object obj = 15 ; // int –&gt; 自动装箱 –&gt; Object int result = (Integer) obj ; // Object –&gt; 包装类 –&gt; 自动拆箱 System.out.println(result * result) ; } } 但是到此处还有一个小问题，实际上这一问题之前已经见过的。 public class TestDemo { public static void main(String args[]) { Integer x = new Integer(10) ; // 新空间 Integer y = 10 ; // 入池 Integer z = 10 ; System.out.println(x == y) ; // false System.out.println(x == z) ; // false System.out.println(z == y) ; // true System.out.println(x.equals(y)) ; // true } } 以后使用包装类的时候还需要考虑equals()和==的区别。 3.3.2、数据转型包装类之中所提供的最大优点还在于可以将字符串变为指定的基本数据类型，下面列出几个操作： · Integer类：public static int parseInt(String s)； · Double类：public static double parseDouble(String s)； · Boolean类：public static boolean parseBoolean(String s)； 但是Character这个包装类之中，并没有提供一个类似的parseCharacter()，因为字符串String类之中提供了一个charAt()方法，可以取得指定索引的字符，而且一个字符的长度就是一位。 范例：将字符串变为int public class TestDemo { public static void main(String args[]) { String str = “16” ; int result = Integer.parseInt(str) ; // String –&gt; int System.out.println(result * result) ; } } 但是需要提醒的是，在执行这种转换的操作过程之中，字符串中的全部内容必须由数字所组成，如果有一位内容不是数字，则在转换的过程之中将出现如下的错误提示：NumberFormatException。 范例：将字符串变为double public class TestDemo { public static void main(String args[]) { String str = “36.” ; double result = Double.parseDouble(str) ; System.out.println(result * result) ; } } 范例：将字符串变为boolean型数据 public class TestDemo { public static void main(String args[]) { String str = “true” ; boolean result = Boolean.parseBoolean(str) ; if (result) { System.out.println(“Hello World .”) ; } } } 提示：在使用Boolean型包装类的时候，如果字符串之中的内容不是true或者是false，统一都按照false处理。 以上的操作是通过字符串变为了一些基本类型的数据，但是反过来讲，基本类型如何变为字符串呢？ · 方式一：任何的基本类型数据遇到了String之后都变为String型数据； public class TestDemo { public static void main(String args[]) { int num = 100 ; String str = num + “” ; // int –&gt; String System.out.println(str.length()) ; } } · 方式二：利用String类的方法，public static String valueOf(数据类型 b) public class TestDemo { public static void main(String args[]) { int num = 100 ; String str = String.valueOf(num) ; // int –&gt; String System.out.println(str.length()) ; } } 字符串向各个基本数据类型的转换，是一个非常重要的内容，必须熟练。 3.4、思考题（核心）一个动物园有多种动物，现在要求实现某类动物的添加、某一类动物的取消、以及关键字检索动物信息的操作 提示：要求代码模型，动物属性以名称和年龄为主 分析： 1、首先需要分析出本程序的关系：一个动物园有多种动物，按照道理是属于一对多的操作关系，而多的一方肯定通过Link来表示，而且Link可以针对于各种类型。 2、什么叫动物？动物是一个标准，既然是标准，肯定在类之上，那么一定就是接口，所以对于整个程序应该先把接口定义出来，那么接口只有两个功能： 范例：定义出动物的接口 interface Animal { // 动物 public String getName() ; public int getAge() ; } 范例：定义动物园，动物园里面只关心接口，而不关心具体有什么动物。 class Zoo { private Link animals = new Link() ; // 多个动物 public void add(Animal ani) { // 增加动物 this.animals.add(ani) ; // 增加动物 } public void delete(Animal ani) { this.animals.remove(ani) ; // 需要equals() } public Link search(String keyWord) { Link result = new Link() ; Object obj [] = this.animals.toArray() ; for (int x = 0 ; x &lt; obj.length ; x ++) { Animal ani = (Animal) obj[x] ; if (ani.getName().contains(keyWord)) { // 满足 result.add(ani) ; } } return result ; } } 动物园没和具体的动物有关，只和动物的标准有关，而后下面按照标准去定义动物。 范例：定义狗 class Dog implements Animal { private String name ; private int age ; public Dog(String name,int age) { this.name = name ; this.age = age ; } public String getName() { return this.name ; } public int getAge() { return this.age ; } public boolean equals(Object obj) { if (this == obj) { return true ; } if (obj == null) { return false ; } if (!(obj instanceof Dog)) { return false ; } Dog dog = (Dog) obj ; if (this.name.equals(dog.name) &amp;&amp; this.age == dog.age) { return true ; } return false ; } public String toString() { return “〖狗的信息〗名字：” + this.name + “，年龄：” + this.age ; } } 范例：定义老虎 class Tiger implements Animal { private String name ; private int age ; public Tiger(String name,int age) { this.name = name ; this.age = age ; } public String getName() { return this.name ; } public int getAge() { return this.age ; } public boolean equals(Object obj) { if (this == obj) { return true ; } if (obj == null) { return false ; } if (!(obj instanceof Dog)) { return false ; } Tiger t = (Tiger) obj ; if (this.name.equals(t.name) &amp;&amp; this.age == t.age) { return true ; } return false ; } public String toString() { return “〖老虎的信息〗名字：” + this.name + “，年龄：” + this.age ; } } 范例：定义测试类 public class TestDemo { public static void main(String args[]) { Zoo zoo = new Zoo() ; // 动物园 zoo.add(new Dog(“花狗”,1)) ; zoo.add(new Dog(“黄狗”,1)) ; zoo.add(new Dog(“黑狗”,1)) ; zoo.add(new Dog(“斑点狗”,1)) ; zoo.add(new Tiger(“斑点虎”,2)) ; zoo.add(new Tiger(“黑虎”,2)) ; zoo.add(new Tiger(“花虎”,2)) ; zoo.delete(new Dog(“斑点狗”,1)) ; // 删除 Link result = zoo.search(“斑点”) ; Object obj [] = result.toArray() ; for (int x = 0 ; x &lt; obj.length ; x ++) { System.out.println(obj[x]) ; } } } 利用此代码模型，日后可以解决以下问题： · 一个停车场可以停放多种车辆； · 一列火车上可以有不同国家的人乘座； · 一个人的书包可以放多物品； · 一个超市里有多种商品，每个人可以购买自己的商品。 4、总结1、 匿名内部类现在不使用； 2、 Object类可以接收任意的对象，是所有类的父类； 3、包装类可以使用自动装箱和拆箱进行操作，以及可以与字符串之间进行的数据互相转换； 4、 接口和链表的应用。 5、预习任务异常的捕获及处理、包及访问控制权限、Eclipse开发工具。","categories":[],"tags":[]},{"title":"","slug":"Java网络编程","date":"2020-08-10T14:21:51.338Z","updated":"2020-08-10T14:17:09.435Z","comments":true,"path":"2020/08/10/java-wang-luo-bian-cheng/","link":"","permalink":"https://kilitom.github.io/2020/08/10/java-wang-luo-bian-cheng/","excerpt":"","text":"3.1、网络编程（了解） 网络编程指的就是通过网络进行程序数据操作，既然是网络开发，那么一定就分为用户和服务两端，而这两个端的开发实际上就有以下的两种不同的架构（面试题：请解释C/S和B/S的区别？）： · C/S（Client / Server）：要开发两套程序，一套是服务器端，另外一套是与之对应的客户端，但是这种程序在日后进行维护的时候，是需要维护两套程序，而且客户端的程序更新也必须及时，此类程序安全； · B/S（Browser / Server）：要开发一套程序，只开发服务器端的，客户端使用浏览器进行访问，这种程序在日后进行程序维护的时候只需要维护服务器端即可，客户端不需要做任何的修改，此类程序使用公共端口，包括公共协议，所以安全性很差。 如果从网络的开发而言，大的分类是以上的两类，可是从现在的开发来讲，更多的情况是针对于B/S程序进行的开发，或者可以这么理解：B/S程序的开发属于网络时代，而C/S程序的开发属于单机时代。而对于WebService的开发，实话而言，也属于B/S结构的程序（跨平台）。 而在日后学习Android开发的时候，如果要考虑安全性使用Socket，如果要考虑方便性，还是基于WEB的开发方便使用。而对于网络的开发在Java中也分为两种：TCP（传输控制协议，可靠的传输）、UDP（数据报协议），对于网络开发，本次只专注于TCP程序的实现。 3.2、网络程序的基本实现（了解） 如果要进行网络程序的开发，那么首先应该开发出的就是服务器端，本次的操作使用服务器端向客户端输出一个“HelloWorld.”的字符串信息，而如果要想完成服务器端的开发，则需要java.net包中的两个类： ·ServerSocket类：是一个封装支持TCP协议的操作类，主要工作在服务器端，用于接收客户端请求； · Socket类：也是一个封装了TCP协议的操作类，每一个Socket对象都表示一个客户端。 而现在必须观察这两个类之中的操作方法： · ServerSocket类的方法： No. 方法名称 类型 描述 1 public ServerSocket(int port) throws IOException 构造 开辟一个指定的端口监听，一般使用5000以上 2 public Socket accept() throws IOException 普通 服务器端接收客户端请求，通过Socket返回 3 public void close() throws IOException 普通 关闭服务器端 · Socket类的方法： No. 方法名称 类型 描述 1 public Socket(String host, int port) throws UnknownHostException, IOException 构造 指定要连接的主机（IP地址）和端口 2 public OutputStream getOutputStream() throws IOException 普通 取得指定客户端的输出对象，使用的时候肯定使用PrintStream装饰操作 3 public InputStream getInputStream() throws IOException 普通 从指定的客户端读取数据，使用Scanner操作 范例：完成一个服务器端程序代码 package cn.mldn.netdemo; import java.io.PrintStream; import java.net.ServerSocket; import java.net.Socket; public class HelloServer { public static void main(String[] args) throws Exception { ServerSocket server = new ServerSocket(9999); // 在9999端口监听 System.out.println(“服务开始启动…”); Socket client = server.accept(); // 接收客户端连接，进入到阻塞状态 PrintStream out = new PrintStream(client.getOutputStream()); out.println(“Hello World .”); // 向客户端输出 out.close(); // 输出流的关闭 client.close(); // 关闭客户端 server.close(); // 关闭服务器端 System.out.println(“服务器已关闭…”); } } 现在服务器端已经开发完成了，而现在的服务器端虽然是通过Java编写的，但是使用的是TCP协议，所以可以利用系统命令的telnet进行访问。 · 使用运行方式输入：telnet； · 连接服务器：open ip地址 端口，open localhost 9999； 但是现在是利用了系统的工具完成的，那么在开发之中是不可能使用这工具，应该自己去编写客户端。 范例：编写一个客户端 package cn.mldn.netdemo; import java.net.Socket; import java.util.Scanner; public class HelloClient { public static void main(String[] args) throws Exception { Socket client = new Socket(“localhost”, 9999); Scanner scan = new Scanner(client.getInputStream()); scan.useDelimiter(“\\n”) ; if (scan.hasNext()) { // 有数据 System.out.println(“服务器的回应数据：” + scan.next()); } scan.close() ; client.close() ; } } 整个的操作就是一个输出和输入的过程，只是现在的输出和输入的来源在于网络，而不是像之前那样是通过文件操作了。 3.3、网络开发的经典模型 —— ECHO程序 这种开发模型的典型模式指的是客户端要输入信息，而后服务器端接收这端信息之后，前面增加一个“ECHO：”的信息再返回给客户端，也就是说现在的服务器端需要输入和输出数据。 范例：编写一个程序的基本模型 package cn.mldn.netdemo; import java.io.PrintStream; import java.net.ServerSocket; import java.net.Socket; import java.util.Scanner; public class EchoServer { public static void main(String[] args) throws Exception { ServerSocket server = new ServerSocket(9999); boolean flag = true; System.out.println(“服务器运行…”); Socket client = server.accept(); // 接收客户端请求 Scanner scan = new Scanner(client.getInputStream()); PrintStream out = new PrintStream(client.getOutputStream()); while (flag) { if (scan.hasNext()) { // 有内容 String str = scan.next(); if (“byebye”.equalsIgnoreCase(str.trim())) { // 程序结束 out.println(“Bye Bye…”); flag = false; // 退出循环 } out.println(“ECHO：” + str.trim()); // 回应数据 } } System.out.println(“服务器停止运行…”); server.close(); } } 这个时候程序实际上是一种单线程的运行状态，这样的程序运行起来只能够为一个用户进行服务，所以如果希望一个服务器可以同时处理多个客户的操作，那么就必须为其实现多线程的处理机制，让每一个客户端表示一个独立的线程对象，每个线程对象有自己独立的输入输出操作。 范例：为服务器端增加多线程机制，使用匿名内部类 package cn.mldn.netdemo; import java.io.IOException; import java.io.PrintStream; import java.net.ServerSocket; import java.net.Socket; import java.util.Scanner; public class EchoServer { public static void main(String[] args) throws Exception { ServerSocket server = new ServerSocket(9999); boolean flag = true; System.out.println(“服务器运行…”); while (flag) { final Socket client = server.accept(); // 接收客户端请求 new Thread(new Runnable() { @Override public void run() { boolean runFlag = true; try { Scanner scan = new Scanner(client.getInputStream()); PrintStream out = new PrintStream(client.getOutputStream()); while (runFlag) { if (scan.hasNext()) { // 有内容 String str = scan.next(); if (“byebye”.equalsIgnoreCase(str.trim())) { // 程序结束 out.println(“Bye Bye…”); runFlag = false; // 退出循环 } out.println(“ECHO：” + str.trim()); // 回应数据 } } } catch (IOException e) { e.printStackTrace(); } try { client.close() ; } catch (IOException e) { e.printStackTrace(); } } }).start(); } System.out.println(“服务器停止运行…”); server.close(); } } 但是，在这个时候对于线程的控制也需要处理好，如果处理不好，可能就出现死锁问题了。 4、总结 知道什么叫网络编程就行了，暂时用不到。","categories":[],"tags":[]},{"title":"","slug":"包","date":"2020-08-10T14:21:51.338Z","updated":"2020-08-10T14:15:31.541Z","comments":true,"path":"2020/08/10/bao/","link":"","permalink":"https://kilitom.github.io/2020/08/10/bao/","excerpt":"","text":"3.1、包（重点） 3.1.1、包的定义 在Java程序之中的包，主要的目的是可以将不同功能的文件进行分割。在之前的代码开发之中，所有的程序都保存在了同一个目录之中，这样一来所带来的问题：如果出现了同名文件，那么会发生覆盖问题，因为在同一个目录之中不允许有重名文件，而在不同的目录下可以有重名文件，所谓的包实际上指的就是文件夹。 在Java之中使用package关键字来定义包，其定义如下： 范例：定义Hello.java package cn.mldn.demo ; // 定义包 public class Hello { public static void main(String args[]) { System.out.println(“Hello World .”) ; } } 一旦包定义完成之后，那么这个类的名字就成了“cn.mldn.demo.Hello”，即这是完整的类名称，而在进行程序编译的时候也需要将*.class文件保存在包之中，于是为了方便开发，那么也就提供了一个打包编译的操作： javac -d . Hello.java 这个命令之间有空格，每一个操作的含义： · -d：表示的是生成文件目录，根据package的定义生成； · .：表示在当前所在的目录下生成。 这个时候类的名字必须带上包的名称，所以执行类的时候：javacn.mldn.demo.Hello，也就是说完整类的名称就是“包.类”，而在所有的开发之中，没有包的类是绝对不存在的，只要是程序一定要有包。 3.1.2、包的导入 既然使用包可以将一个大型的程序拆分成不同的功能目录保存，那么这些不同的包之间也一定会存在包的导入问题，而导入包在程序之中使用import完成，下面通过一个程序来进行演示。 范例：定义一个Message.java的类 package cn.mldn.util ; class Message { public String getInfo() { return “Hello World .” ; } } 范例：随后定义另外一个类，使用Message类 package cn.mldn.test ; import cn.mldn.util.Message ; // 导入包 public class Test { public static void main(String args[]) { Message msg = new Message() ; System.out.println(msg.getInfo()) ; } } 这个时候上面的两个类应该是按照顺序编译： · 应该首先编译Message.java程序：javac -d . Message.java； · 再次编译Test.java程序：javac -d .Test.java，但是这个时候出现了以下的错误提示： Test.java:2: 错误: Message在cn.mldn.util中不是公共的; 无法从外部程序包中对其进行访问 import cn.mldn.util.Message ; // 导入包 提示：关于public class和class定义类的区别 · publicclass：文件名称和类名称保持一致，在一个*.java文件之中只能存在一个publicclass定义，如果一个类要想被外部的包所访问必须定义为public； ·class：文件名称可以和类名称不一致，在一个*.java之中可以同时存在多个class定义，并且编译完成之后会形成多个*.class文件，使用class定义的类只能够在一个包中访问，不同包无法访问。 范例：修改Message.java程序 package cn.mldn.util ; public class Message { public String getInfo() { return “Hello World .” ; } } 但同时也可以发现一个问题，现在这些类编译的时候要有顺序，实在是麻烦了，为此在Java之中专门提供了一个可以进行自动联编的操作，编译的时候使用*.java：javac-d . *.java，将一个目录之中的所有的*.java文件进行编译。 但是以上的代码还有一个小问题：程序在进行导入的时候使用了“包.类”的完整名称完成的，但是如果在一个程序之中要同时导入一个包的多个类的时候，那么分开去编写实在是很麻烦，为此可以使用通配符“*”完成导入。 package cn.mldn.test ; import cn.mldn.util.* ; // 导入包 public class Test { public static void main(String args[]) { Message msg = new Message() ; System.out.println(msg.getInfo()) ; } } 但是需要注意的是，在Java之中是使用“*”或者是单独导入，其从实际的操作性能上来讲是没有任何区别的，因为即使使用了*也表示只导入所需要的类，不需要的不导入。 可是在导入包的时候也会遇到一种比较麻烦的问题：会导入不同包的同名类，例如：对于Message类，现在在两个包中都有：cn.mldn.util、cn.mldnjava.info。 package cn.mldnjava.info ; public class Message { public String getMsg() { return “世界，你好！” ; } } 范例：由于某种需要，同时导入两个包，这个时候要使用Message类的时候必须加上类的全名。 package cn.mldn.test ; import cn.mldn.util.* ; // 导入包 import cn.mldnjava.info.* ; // 导入包 public class Test { public static void main(String args[]) { cn.mldn.util.Message msg = new cn.mldn.util.Message() ; System.out.println(msg.getInfo()) ; } } 这种情况在开发之中经常可见到，习惯了就好。 3.1.3、jar命令 Jar是一种Java给出的压缩格式文件，即：可以将*.class文件以*.jar压缩包的方式给用户，这样方便程序的维护。如果要使用jar的话，可以直接利用JDK给出的jar命令完成。 在以上的操作之中，往往只使用三个参数： · -c：创建一个新的文件； · -v：生成标准的压缩信息； · -f：由用户自己指定一个*.jar的文件名称。 范例：Message.java package cn.mldn.util ; public class Message { public String getInfo() { return “Hello World .” ; } } · 将Message.java程序进行编译：javac -d . Message.java，生成包.类； · 将“包.类”压缩成my.jar文件：jar -cvf my.jar cn，出现了一个my.jar包； 范例：定义一个测试类，使用以上的程序 package cn.mldn.test ; public class Test { public static void main(String args[]) { cn.mldn.util.Message msg = new cn.mldn.util.Message() ; System.out.println(msg.getInfo()) ; } } 现在my.jar和Test.java处于同一目录之中。但是发现找不到my.jar之中定义的内容，这是因为在java之中每一个*.jar文件都属于一个独立的CLASSPATH路径，如果要想使用，必须配置CLASSPATH。 SET CLASSPATH=.;d:\\javademo\\my.jar 以上的配置只是针对于一个命令行方式下完成的，如果现在希望针对于全局配置，则需要修改环境属性。 3.2、Java的常用包（了解） Java语言最大的特点是提供了大量的开发支持，尤其是经过了这么多年的发展，几乎只要想做的技术，Java都可以完成了，而且有大量的开发包支撑着。而对于JAVASE部分也提供了一些常见的系统包，下面分别来看。 · java.lang：包含了一些系统的常用类，例如：String、Object、Integer等，JDK1.1之后此包默认导入； · java.lang.reflect：Java的反射机制操作包； · java.util：是一个工具的提供包，里面提供了各种的工具操作类； · java.util.regex：正则开发包； · java.io：编写IO操作； · java.sql：数据库的程序开发包； · java.net：网络程序开发包； · java.applet：小应用程序开发包； 在1995年出现java的时候最早就是以小应用程序为主的，小应用程序最大的特点是嵌入在HTML代码之中进行展示，但是这种程序已经随着时间的推移不再开发了，下面演示一个比较简单的程序。 范例：定义一个Hello.java类 package cn.mldn.demo ; // 定义包 import java.applet.* ; import java.awt.* ; public class Hello extends Applet { public void paint(Graphics g) { g.drawString(“Hello World .”,20,20) ; } } 范例：定义一个HTML文件，使用以上的程序 &lt;applet code=”cn.mldn.demo.Hello” height=”300” width=”300”/&gt; 提示：关于Applet和Application的区别？ · Applet是不需要主方法运行的，需要嵌入在HTML代码之中； · Application是需要通过主方法执行。 · java.awt.、javax.swing：是进行图形界面的开发包，其中java.awt是一组重量级的组件包，而javax.swing是属于轻量级的组件包，并且JDK 1.2的最大特点是加入了javax.swing包； 3.3、四种访问权限（重点） 对于封装型实际上在之前只讲解了一个private，而封装性如果要想讲解完整，必须结合四种访问权限来看。 No. 范围 private default protected public 1 在同一包的同一类 √ √ √ √ 2 同一包的不同类 √ √ √ 3 不同包的子类 √ √ 4 不同包的非子类 √ 以上可以简单理解为： · private只能在一个类中访问； · default：只能在一个包中访问； · protected：在不同包子类； · public：所有都可以。 范例：观察protected权限 package cn.aa ; public class A { protected String info = “Hello World .” ; } 范例：在不同的包继承此类 package cn.bb ; import cn.aa.A ; public class B extends A { public void print() { System.out.println(super.info) ; } } 范例：定义测试类 package cn.test ; import cn.bb.* ; public class Test { public static void main(String args[]) { new B().print() ; } } 实际上对于四种权限本人原则： · 属性永远都是private； · 正常类的方法永远都是public； · protected实际上也属于一种封装，但是这种封装知道特点就行了。 封装：private、default、protected。 3.4、命名规范（重点） 命名规范的主要特点就是保证程序之中类名称或方法等名称的标记明显一些，可是对于Java而言，有一些固定的命名规范还是需要遵守的： · 类名称：每一个单词的开头首字母大写，例如：TestDemo； · 变量名称：第一个单词的首字母小写，之后每个单词的首字母大写，例如：studetName； ·方法名称：第一个单词的首字母小写，之后每个单词的首字母大写，例如：printInfo()； · 常量名称：每个字母大写，例如：FLAG； · 包名称：所有字母小写，例如：cn.mldnjava.util。 4、总结 1、 所有的类都要有包； 2、 虽然访问权限有四种，但是我们只需要使用private、public，99%通用原则。","categories":[],"tags":[]},{"title":"","slug":"处理异常","date":"2020-08-10T14:21:51.338Z","updated":"2020-08-10T14:15:20.425Z","comments":true,"path":"2020/08/10/chu-li-yi-chang/","link":"","permalink":"https://kilitom.github.io/2020/08/10/chu-li-yi-chang/","excerpt":"","text":"3.1、认识异常（了解） 异常是程序之中导致程序中断的一种指令流，下面，通过两个程序来进行异常产生问题的对比。 范例：不产生异常的程序 public class TestDemo { public static void main(String args[]) { System.out.println(“1、除法计算开始。”) ; int result = 10 / 2 ; System.out.println(“2、除法计算结果：” + result) ; System.out.println(“3、除法计算结束。”) ; } } 1、除法计算开始。 2、除法计算结果：5 3、除法计算结束。 范例：产生异常的程序 public class TestDemo { public static void main(String args[]) { System.out.println(“1、除法计算开始。”) ; int result = 10 / 0 ; // 会出现错误 System.out.println(“2、除法计算结果：” + result) ; System.out.println(“3、除法计算结束。”) ; } } 1、除法计算开始。 Exception in thread “main” java.lang.ArithmeticException: / by zero at TestDemo.main(TestDemo.java:4) 这时候程序出现了错误，那么出现错误之后的程序不执行了，而是直接进行了错误信息的输出，并且直接结束程序。但是，出现了错误，应该去处理才对，但是现在没有处理。 3.2、处理异常（重点） 现在，如果希望程序出现了异常之后，程序依然可以正常的完成的话，那么就可以使用如下的格式进行异常的处理： try { 可能出现异常的语句 ; } [ catch (异常类型 异常对象) { 处理异常 ; } catch (异常类型 异常对象) { 处理异常 ; } … ] [finally { 不管是否出现异常，都执行此代码 ; }] 范例：使用以上的操作处理异常 public class TestDemo { public static void main(String args[]) { System.out.println(“1、除法计算开始。”) ; try { int result = 10 / 0 ; // 异常 System.out.println(“2、除法计算结果：” + result) ; // 之前语句有异常，此语句不再执行 } catch (ArithmeticException e) { System.out.println(e) ; // 异常处理：输出错误信息，java.lang.ArithmeticException: / by zero } System.out.println(“3、除法计算结束。”) ; } } 1、除法计算开始。 java.lang.ArithmeticException: / by zero 3、除法计算结束。 可以发现，加入了异常处理之后，程序之中即使有了异常，程序也可以正常的执行完毕，但是现在发现，异常处理时的错误输出信息和之前相比，出错的信息不明确了，那么为了让错误的信息更加的完整，一般而言，都会调用printStackTrace()方法进行异常信息的打印，这个方法打印的异常信息是最完整的： java.lang.ArithmeticException: / by zero at TestDemo.main(TestDemo.java:5) 范例：加入finally public class TestDemo { public static void main(String args[]) { System.out.println(“1、除法计算开始。”) ; try { int result = 10 / 1 ; System.out.println(“2、除法计算结果：” + result) ; } catch (ArithmeticException e) { e.printStackTrace() ; } finally { System.out.println(“不管是否出现异常都执行”) ; } System.out.println(“3、除法计算结束。”) ; } } 对于finally的实际应用必须结合之后的异常处理的标准格式来看，单独看，没意义。 但是，对于之前的程序现在又有了问题：现在执行数学计算的两个参数，都是由程序默认提供，那么如果说现在两个计算的参数通过初始化参数传递呢？ public class TestDemo { public static void main(String args[]) { System.out.println(“1、除法计算开始。”) ; try { int x = Integer.parseInt(args[0]) ; // 接收参数 int y = Integer.parseInt(args[1]) ; // 接收参数 int result = x / y ; System.out.println(“2、除法计算结果：” + result) ; } catch (ArithmeticException e) { e.printStackTrace() ; } finally { System.out.println(“不管是否出现异常都执行”) ; } System.out.println(“3、除法计算结束。”) ; } } 这个时候，数据由外部传送，那么在这种情况下，就有可能出现以下几类问题： · 执行时不输入参数（java TestDemo），ArrayIndexOutOfBoundsException，未处理； · 输入的参数不是数字（java TestDemo a b），NumberFormatException，未处理； · 被除数为0（java TestDemo 10 0），ArithmeticException，已处理。 可以发现，以上的程序实际上是存在三种异常，而程序之中只能够处理一种，而对于不能处理的异常，发现程序依然会直接中断执行。 public class TestDemo { public static void main(String args[]) { System.out.println(“1、除法计算开始。”) ; try { int x = Integer.parseInt(args[0]) ; int y = Integer.parseInt(args[1]) ; int result = x / y ; System.out.println(“2、除法计算结果：” + result) ; } catch (ArithmeticException e) { e.printStackTrace() ; } catch (ArrayIndexOutOfBoundsException e) { e.printStackTrace() ; } catch (NumberFormatException e) { e.printStackTrace() ; } finally { System.out.println(“不管是否出现异常都执行”) ; } System.out.println(“3、除法计算结束。”) ; }} 此时，问题就来了，如果按照以上的方式一次一次的测试来进行异常类型的推断，还不如直接编写多个if..else。 3.3、异常的处理流程（重点） 以上已经完成了异常的基本处理流程，但是也可以发现问题，所有的异常都像之前那样一条条的判断似乎是一件不可能完成的任务，因为日后肯定会接触到一些不常见的异常信息，那么下面就必须首先研究异常的流程和结构。 先查看两个异常类的继承结构： ArithmeticException： ArrayIndexOutOfBoundsException： java.lang.Object |- java.lang.Throwable |- java.lang.Exception |- java.lang.RuntimeException |- java.lang.ArithmeticException java.lang.Object |- java.lang.Throwable |- java.lang.Exception |- java.lang.RuntimeException |- java.lang.IndexOutOfBoundsException |- java.lang.ArrayIndexOutOfBoundsException 可以发现所有的异常类型最高的继承类是Throwable，通过doc文档可以发现在Throwable下有两个子类： （面试题：请解释Error和Exception的区别？） · Error：指的是JVM错误，这个时候的程序并没有执行，无法处理； · Exception：指的是程序之中出现的错误信息，可以进行异常处理，主要关心Exception。 那么通过继承关系可以发现，肯定在进行日后异常处理的时候是以Exception为主，而这个时候就可以形成以下的异常处理流程（面试题：请解释java之中的异常处理流程。） 1、如果程序之中产生了异常，那么会自动的由JVM根据异常的类型，实例化一个指定异常类的对象； 2、如果这个时候程序之中没有任何的异常处理操作，则这个异常类的实例化对象将交给JVM进行处理，而JVM的默认处理方式就是进行异常信息的输出，而后中断程序执行； 3、 如果程序之中存在了异常处理，则会由try语句捕获产生的异常类对象； 4、与try之后的每一个catch进行匹配，如果匹配成功，则使用指定的catch进行处理，如果没有匹配成功，则向后面的catch继续匹配，如果没有任何的catch匹配成功，则这个时候将交给JVM执行默认处理； 5、不管是否有异常都会执行finally程序，如果此时没有异常，执行完finally，则会继续执行程序之中的其他代码，如果此时有异常没有能够处理（没有一个catch可以满足），那么也会执行finally，但是执行完finally之后，将默认交给JVM进行异常的信息输出，并且程序中断； 通过以上的分析，可以发现，实际上catch捕获异常类型的操作，就和方法接收参数是一样的，那么按照之前所学习过的对象多态性来讲，所有的异常类都是Exception的子类，那么这个时候，实际上所有的异常都可以使用Exception进行接收。 public class TestDemo { public static void main(String args[]) { System.out.println(“1、除法计算开始。”) ; try { int x = Integer.parseInt(args[0]) ; int y = Integer.parseInt(args[1]) ; int result = x / y ; System.out.println(“2、除法计算结果：” + result) ; } catch (Exception e) { e.printStackTrace() ; } finally { System.out.println(“不管是否出现异常都执行”) ; } System.out.println(“3、除法计算结束。”) ; } } 那么这个时候就应该可以感受到异常处理所带来的好处了。但是这种操作也存在一种问题。如果在一些异常处理要求严格的项目之中，异常必须分别处理，如果现在异常的处理要求不是很严格，直接编写Exception就足够了。 3.4、throws关键字（重点） thrwos关键字主要是在方法定义上使用的，表示的是此方法之中不进行异常的处理，而交给被调用处处理。 class MyMath { public int div(int x,int y) throws Exception { return x / y ; } } 现在的div()方法之中抛了一个异常出来，表示的是，所有的异常交给被调用处进行处理。 class MyMath { public int div(int x,int y) throws Exception { return x / y ; } } public class TestDemo { public static void main(String args[]) { try { System.out.println(new MyMath().div(10,0)) ; } catch (Exception e) { e.printStackTrace() ; } } } 在调用throws声明方法的时候，一定要使用异常处理操作进行异常的处理，这个是属于强制性的处理，而现在主方法本身也属于方法，那么实际上在主方法上也可以继续使用throws进行异常的抛出。 class MyMath { public int div(int x,int y) throws Exception { return x / y ; } } public class TestDemo { public static void main(String args[]) throws Exception { System.out.println(new MyMath().div(10,0)) ; } } 这个时候表示的是将异常继续向上抛，交给JVM进行异常的处理。 3.5、throw关键字（重点） 之前的所有异常类对象都是由JVM自动进行实例化操作的，而现在用户也可以自己手工的抛出一个实例化对象，就通过throw完成了。 public class TestDemo { public static void main(String args[]){ try { throw new Exception(“抛着玩的，你管不着。”) ; } catch (Exception e) { e.printStackTrace() ; } } } 理论上，对于异常应该躲，现在属于不躲反而自己抛了，有病啊？ 3.6、异常处理的标准格式（重点） 现在觉得有两个内容实在是没有用处：finally、throw。 现在要求定义一个div()方法，而这个方法有如下的一些要求： · 在进行除法操作之前，输出一行提示信息，可以理解为大爷开门； · 在除法操作执行完毕后，输出一行提示信息，可以理解为大爷关门； · 如果中间产生了异常，则应该交给被调用处来进行处理，譬如：xxOver了。 class MyMath { // 出现异常要交给被调用处出，使用throws public int div(int x,int y) throws Exception { System.out.println(“===== 计算开始 =====”) ; // 资源打开 int result = 0 ; try { result = x / y ; // 除法计算 } catch (Exception e) { throw e ; // 向上抛 } finally { System.out.println(“===== 计算结束 =====”) ; // 资源关闭 } return result ; } } public class TestDemo { public static void main(String args[]){ try { System.out.println(new MyMath().div(10,0)) ; } catch (Exception e) { e.printStackTrace() ; } } } 而对于以上的操作代码也可以按照如下的简化格式编写。 class MyMath { // 出现异常要交给被调用处出，使用throws public int div(int x,int y) throws Exception { System.out.println(“===== 计算开始 =====”) ; // 资源打开 int result = 0 ; try { result = x / y ; // 除法计算 } finally { System.out.println(“===== 计算结束 =====”) ; // 资源关闭 } return result ; } } public class TestDemo { public static void main(String args[]){ try { System.out.println(new MyMath().div(10,0)) ; } catch (Exception e) { e.printStackTrace() ; } } } 以上不带有catch的操作在开发之中并不建议使用。永远的标准格式：try…catch、finally、throws、throw一起使用。 3.7、RuntimeException（重点） 在讲解此操作之前，首先来观察如下的一段代码： public class TestDemo { public static void main(String args[]){ String str = “123” ; int num = Integer.parseInt(str) ; System.out.println(num * num) ; } } 这个程序就是将一个字符串变为了基本数据类型，而后执行乘法操作，但是下面来看一下parseInt()方法定义： public static int parseInt(String s) throws NumberFormatException 发现这个方法上抛出了一个NumberFormatException的异常，按照之前所讲，如果存在了throws，则必须使用try…catch进行处理，可是现在却没有强制要求处理，来观察一下NumberFormatException的继承结构： java.lang.Object |- java.lang.Throwable |- java.lang.Exception |- java.lang.RuntimeException |- java.lang.IllegalArgumentException |- java.lang.NumberFormatException 发现NumberFormatException属于RuntimeException的子类，而在Java之中明确规定了，对于RuntimeException的异常类型可以有选择性的来进行处理，在开发之中，如果没有处理，那么出现异常之后将交给JVM默认进行处理。 面试题：请解释一下RuntimeException和Exception的区别？请列举出几个常见的RuntimeException； · RuntimeException是Exception的子类； ·Exception定义了必须处理的异常，而RuntimeException定义的异常可以选择性的进行处理； ·常见的RuntimeException：NumberFormatException、ClassCastException、NullPointerException、ArithmeticException、ArrayIndexOutOfBoundsException。 3.8、断言：assert（了解） 断言指的是程序执行到某行之后，其结果一定是预期的结果，而在JDK1.4之后增加了一个assert关键字。 范例：使用断言 public class TestDemo { public static void main(String args[]){ int x = 10 ; // 假设经过了若干操作 assert x == 30 : “x的内容不是30” ; System.out.println(x) ; } } 默认情况下，Java之中的断言，不会在正常执行的代码中出现，如果要想启用断言，则应该增加一些选项： java -ea TestDemo 不过断言在开发之中几乎是不使用的技术，知道这个关键字就完了。 3.9、自定义异常类（了解） 在Java之中本身已经提供了大量的异常类型，但是在开发之中，这些异常类型根本就不能满足于开发的需要。所以在一些系统架构之中往往会提供一些新的异常类型，来表示一些特殊的错误，而这种操作就称为自定义异常类，而要想实现这种自定义异常类，那么可以让一个类继承Exception或RuntimeException。 范例：自定义异常类 class MyException extends Exception { // 自定义异常类 public MyException(String msg) { super(msg) ; } } public class TestDemo { public static void main(String args[]) throws Exception { throw new MyException(“自己的异常类”) ; } } 如果以后见到了一些特殊的没见过的异常类，基本上都表示自定义的。 4、总结 1、 异常的处理流程，出现错误之后的程序不执行； 2、 异常处理的标准结构：try、catch、finally、throw、throws的使用； 3、 RuntimeException和Exception的区别。","categories":[],"tags":[]},{"title":"","slug":"JDK多线程02","date":"2020-08-10T14:21:51.338Z","updated":"2020-08-10T14:15:48.180Z","comments":true,"path":"2020/08/10/jdk-duo-xian-cheng-02/","link":"","permalink":"https://kilitom.github.io/2020/08/10/jdk-duo-xian-cheng-02/","excerpt":"","text":"3、具体内容从多线程开始，Java正式进入到应用部分，而对于多线程的开发，从JavaEE上表现的并不是特别多，但是在Android开发之中使用较多，并且需要提醒的是，笔试或面试的过程之中，多线程所问到的问题是最多的。 3.1、多线程的基本概念如果要想解释多线程，那么首先应该从单进程开始讲起，最早的DOS系统有一个最大的特征：一旦电脑出现了病毒，电脑会立刻死机，因为传统DOS系统属于单进程的处理方式，即：在同一个时间段上只能有一个程序执行。后来到了windows时代，电脑即使（非致命）存在了病毒，那么也可以正常使用，只是慢一些而已，因为windows属于多进程的处理操作，但是这个时候的资源依然只有一块，所以在同一个时间段上会有多个程序共同执行，而在一个时间点上只能有一个程序在执行，多线程是在一个进程基础之上的进一步划分，因为进程的启动所消耗的时间是非常长的，所以在进程之上的进一步的划分就变得非常重要，而且性能也会有所提高。 所有的线程一定要依附于进程才能够存在，那么进程一旦消失了，线程也一定会消失，但是反过来不一定。而Java是为数不多的支持多线程的开发语言之一。 3.2、多线程的实现（重点）在Java之中，如果要想实现多线程的程序，那么就必须依靠一个线程的主体类（就好比主类的概念一样，表示的是一个线程的主类），但是这个线程的主体类在定义的时候也需要有一些特殊的要求，这个类可以继承Thread类或实现Runnable接口来完成定义。 3.2.1、继承Thread类实现多线程java.lang.Thread是一个负责线程操作的类，任何的类只需要继承了Thread类就可以成为一个线程的主类，但是既然是主类必须有它的使用方法，而线程启动的主方法是需要覆写Thread类中的run()方法才可以。 范例：定义一个线程的主体类 class MyThread extends Thread { // 线程的主体类 private String title; public MyThread(String title) { this.title = title; } @Override public void run() { // 线程的主方法 for (int x = 0; x &lt; 50; x++) { System.out.println(this.title + “运行，x = “ + x); } } } 现在按照道理来讲，已经出现了线程类，并且里面也存在了相应的操作方法，那么就应该产生对象并调用里面的方法，自然下面编写出了下的程序。 public class TestDemo { public static void main(String[] args) throws Exception { MyThread mt1 = new MyThread(“线程A”) ; MyThread mt2 = new MyThread(“线程B”) ; MyThread mt3 = new MyThread(“线程C”) ; mt1.run() ; mt2.run() ; mt3.run() ; } } 但是以上的操作实话而言并没有真正的启动多线程，因为多个线程彼此之间的执行一定是交替的方式运行，而此时是顺序执行，即：每一个对象的代码执行完之后才向下继续执行。如果要想在程序之中真正的启动多线程，必须依靠Thread类的一个方法：publicvoid start()，表示真正启动多线程，调用此方法后会间接调用run()方法。 public class TestDemo { public static void main(String[] args) throws Exception { MyThread mt1 = new MyThread(“线程A”) ; MyThread mt2 = new MyThread(“线程B”) ; MyThread mt3 = new MyThread(“线程C”) ; mt1.start() ; mt2.start() ; mt3.start() ; } } 此时可以发现，多个线程之间彼此交替执行，但是每次的执行结果肯定是不一样的。通过以上的代码就可以得出结论：要想启动线程必须依靠Thread类的start()方法执行，线程启动之后会默认调用了run()方法。 疑问？为什么线程启动的时候必须调用start()而不是直接调用run()？ 发现调用了start()之后，实际上它执行的还是覆写后的run()方法，那为什么不直接调用run()方法呢？那么为了解释此问题，下面打开Thread类的源代码，观察一下start()方法的定义。 public synchronized void start() { if (threadStatus != 0) throw new IllegalThreadStateException(); group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { } } } private native void start0(); 打开此方法的实现代码首先可以发现方法会抛出一个“IllegalThreadStateException”异常。按照之前所学习的方式来讲，如果一个方法之中使用了throw抛出一个异常对象，那么这个异常应该使用try…catch捕获，或者是方法的声明上使用throws抛出，但是这块都没有，因为这个异常类是属于运行时异常（RuntimeException）的子类。 java.lang.Object |- java.lang.Throwable |- java.lang.Exception |- java.lang.RuntimeException |- java.lang.IllegalArgumentException |- java.lang.IllegalThreadStateException 当一个线程对象被重复启动之后会抛出此异常，即：一个线程对象只能启动唯一的一次。在start()方法之中有一个最为关键的部分就是start0()方法，而且这个方法上使用了一个native关键字的定义。 native关键字指的是Java本地接口调用（Java NativeInterface），即：是使用Java调用本机操作系统的函数功能完成一些特殊的操作，而这样的代码开发在Java之中几乎很少出现，因为Java的最大特点是可移植性，如果一个程序只能在固定的操作系统上使用，那么可移植性就将彻底的丧失，所以，此操作一般只作为兴趣使用。 多线程的实现一定需要操作系统的支持，那么以上的start0()方法实际上就和抽象方法很类似没有方法体，而这个方法体交给JVM去实现，即：在windows下的JVM可能使用A方法实现了start0()，而在linux下的JVM可能使用了B方法实现了start0()，但是在调用的时候并不会去关心具体是何方式实现了start0()方法，只会关心最终的操作结果，交给JVM去匹配了不同的操作系统。 所以在多线程操作之中，使用start()方法启动多线程的操作是需要进行操作系统函数调用的。 3.2.2、实现Runnable接口实现多线程使用Thread类的确是可以方便的进行多线程的实现，但是这种方式最大的缺点就是单继承的问题，为此，在java之中也可以利用Runnable接口来实现多线程，而这个接口的定义如下： public interface Runnable { public void run(); } 分享：如何区分新老接口？ 在JDK之中，由于其发展的时间较长，那么会出现一些新的接口和老的接口，这两者有一个最大的明显特征：所有最早提供的接口方法里面都不加上public，所有的新接口里面都有public。 范例：通过Runnable接口实现多线程 class MyThread implements Runnable { // 线程的主体类 private String title; public MyThread(String title) { this.title = title; } @Override public void run() { // 线程的主方法 for (int x = 0; x &lt; 50; x++) { System.out.println(this.title + “运行，x = “ + x); } } } 这个时候和之前的继承Thread类区别不大，但是唯一的好处就是避免了单继承局限，不过现在问题也就来了。刚刚解释过，如果要想启动多线程依靠Thread类的start()方法完成，之前继承Thread类的时候可以将此方法直接继承过来使用，但现在实现的是Runable接口，没有这个方法可以继承了，为了解决这个问题，还是需要依靠Thread类完成，在Thread类中定义了一个构造方法：publicThread(Runnable target)，接收Runnable接口对象。 范例：利用Thread类启动多线程 public class TestDemo { public static void main(String[] args) throws Exception { MyThread mt1 = new MyThread(“线程A”); MyThread mt2 = new MyThread(“线程B”); MyThread mt3 = new MyThread(“线程C”); new Thread(mt1).start(); new Thread(mt2).start(); new Thread(mt3).start(); } } 这个时候就实现了多线程的启动，而且没有了单继承局限。 3.2.3、Thread类和Runnable接口实现多线程的区别（面试题）现在Thread类和Runnable接口都可以做为同一功能的方式来实现多线程，那么这两者如果从Java的实际开发而言，肯定使用Runnable接口，因为可以有效的避免单继承的局限，那么除了这些之外，这两种方式是否还有其他联系呢？ 为了解释这两种方式的联系，下面可以打开Thread类的定义： public class Thread extends Object implements Runnable 发现Thread类也是Runnable接口的子类，而如果真的是这样，那么之前程序的结构就变为了以下形式。 这个时候所表现出来的代码模式非常类似于代理设计模式，但是它并不是严格意义上代理设计模式，因为从严格来讲代理设计模式之中，代理主题所能够使用的方法依然是接口中定义的run()方法，而此处代理主题调用的是start()方法，所以只能够说形式上类似于代理设计模式，但本质上还是有差别的。 但是除了以上的联系之外，对于Runnable和Thread类还有一个不太好区分的区别：使用Runnable接口可以更加方便的表示出数据共享的概念。 范例：通过继承Thread类实现卖票程序 package cn.mldn.demo; class MyThread extends Thread { // 线程的主体类 private int ticket = 5; // 一共5张票 @Override public void run() { // 线程的主方法 for (int x = 0; x &lt; 50; x++) { **if** (**this**.ticket &gt; 0) { System.out.println(“卖票，ticket = “ + this.ticket –); } } } } public class TestDemo { public static void main(String[] args) throws Exception { MyThread mt1 = new MyThread(); MyThread mt2 = new MyThread(); MyThread mt3 = new MyThread(); mt1.start() ; mt2.start() ; mt3.start() ; } } 现在的结果是一共买出了15张票，等于是每一个线程对象各自卖各自的5张票，这个时候的内存关系图如下： 范例：利用Runnable来实现多线程 package cn.mldn.demo; class MyThread implements Runnable { // 线程的主体类 private int ticket = 5; // 一共5张票 @Override public void run() { // 线程的主方法 for (int x = 0; x &lt; 50; x++) { **if** (**this**.ticket &gt; 0) { System.out.println(“卖票，ticket = “ + this.ticket–); } } } } public class TestDemo { public static void main(String[] args) throws Exception { MyThread mt = new MyThread(); new Thread(mt).start(); new Thread(mt).start(); new Thread(mt).start(); } } 现在使用继承Thread类也可以实现同样的功能。 package cn.mldn.demo; class MyThread extends Thread { // 线程的主体类 private int ticket = 5; // 一共5张票 @Override public void run() { // 线程的主方法 for (int x = 0; x &lt; 50; x++) { **if** (**this**.ticket &gt; 0) { System.out.println(“卖票，ticket = “ + this.ticket–); } } } } public class TestDemo { public static void main(String[] args) throws Exception { MyThread mt = new MyThread(); new Thread(mt).start(); new Thread(mt).start(); new Thread(mt).start(); } } 面试题：请解释多线程的两种实现方式及区别？分别编写程序以验证两种实现方式。 ·多线程的两种实现方式都需要一个线程的主类，而这个类可以实现Runnable接口或继承Thread类，不管使用何种方式都必须在子类之中覆写run()方法，此方法为线程的主方法； ·Thread类是Runnable接口的子类，而且使用Runnable接口可以避免单继承局限，以及更加方便的实现数据共享的概念。 · 程序实现： Runnable接口： Thread类： class MyThread implements Runnable { @Override public void run() { // 线程的主方法 // 线程操作方法 } } class MyThread extends Thread { @Override public void run() { // 线程的主方法 // 线程操作方法 } } MyThread mt = new MyThread(); new Thread(mt).start(); MyThread mt = new MyThread(); mt.start(); 3.2.4、线程的操作状态（了解）每一个线程对象实际上都拥有属于自己的运行状态，那么下面分别说明线程的每种运行状态的特点： 1、 所有的线程对象都必须通过关键字new进行创建； 2、线程如果要进行启动则一定会调用Thread类的start()方法，但是代码可能会分先后顺序： new Thread(mt).start(); new Thread(mt).start(); new Thread(mt).start(); 以上是启动了三个线程，虽然在代码上有先后调用start()方法的顺序，可是对于JVM而言，都表示着所有的线程将同时进入到就绪状态，等待执行。 3、进入到就绪状态之后，将等待着CPU进行资源的抢占，抢占到了资源之后，线程会进如到运行状态，开始执行run()方法体之中所定义的代码，； 4、每一个线程执行run()方法到一定的时间的时候会让出CPU资源，进入到阻塞状态，而后重新回到就绪状态等待下次资源调度并继续执行run()方法中的代码； 5、如果全部方法执行完毕之后，将进入到线程的终止状态，并且不会再进入到就绪状态，直接结束。 3.3、线程的主要操作方法（理解）线程对象的也是可以进行若干种操作的，而且所有的线程操作方法都在Thread类中定义，如果要想学习完整的方法，可以参考本人的书《java开发实战经典》，但是下面只讲解核心的几个方法。 3.3.1、线程的命名和取得线程本身是属于不可见的运行状态的，即：每次操作的时候是无法预料的，所以如果要想在程序之中操作线程，唯一依靠的就是线程名称，而要想取得和设置线程的名称可以使用如下的方法： · 构造方法：public Thread(Runnable target, String name)； · 设置名字：public final void setName(String name)； · 取得名字：public final String getName()。 但是由于线程的状态不确定，所以每次可以操作的都是正在执行run()方法的线程，那么取得当前线程对象的方法：publicstatic Thread currentThread()。 范例：线程的命名和取得 package cn.mldn.demo; class MyThread implements Runnable { // 线程的主体类 @Override public void run() { // 线程的主方法 System.out.println(Thread.currentThread().getName()); } } public class TestDemo { public static void main(String[] args) throws Exception { MyThread mt = new MyThread(); new Thread(mt).start(); // Thread-0 new Thread(mt).start(); // Thread-1 new Thread(mt).start(); // Thread-2 new Thread(mt,”线程A”).start(); // 线程A new Thread(mt,”线程B”).start(); // 线程B } } 如果说现在为线程设置名字的话，那么会使用用户定义的名字，而如果没有设置线程名称，会自动的为其分配一个名称，这一点操作和之前讲解的static命名类似。 范例：观察如下代码 package cn.mldn.demo; class MyThread implements Runnable { // 线程的主体类 @Override public void run() { // 线程的主方法 System.out.println(Thread.currentThread().getName()); } } public class TestDemo { public static void main(String[] args) throws Exception { MyThread mt = new MyThread(); new Thread(mt, “线程”).start(); // 启动线程，并设置名字，线程 mt.run(); // 在主方法之中，直接调用类的run()方法，main } } 通过如上的程序可以发现，原来一个主方法也是一个线程，但是有一个问题出现了，现在一直是讲解了多线程，但是线程一定要依附于进程，进程在那里啊？ 每一次使用java命令执行一个类的时候就表示启动了一个JVM的进程，而主方法是这个进程上的一个线程而已。 问题：一个JVM进程启动的时候至少启动几个线程呢？ 两个线程：main、gc。 3.3.2、线程的休眠线程的休眠指的是让程序的执行速度变慢一些，方法：public static void sleep(longmillis) throws InterruptedException，设置的休眠单位是毫秒。 package cn.mldn.demo; class MyThread implements Runnable { // 线程的主体类 @Override public void run() { // 线程的主方法 for (int x = 0; x &lt; 100; x++) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + “，x = “ + x); } } } public class TestDemo { public static void main(String[] args) throws Exception { MyThread mt = new MyThread(); new Thread(mt, “线程A”).start(); new Thread(mt, “线程B”).start(); new Thread(mt, “线程C”).start(); new Thread(mt, “线程D”).start(); new Thread(mt, “线程E”).start(); } } 这个时候由于电脑的执行速度原因，所有的线程先后顺序并不容易发现，但是可以发现休眠了之后，程序运行速度变慢了。 3.3.3、线程的优先级从理论上讲，线程的优先级越高，越有可能先执行。如果要想操作线程的优先级有如下两个方法： · 设置线程的优先级：public final void setPriority(int newPriority)； · 取得线程的优先级：public final int getPriority()； 发现设置和取得优先级的时候都是利用了一个int型数据的操作，而这个int型数据有三种取值： · 最高优先级：public static final int MAX_PRIORITY，10； · 中等优先级：public static final int NORM_PRIORITY，5； · 最低优先级：public static final int MIN_PRIORITY，1； 范例：设置优先级 package cn.mldn.demo; class MyThread implements Runnable { // 线程的主体类 @Override public void run() { // 线程的主方法 for (int x = 0; x &lt; 10; x++) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + “，x = “ + x); } } } public class TestDemo { public static void main(String[] args) throws Exception { MyThread mt = new MyThread(); Thread t1 = new Thread(mt,”线程A”) ; Thread t2 = new Thread(mt,”线程B”) ; Thread t3 = new Thread(mt,”线程C”) ; t3.setPriority(Thread.MAX_PRIORITY) ; t1.setPriority(Thread.MIN_PRIORITY) ; t2.setPriority(Thread.MIN_PRIORITY) ; t1.start() ; t2.start() ; t3.start() ; } } 问题：主线程的优先级是什么呢？ public class TestDemo { public static void main(String[] args) throws Exception { System.out.println(Thread.currentThread().getPriority()); } } 发现主线程的优先级是5，是中等级别。 3.4、线程的同步与死锁（理解）3.4.1、同步问题所谓的同步问题指的是多个线程操作同一资源时所带来的信息的安全性问题，例如，下面模拟一个简单的卖票程序，要求有5个线程，卖6张票。 package cn.mldn.demo; class MyThread implements Runnable { // 线程的主体类 private int ticket = 6; @Override public void run() { // 线程的主方法 for (int x = 0; x &lt; 10; x++) { **if** (**this**.ticket &gt; 0) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + “卖票，ticket = “ + this.ticket–); } } } } public class TestDemo { public static void main(String[] args) throws Exception { MyThread mt = new MyThread(); new Thread(mt, “票贩子A”).start(); new Thread(mt, “票贩子B”).start(); new Thread(mt, “票贩子C”).start(); new Thread(mt, “票贩子D”).start(); new Thread(mt, “票贩子E”).start(); } } 这个时候发现操作的数据之中出现了负数，这个就可以理解为不同步问题。 如果说现在只剩下最后一张票了，一个线程判断条件满足，但是再它还没有修改票数之后，其他线程也同时通过了if判断，所以最终修改票数的时候就变成了负数。 如果现在要想增加这个锁，在程序之中就可以通过两种方式完成：一种是同步代码块，另外一种就是同步方法。 实现一：同步代码块，使用synchronized关键字定义的代码块就称为同步代码块，但是在进行同步的操作之中必须设置一个要同步的对象，而这个对象应该理解为当前对象：this。 package cn.mldn.demo; class MyThread implements Runnable { // 线程的主体类 private int ticket = 6; @Override public void run() { // 线程的主方法 for (int x = 0; x &lt; 10; x++) { **synchronized** (**this**) { // 同步代码块 **if** (**this**.ticket &gt; 0) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + “卖票，ticket = “ + this.ticket–); } } } } } public class TestDemo { public static void main(String[] args) throws Exception { MyThread mt = new MyThread(); new Thread(mt, “票贩子A”).start(); new Thread(mt, “票贩子B”).start(); new Thread(mt, “票贩子C”).start(); new Thread(mt, “票贩子D”).start(); new Thread(mt, “票贩子E”).start(); } } 方式二：同步方法 package cn.mldn.demo; class MyThread implements Runnable { // 线程的主体类 private int ticket = 6; @Override public void run() { // 线程的主方法 for (int x = 0; x &lt; 10; x++) { **this**.sale() ; } } **public synchronized void** sale() { **if** (**this**.ticket &gt; 0) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + “卖票，ticket = “ + this.ticket–); } } } public class TestDemo { public static void main(String[] args) throws Exception { MyThread mt = new MyThread(); new Thread(mt, “票贩子A”).start(); new Thread(mt, “票贩子B”).start(); new Thread(mt, “票贩子C”).start(); new Thread(mt, “票贩子D”).start(); new Thread(mt, “票贩子E”).start(); } } 但是在此处需要说明的一个问题：加入同步之后明显比不加入同步慢许多，所以同步的代码性能会很低，但是数据的安全性会高。 3.4.2、死锁同步就是指一个线程要等待另外一个线程执行完毕才会继续执行的一种操作形式，但是如果在一个操作之中都是在互相等着的话，那么就会出现死锁问题。 范例：下面简单的模拟一个死锁程序的样式 package cn.mldn.demo; class YuShi { public synchronized void say(FuXie f) { System.out.println(“玉史：给我30亿欧圆，放了你儿子。”); f.get() ; } public synchronized void get() { System.out.println(“玉史终于得到了赎金，放了儿子，为了下次继续绑架。”); } } class FuXie { public synchronized void say(YuShi y) { System.out.println(“付谢：放了我儿子，我给你30亿欧圆，不见人不给钱。”) ; y.get() ; } public synchronized void get() { System.out.println(“付谢救回了自己的儿子，于是开始哭那30亿。”); } } public class DeadLock implements Runnable { static YuShi ys = new YuShi() ; static FuXie fx = new FuXie() ; public static void main(String[] args) { new DeadLock() ; } public DeadLock() { new Thread(this).start() ; ys.say(fx) ; } @Override public void run() { fx.say(ys) ; } } 死锁是在日后多线程程序开发之中经常会遇见的问题，而以上的代码并没有任何的实际意义，大概可以理解死锁的操作形式就可以了，不用去研究程序。 面试题：请问多个线程操作同一资源的时候要考虑到那些，会带来那些问题？ 多个线程访问同一资源的时候一定要考虑到同步的问题，但是过多的同步会带来死锁。 3.5、线程间的经典操作案例（理解）在多线程的开发之中存在一种称为“生产者和消费者的程序”，这个程序的主要功能是生产者负责生产一些内容，每当生产完成之后，会由消费者取走全部内容，那么现在假设要生产的是如下两种数据： · 数据一：title = 2012.12.21日，content = 世界末日； · 数据二：title = 付谢，content = 打扫卫生迎接末日。 现在对于这样的程序，可以使用如下的一些基本模型实现。 package cn.mldn.demo; class Message { private String title ; private String content ; public void setTitle(String title) { this.title = title; } public void setContent(String content) { this.content = content; } public String getTitle() { return title; } public String getContent() { return content; } } class Productor implements Runnable { private Message msg = null ; public Productor(Message msg) { this.msg = msg ; } @Override public void run() { for (int x = 0; x &lt; 50; x++) { **if** (x % 2 == 0) { **this**.msg.setTitle(“2012.12.21”) ; **try** { Thread.*sleep*(100) ; } **catch** (InterruptedException e) { e.printStackTrace(); } **this**.msg.setContent(“世界末日”) ; } **else** { **this**.msg.setTitle(“付谢”) ; **try** { Thread.*sleep*(100) ; } **catch** (InterruptedException e) { e.printStackTrace(); } **this**.msg.setContent(“打扫卫生迎接末日”) ; } } } } **class** Customer **implements** Runnable { **private** Message msg = **null** ; **public** Customer(Message msg) { **this**.msg = msg ; } @Override **public void** run() { **for** (**int** x = 0; x &lt; 50; x++) { **try** { Thread.*sleep*(100) ; } **catch** (InterruptedException e) { e.printStackTrace(); } System.*out*.println(**this**.msg.getTitle() + “ –&gt; “ + this.msg.getContent()); } } } public class TestDemo { public static void main(String[] args) throws Exception { Message msg = new Message() ; new Thread(new Productor(msg)).start() ; new Thread(new Customer(msg)).start() ; } } 但是，以上的代码模型出现了如下的两严重问题： · 数据错位了； · 出现了重复取出和重复设置的问题。 3.5.1、解决数据错位问题：依靠同步就可以解决只要对设置和取得加上同步应用，就可以解决数据的错位的操作问题，下面，对代码进行修改。 package cn.mldn.demo; class Message { private String title ; private String content ; public synchronized void set(String title,String content) { this.title = title ; try { Thread.sleep(200) ; } catch (InterruptedException e) { e.printStackTrace(); } this.content = content ; } public synchronized void get() { try { Thread.sleep(100) ; } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(this.title + “ –&gt; “ + this.content); } } class Productor implements Runnable { private Message msg = null ; public Productor(Message msg) { this.msg = msg ; } @Override public void run() { for (int x = 0; x &lt; 50; x++) { if (x % 2 == 0) { this.msg.set(“2012.12.21”, “世界末日”); } else { this.msg.set(“付谢”, “打扫卫生迎接末日”); } } } } class Customer implements Runnable { private Message msg = null ; public Customer(Message msg) { this.msg = msg ; } @Override public void run() { for (int x = 0; x &lt; 50; x++) { this.msg.get() ; } } } public class TestDemo { public static void main(String[] args) throws Exception { Message msg = new Message() ; new Thread(new Productor(msg)).start() ; new Thread(new Customer(msg)).start() ; } } 这个时候的确解决了数据的错位的问题，但同时新的问题又来了：发现数据的重复问题更严重了。 3.5.2、解决数据的重复设置和重复取出要想解决重复的问题需要等待及唤醒机制，而这一机制的实现只能依靠Object类完成，在Object类之中定义了以下的三个方法完成线程的操作： · 等待：public final void wait() throws InterruptedException； · 唤醒第一个等待线程：public final void notify()； · 唤醒全部等待线程：public final void notifyAll()。 对于唤醒的两个操作：notify()是按照等待顺序进行了唤醒，而使用了notifyAll()则表示所有等待的线程都会被唤醒，那个线程的优先级高，那个线程就先执行。 范例：修改Message类，解决数据的重复设置和重复取出的操作 class Message { private String title ; private String content ; private boolean flag = true ; // flag == true：表示可以生产，但是不能取走 // flag == false：表示可以取走，但是不能生产 public synchronized void set(String title,String content) { if (this.flag == false) { // 已经生产过了，不能生产 try { super.wait() ; } catch (InterruptedException e) { e.printStackTrace(); } } this.title = title ; try { Thread.sleep(200) ; } catch (InterruptedException e) { e.printStackTrace(); } this.content = content ; this.flag = false ; super.notify() ; } public synchronized void get() { if (this.flag == true) { // 不能取走 try { super.wait() ; } catch (InterruptedException e) { e.printStackTrace(); } } try { Thread.sleep(100) ; } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(this.title + “ –&gt; “ + this.content); this.flag = true ; // 已经取走了，可以继续生产 super.notify() ; } } 面试题：请解释sleep()和wait()的区别？ · sleep()是Thread类定义的static方法，表示线程休眠，休眠到一定时间后自动唤醒； ·wait()是Object类定义的方法，表示线程等待，一直到执行了notify()或notifyAll()之后才结束等待。 4、总结1、 多线程的两种实现方式及区别； 2、 理解同步与死锁的概念； 3、 Object类对多线程支持的三个方法。 5、预习任务StringBuffer类、Date类、SimpleDateFormat、System、Runtime、Math、Random、BigInteger、BigDecimal、比较器、正则表达式。 6、学习问题解决1、 对象比较假设类都是同一个类。主方法及输出结果如下 public class Hello{ public static void main(String args[]){ Emp emp1 = new Emp(22,”李四”,”程序员”) ; Emp emp2 = new Emp(22,”李四”,”程序员”) ; if(emp1.equals(emp2)){ System.out.println(“不是同一个人”) ; }else{ System.out.println(“是同一个人”) ; } } public class Hello{ public static void main(String args[]){ Emp emp1 = new Emp(22,”李四”,”程序员”) ; Emp emp2 = new Emp(22,”李四”,”程序员”) ; if(emp1.equals(emp2)){ System.out.println(“不是同一个人”) ; }else{ System.out.println(“是同一个人”) ; } } 是同一个人 不是同一个人 不明白的是，既然是对象比较那么主方法中的两个输出语句位置应该无所谓先后。而且结果都是同一个人才对，那么所有的属性都是相同的情况下，为什么会出现两次输出结果不一样呢？ 2、 数据类型的转换是转型吗？ 对象多态性：向上转型和向下转型； 数据类型转换：String向基本型转换，或者是基本型向String转换，称为类型转换。 3、 public class Test{ public static void main(String args[]){ String str1 = “hello”; System.out.println(“fun()方法调用之前：”+str1); fun(str1); System.out.println(“fun()方法调用之后：”+str1); } public static void fun(String str){ str=”mldn”; } } 为什么输出的是 hello。 核心：如果看不懂图，把String基本数据类型那样，数值传递（就仿佛是数值拷贝一样）。 4、 关于 equals的问题： |–equals()用于字符串比较： String str1 = “Hello” ; String str2 = new String(“Hello”) ; System.out.println(str1.equals(str2)) ;—&gt;true； |–equals()用于对象比较： Person per1 = new Person(“张三”,20) ; Person per2 = new Person(“张三”,20) ; System.out.println(per1.equals(per2)) ; —&gt;false； 问题来了，String类既然也是继承自Object类，字符串比较之前也没有对Object的equals()进行覆写，怎么就相当于内容的比较了呢？？ String类覆写了Object类的equals()方法。 5、 匿名内部类不是很懂？ 匿名内部类根本就没用，2个月之后用，匿名内部类就是指一个接口或抽象类的子类只使用一次的情况下所采用的技术。 package cn.mldn.demo; public class TestDemo { public static void main(String[] args) throws Exception { new Thread(new Runnable() { @Override public void run() { for (int x = 0; x &lt; 10; x++) { System.out.println(Thread.currentThread().getName() + “，x = “ + x); } } }).start(); } } 复习：复习核心代码，并根据代码推导概念。 重点的概念认真复习，凡是明确给出日后再使用的技术，肯定到时候一用就会了。 之前也强调过了，自己编写的代码之中，现阶段是不去考虑内部类问题的。 7、测试题讲解1、 请写出String类对象两种实例化方式的区别？ 2、 请写出字符串比较的两种方式及区别？ 3、 编写一个程序，判断一个字符串是否全部由数字所组成；、 4、 〖SQL〗查询出公司每个工资等级的人数、平均工资、最高和最低工资； 5、 〖SQL〗显示出emp表的5~10行记录。","categories":[],"tags":[]},{"title":"","slug":"JDBC","date":"2020-08-10T14:21:51.338Z","updated":"2020-08-10T14:16:14.982Z","comments":true,"path":"2020/08/10/jdbc/","link":"","permalink":"https://kilitom.github.io/2020/08/10/jdbc/","excerpt":"","text":"3.1、JDBC的简介（理解） JDBC是Java数据库连接服务，主要是一个由Java程序操作数据库的执行标准，所以在这个JDBC的开发包java.sql包之中，所有的组成几乎都是接口，那么不同的数据库如果要想使用java开发，就必须实现这些接口的标准。不过JDBC不是技术，而是一种服务：所有的操作完全固定。 在JDBC之中的核心组成部分：DriverManager类、Connection接口、Statement接口、PreparedStatement接口、ResultSet接口，即：五个接口一个类，就构成了整个JDBC的组成。 但是如果要进行JDBC的开发，程序必须首先要连接到数据库，而在Java之中，对于程序连接数据库的操作，有以下的三种方式支持： · JDBC-ODBC：使用微软的ODBC技术进行数据库的连接； |- 流程：程序 JDBC ODBC 数据库，性能很差，数据的实时性特别差，没人用，这个操作由SUN自己提供，所有的JDBC技术都是最新版本； ·JDBC连接：由各个数据库生产商提供数据库驱动程序的实现，用户需要单独配置开发包（*.jar）； |- 流程：程序 JDBC 数据库，直接操作，性能高； ·JDBC网络连接：由程序根据网络协议连接到指定的数据库上，这个驱动程序依然由数据库生产商提供； 在以后的开发之中主要使用JDBC网络连接。 在Java之中，由于JDBC属于固定的服务，所以其代码的操作流程完全一样： · 第一步：加载数据库驱动程序； · 第二步：通过DriverManager类根据指定的属性内容连接数据库； · 第三步：进行数据表的CRUD操作，执行SQL； · 第四步：关闭数据库连接。 3.2、连接Oracle数据库（重点） 如果现在要使用Oracle进行连接，那么对于Oracle数据库就必须启动以下两个服务： · 监听服务：OracleOraDb 10g _home1TNSListener； · 数据库实例服务：OracleServiceMLDN。 如果监听服务有问题，那么程序根本就无法连接数据库。当这两个服务已经正常启动之后，下面就需要配置Oracle的驱动程序了。对于Oracle或DB2这样的大型数据库，一般都会在安装目录下存在了数据库的驱动程序开发包，Oracle的驱动程序路径：D:\\oracle\\product\\10.1.0 \\db_1\\jdbc\\lib\\classes12.jar。 对于这个jar包的配置需要分两种情况： 情况一：如果现在使用命令行方式开发（不用开发工具），则这个jar包要在CLASSPATH属性之中进行配置。 情况二：如果现在使用的是Eclipse进行开发，这个时候CLASSPATH是不起作用的，必须在项目属性之中配置指定库文件的开发包。 配置流程：项目点右键 属性 Java Build Path Add External Jars。 如果要想进行连接，那么首先需要知道如下的几个信息（背）： · 数据库的驱动程序路径（配置的*.jar）：oracle.jdbc.driver.OracleDriver； · 数据库的连接地址：jdbc:oracle:thin:@主机名称:端口号:数据库的实例名称； |- 要连接本机的mldn数据库：jdbc:oracle:thin:@localhost:1521:mldn； · 数据库的用户名：scott； · 数据库的密码：tiger。 不同的数据库以上的信息是不一样的，但是至少背一个，应付面试去。清楚了以上的操作之后，下面来逐步分析如何实现之前所说的JDBC的每一步操作： 第一步：加载数据库驱动程序； 数据库驱动程序给出的是“包.类”，只要看见写出了完整的类名称都应该想到反射，所以驱动程序的加载是通过Class类完成的：Class.forName(驱动程序)； 第二步：通过DriverManager类根据指定的属性内容连接数据库； java.sql.DriverManager是一个负责取得数据库连接接口（Connection）对象的操作类，在这个类之中定义了如下一个可以取得连接的方法：publicstatic Connection getConnection(String url, String user, String password)throws SQLException； 第四步：关闭数据库连接。 在Connection接口中定义了close()方法：public void close() throws SQLException。 范例：连接mldn数据库 package cn.mldn.demo; import java.sql.Connection; import java.sql.DriverManager; public class TestDemo { public static final String DBDRIVER = “oracle.jdbc.driver.OracleDriver”; public static final String DBURL = “jdbc:oracle:thin:@localhost:1521:mldn”; public static final String DBUSER = “scott”; public static final String PASSWORD = “tiger”; public static void main(String[] args) throws Exception { Connection conn = null; // 每一个Connection对象表示一个数据库连接 Class.forName(DBDRIVER); // 加载驱动程序 conn = DriverManager.getConnection(DBURL, DBUSER, PASSWORD); System.out.println(conn); // 如果可以输出对象则表示连接成功 conn.close() ; // 关闭连接 } } 对于日后不同的数据而言，除了驱动程序、连接地址、用户名和密码不同之外，其余的所有代码都一样。 JDBC的设计就属于一个工厂设计模式，其中的DriverManager类负责取得Connection接口的实例化对象。 在正常情况下以上的程序肯定是可以连接数据库，但是也会有一些个别份子由于自己电脑上经常安装一些不正当的软件会造成连接失败，主要的常见问题有二： 问题一：监听问题无法启动 那么这种情况下，如果要想解决此问题，首先要确定一下监听程序的路径是否正确。 现在已经配置的路径：D:\\oracle\\product\\ 10.1.0\\db_1\\BIN\\TNSLSNR，如果执行程序的路径正确，那么下面可以使用一个Oracle的工具通过命令行来控制监听启动：lsnrctl，现在就有可能是网络的配置环境出现了问题。 为了解决这个问题，现在进入到网络配置路径：D:\\oracle\\product\\ 10.1.0\\db_1\\NETWORK\\ADMIN路径下有两个文件：tnsnames.ora、listener.ora，如果这两个文件的网络配置出错，那么基本上监听服务就Over了。将网络名称修改为主机名称一样的数值。 问题二：缺少SID，从而导致无法连接 Exception in thread “main” java.sql.SQLException: Io 异常: The Network Adapter could not establish the connection 这个是因为有些电脑安装了Oracle之后，有可能安装过程之中出现了一些问题，导致SID没有配置成功。 这个时候，可以启动NetManager程序，通过这个程序注册一个与当前数据库实例名称相同的SID，保存后即可连接。 3.3、使用Statement操作数据库（重点） 如果现在要进行数据库的操作，那么一定需要数据表，所以首先编写一个如下的数据库创建脚本： DROP SEQUENCE myseq ; DROP TABLE member PURGE ; CREATE SEQUENCE myseq ; CREATE TABLE member( mid NUMBER , name VARCHAR2(20) NOT NULL , age NUMBER(3) , birthday DATE , note CLOB , CONSTRAINT pk_mid PRIMARY KEY (mid) , CONSTRAINT ck_age CHECK (age BETWEEN 0 AND 200) ) ; 如果要想执行数据表操作在Java之中可以使用Statement接口完成，但是如果要想取得Statement接口对象的话，必须依靠Connection接口完成，在Connection接口中定义了如下的一个操作方法： · 取得Statement接口对象：public Statement createStatement() throwsSQLException； 当取得了Statement接口对象之后就可以进行数据表的CRUD操作了，而操作的方法： · 执行数据更新操作：public int executeUpdate(String sql) throwsSQLException，返回更新的行数； · 执行数据查询操作：public ResultSet executeQuery(String sql) throwsSQLException； · 关闭操作：public void close() throws SQLException。 3.3.1、使用Statement接口进行数据表的更新操作 数据更新就是三种操作语法：增加、修改、删除。 范例：执行数据的增加操作 · 增加的SQL语法：INSERT INTO 表名称 (字段,字段,..) VALUES (值,值,…)； package cn.mldn.demo; import java.sql.Connection; import java.sql.DriverManager; import java.sql.Statement; public class TestDemo { public static final String DBDRIVER = “oracle.jdbc.driver.OracleDriver”; public static final String DBURL = “jdbc:oracle:thin:@localhost:1521:mldn”; public static final String DBUSER = “scott”; public static final String PASSWORD = “tiger”; public static void main(String[] args) throws Exception { Connection conn = null; // 每一个Connection对象表示一个数据库连接 Statement stmt = null; // 数据库操作对象 Class.forName(DBDRIVER); // 加载驱动程序 conn = DriverManager.getConnection(DBURL, DBUSER, PASSWORD); stmt = conn.createStatement(); // 找到Statement接口对象 String sql = “INSERT INTO member (mid,name,age,birthday,note) VALUES (myseq.nextval,’张三’,20,SYSDATE,’是世界末日的一个人’)”; int len = stmt.executeUpdate(sql); System.out.println(“更新行数：” + len); stmt.close(); // 关闭操作，如果不关闭操作，关闭连接也是一样的 conn.close(); // 关闭连接 } } 范例：执行修改操作 · 修改的SQL语法：UPDATE 表名称 SET 字段=值,字段=值,.. [WHERE 更新条件(s)]； package cn.mldn.demo; import java.sql.Connection; import java.sql.DriverManager; import java.sql.Statement; public class TestDemo { public static final String DBDRIVER = “oracle.jdbc.driver.OracleDriver”; public static final String DBURL = “jdbc:oracle:thin:@localhost:1521:mldn”; public static final String DBUSER = “scott”; public static final String PASSWORD = “tiger”; public static void main(String[] args) throws Exception { Connection conn = null; // 每一个Connection对象表示一个数据库连接 Statement stmt = null; // 数据库操作对象 Class.forName(DBDRIVER); // 加载驱动程序 conn = DriverManager.getConnection(DBURL, DBUSER, PASSWORD); stmt = conn.createStatement(); // 找到Statement接口对象 String sql = “UPDATE member SET name=’李四’,age=19,note=’扫除达人’ WHERE mid BETWEEN 10 AND 20”; int len = stmt.executeUpdate(sql); System.out.println(“更新行数：” + len); stmt.close(); // 关闭操作，如果不关闭操作，关闭连接也是一样的 conn.close(); // 关闭连接 } } 范例：执行删除操作 · 删除的SQL语法：DELETE FROM 表名称 WHERE 删除条件 ; package cn.mldn.demo; import java.sql.Connection; import java.sql.DriverManager; import java.sql.Statement; public class TestDemo { public static final String DBDRIVER = “oracle.jdbc.driver.OracleDriver”; public static final String DBURL = “jdbc:oracle:thin:@localhost:1521:mldn”; public static final String DBUSER = “scott”; public static final String PASSWORD = “tiger”; public static void main(String[] args) throws Exception { Connection conn = null; // 每一个Connection对象表示一个数据库连接 Statement stmt = null; // 数据库操作对象 Class.forName(DBDRIVER); // 加载驱动程序 conn = DriverManager.getConnection(DBURL, DBUSER, PASSWORD); stmt = conn.createStatement(); // 找到Statement接口对象 String sql = “DELETE FROM member WHERE mid IN (1,11,21)”; int len = stmt.executeUpdate(sql); System.out.println(“更新行数：” + len); stmt.close(); // 关闭操作，如果不关闭操作，关闭连接也是一样的 conn.close(); // 关闭连接 } } 在数据的更新操作之中，如果已经成功的执行了数据的更新，一定会返回更新的行数的。 3.3.2、使用Statement接口进行查询 更新操作会返回给用户更新的行数，那么查询更应该返回数据给用户浏览，所以在整个进行查询的操作之中，就必须有一种结构，可以装下整个的查询结果，而这个结构就使用ResultSet表示。 当所有的记录返回到ResultSet的时候，所有的内容都是按照数据类型存放的，所以用户只需要按照数据类型一行行的取出数据即可，在ResultSet接口之中定义了这样的几个方法： · 移动指针并判断是否有数据：public boolean next() throws SQLException； · 取得指定类型的数据：public 数据 getXxx(列的标记) throws SQLException · 关闭：public void close() throws SQLException。 范例：使用ResultSet取出数据 package cn.mldn.demo; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; import java.util.Date; public class TestDemo { public static final String DBDRIVER = “oracle.jdbc.driver.OracleDriver”; public static final String DBURL = “jdbc:oracle:thin:@localhost:1521:mldn”; public static final String DBUSER = “scott”; public static final String PASSWORD = “tiger”; public static void main(String[] args) throws Exception { Connection conn = null; // 每一个Connection对象表示一个数据库连接 Statement stmt = null; // 数据库操作对象 Class.forName(DBDRIVER); // 加载驱动程序 conn = DriverManager.getConnection(DBURL, DBUSER, PASSWORD); stmt = conn.createStatement(); // 找到Statement接口对象 String sql = “SELECT mid,name,age,birthday,note FROM member”; ResultSet rs = stmt.executeQuery(sql) ; // 查询 while (rs.next()) { int mid = rs.getInt(“mid”) ; String name = rs.getString(“name”) ; int age = rs.getInt(“age”) ; Date birthday = rs.getDate(“birthday”) ; String note = rs.getString(“note”) ; System.out.println(mid + “，” + name + “，” + age + “，” + birthday + “，” + note); } rs.close() ; stmt.close(); // 关闭操作，如果不关闭操作，关闭连接也是一样的 conn.close(); // 关闭连接 } } 从今天开始，所有的SQL语句的查询之中不允许再出现“SELECT*…”，必须明确的写出要显示字段名称。但是，在编写SQL语句的时候，既然已经明确的知道了要显示列的顺序，所以也可以采用序号的形式在ResultSet中使用。 while (rs.next()) { int mid = rs.getInt(1) ; String name = rs.getString(2) ; int age = rs.getInt(3) ; Date birthday = rs.getDate(4) ; String note = rs.getString(5) ; System.out.println(mid + “，” + name + “，” + age + “，” + birthday + “，” + note); } 这种方式更加的简单，所以以后都采用此方式完成。 3.4、预处理：PreparedStatement（核心） 之前所讲解的Statement基本上不用，即：可以不会，下面首先来解释一下之所以不去使用Statement操作的原因，假设：现在要增加的数据为用户自己输入的。 package cn.mldn.demo; import java.sql.Connection; import java.sql.DriverManager; import java.sql.Statement; public class TestDemo { public static final String DBDRIVER = “oracle.jdbc.driver.OracleDriver”; public static final String DBURL = “jdbc:oracle:thin:@localhost:1521:mldn”; public static final String DBUSER = “scott”; public static final String PASSWORD = “tiger”; public static void main(String[] args) throws Exception { String name = “Mr’Smith” ; String birthday = “ 1989-01-02 “ ; int age = 30 ; String note = “终于来了个人” ; Connection conn = null; // 每一个Connection对象表示一个数据库连接 Statement stmt = null; // 数据库操作对象 Class.forName(DBDRIVER); // 加载驱动程序 conn = DriverManager.getConnection(DBURL, DBUSER, PASSWORD); stmt = conn.createStatement(); // 找到Statement接口对象 String sql = “INSERT INTO member (mid,name,age,birthday,note) VALUES (myseq.nextval,’” + name + “‘,” + age + “,TO_DATE(‘“ + birthday + “‘,’yyyy-mm-dd’),’” + note + “‘)”; System.out.println(sql); int len = stmt.executeUpdate(sql); System.out.println(“更新行数：” + len); stmt.close(); // 关闭操作，如果不关闭操作，关闭连接也是一样的 conn.close(); // 关闭连接 } } 本程序一执行之后，会出现如下的错误提示信息： INSERT INTO member (mid,name,age,birthday,note) VALUES (myseq.nextval,’Mr’Smith‘,30,TO_DATE(‘ 1989-01-02 ‘,’yyyy-mm-dd’),’终于来了个人’) Exception in thread “main” java.sql.SQLException: ORA-00917: missing comma 在日后的所有开发之中，如果出现了SQLException不用去检查代码，就检查SQL语句是不是有问题，在SQL语句之中所有的字符串要求使用“’”定义，但是现在名字上有了“’”，那么自然SQL语句就出现了错误，所以导致程序无法进行数据的保存。所以通过这一代码就可以发现，在开发之中，这种拼凑SQL语句的形式根本就不可能被使用，即：Statement不应该被使用，所有的开发都会使用Statement的子接口：PreparedStatement完成。 PreparedStatement采用的是一种预处理的方式来进行程序编写的，所谓的预处理指的是先在数据库之中执行好要操作的SQL语句，但是其对应的内容暂时不插入，通过程序再依次设置。 如果要想取得PreparedStatement接口的对象依然需要通过Connection接口完成，在Connection接口定义的方法： · 取得PreparedStatement接口对象：public PreparedStatementprepareStatement(String sql) throws SQLException 当取得了PreparedStatement接口对象之后，就可以通过PreparedStatement定义的方法进行数据库操作： · 更新操作：public int executeUpdate() throws SQLException； · 查询操作：public ResultSet executeQuery() throws SQLException。 如果现在要为操作的SQL设置内容，使用的方法： · 根据索引设置各种类型：public void setBigDecimal(int parameterIndex, 数据类型x) throws SQLException 在使用PreparedStatement接口中的setDate()方法的时候，其对应的类型是java.sql.Date，而不是平常使用的java.util.Date，那么就必须执行转换，在java.sql.Date类中有一个构造：publicDate(long date)。 范例：通过PreparedStatement执行增加操作 package cn.mldn.demo; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.util.Date; public class TestDemo { public static final String DBDRIVER = “oracle.jdbc.driver.OracleDriver”; public static final String DBURL = “jdbc:oracle:thin:@localhost:1521:mldn”; public static final String DBUSER = “scott”; public static final String PASSWORD = “tiger”; public static void main(String[] args) throws Exception { String name = “Mr’Smith” ; Date birthday = new Date() ; // 表示的是日期 int age = 30 ; String note = “终于来了个人” ; String sql = “INSERT INTO member (mid,name,age,birthday,note) VALUES (myseq.nextval,?,?,?,?)”; Connection conn = null; // 每一个Connection对象表示一个数据库连接 PreparedStatement pstmt = null; // 数据库操作对象 Class.forName(DBDRIVER); // 加载驱动程序 conn = DriverManager.getConnection(DBURL, DBUSER, PASSWORD); pstmt = conn.prepareStatement(sql) ; // 执行了SQL pstmt.setString(1, name) ; pstmt.setInt(2,age) ; pstmt.setDate(3,new java.sql.Date(birthday.getTime())) ; pstmt.setString(4, note) ; int len = pstmt.executeUpdate() ; // 执行更新操作 System.out.println(“更新行数：” + len); pstmt.close(); // 关闭操作，如果不关闭操作，关闭连接也是一样的 conn.close(); // 关闭连接 } } 正因为PreparedStatement使用起来要比Statement方便，所以在日后的开发之中，全部都使用PreparedStatement，而不要使用Statement接口操作。 更新的操作都和增加操作类似，而最麻烦的就在于数据的查询操作，下面编写几个程序，这几个程序是必须会的操作，直接和后续的代码开发有联系。 范例：查询全部操作 package cn.mldn.demo; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.util.Date; public class TestDemo { public static final String DBDRIVER = “oracle.jdbc.driver.OracleDriver”; public static final String DBURL = “jdbc:oracle:thin:@localhost:1521:mldn”; public static final String DBUSER = “scott”; public static final String PASSWORD = “tiger”; public static void main(String[] args) throws Exception { String sql = “SELECT mid,name,age,birthday,note FROM member”; Connection conn = null; // 每一个Connection对象表示一个数据库连接 PreparedStatement pstmt = null; // 数据库操作对象 Class.forName(DBDRIVER); // 加载驱动程序 conn = DriverManager.getConnection(DBURL, DBUSER, PASSWORD); pstmt = conn.prepareStatement(sql) ; // 执行了SQL ResultSet rs = pstmt.executeQuery() ; // 查询操作 while (rs.next()) { int mid = rs.getInt(1) ; String name = rs.getString(2) ; int age = rs.getInt(3) ; Date birthday = rs.getDate(4) ; String note = rs.getString(5) ; System.out.println(mid + “，” + name + “，” + age + “，” + birthday + “，” + note); } pstmt.close(); // 关闭操作，如果不关闭操作，关闭连接也是一样的 conn.close(); // 关闭连接 } } 范例：设置按id查询，如果按照id查询只会返回一条数据，要么就不返回。 package cn.mldn.demo; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.util.Date; public class TestDemo { public static final String DBDRIVER = “oracle.jdbc.driver.OracleDriver”; public static final String DBURL = “jdbc:oracle:thin:@localhost:1521:mldn”; public static final String DBUSER = “scott”; public static final String PASSWORD = “tiger”; public static void main(String[] args) throws Exception { String sql = “SELECT mid,name,age,birthday,note FROM member WHERE mid=?”; Connection conn = null; // 每一个Connection对象表示一个数据库连接 PreparedStatement pstmt = null; // 数据库操作对象 Class.forName(DBDRIVER); // 加载驱动程序 conn = DriverManager.getConnection(DBURL, DBUSER, PASSWORD); pstmt = conn.prepareStatement(sql) ; // 执行了SQL pstmt.setInt(1, 300) ; // 在执行之前设置内容 ResultSet rs = pstmt.executeQuery() ; // 查询操作 if (rs.next()) { // 查询出来就显示 int mid = rs.getInt(1) ; String name = rs.getString(2) ; int age = rs.getInt(3) ; Date birthday = rs.getDate(4) ; String note = rs.getString(5) ; System.out.println(mid + “，” + name + “，” + age + “，” + birthday + “，” + note); } else { System.out.println(“没有查询结果！”); } pstmt.close(); // 关闭操作，如果不关闭操作，关闭连接也是一样的 conn.close(); // 关闭连接 } } 在使用ResultSet接口操作的时候，如果有内容则next()才可以执行，如果没有查询结果，next()直接返回false。 范例：设置模糊查询 package cn.mldn.demo; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.util.Date; public class TestDemo { public static final String DBDRIVER = “oracle.jdbc.driver.OracleDriver”; public static final String DBURL = “jdbc:oracle:thin:@localhost:1521:mldn”; public static final String DBUSER = “scott”; public static final String PASSWORD = “tiger”; public static void main(String[] args) throws Exception { String column = “name” ; String keyWord = “三” ; String sql = “SELECT mid,name,age,birthday,note FROM member WHERE “ + column + “ LIKE ?”; Connection conn = null; // 每一个Connection对象表示一个数据库连接 PreparedStatement pstmt = null; // 数据库操作对象 Class.forName(DBDRIVER); // 加载驱动程序 conn = DriverManager.getConnection(DBURL, DBUSER, PASSWORD); pstmt = conn.prepareStatement(sql) ; // 执行了SQL pstmt.setString(1, “%” + keyWord + “%”); // 在执行之前设置内容 ResultSet rs = pstmt.executeQuery() ; // 查询操作 while (rs.next()) { // 查询出来就显示 int mid = rs.getInt(1) ; String name = rs.getString(2) ; int age = rs.getInt(3) ; Date birthday = rs.getDate(4) ; String note = rs.getString(5) ; System.out.println(mid + “，” + name + “，” + age + “，” + birthday + “，” + note); } pstmt.close(); // 关闭操作，如果不关闭操作，关闭连接也是一样的 conn.close(); // 关闭连接 } } 范例：分页显示，Oracle使用ROWNUM完成 package cn.mldn.demo; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.util.Date; public class TestDemo { public static final String DBDRIVER = “oracle.jdbc.driver.OracleDriver”; public static final String DBURL = “jdbc:oracle:thin:@localhost:1521:mldn”; public static final String DBUSER = “scott”; public static final String PASSWORD = “tiger”; public static void main(String[] args) throws Exception { String column = “name” ; String keyWord = “三” ; int currentPage = 2 ; // 当前所在页 int lineSize = 5 ; // 每页显示的长度 String sql = “ SELECT * FROM ( “ + “ SELECT mid,name,age,birthday,note,ROWNUM rn FROM member WHERE “ + column + “ LIKE ? AND ROWNUM&lt;=?) temp “ + “ WHERE temp.rn&gt;? “; Connection conn = null; // 每一个Connection对象表示一个数据库连接 PreparedStatement pstmt = null; // 数据库操作对象 Class.forName(DBDRIVER); // 加载驱动程序 conn = DriverManager.getConnection(DBURL, DBUSER, PASSWORD); pstmt = conn.prepareStatement(sql) ; // 执行了SQL pstmt.setString(1, “%” + keyWord + “%”); // 在执行之前设置内容 pstmt.setInt(2, currentPage * lineSize) ; pstmt.setInt(3, (currentPage - 1) * lineSize); ResultSet rs = pstmt.executeQuery() ; // 查询操作 while (rs.next()) { // 查询出来就显示 int mid = rs.getInt(1) ; String name = rs.getString(2) ; int age = rs.getInt(3) ; Date birthday = rs.getDate(4) ; String note = rs.getString(5) ; System.out.println(mid + “，” + name + “，” + age + “，” + birthday + “，” + note); } pstmt.close(); // 关闭操作，如果不关闭操作，关闭连接也是一样的 conn.close(); // 关闭连接 } } 如果这个时候设置的关键字为空字符串（String keyWord = “”;）的话呢，则表示查询全部。 范例：统计查询，统计数据量，统计函数使用COUNT()完成。 package cn.mldn.demo; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; public class TestDemo { public static final String DBDRIVER = “oracle.jdbc.driver.OracleDriver”; public static final String DBURL = “jdbc:oracle:thin:@localhost:1521:mldn”; public static final String DBUSER = “scott”; public static final String PASSWORD = “tiger”; public static void main(String[] args) throws Exception { String column = “name” ; String keyWord = “” ; String sql = “ SELECT COUNT(mid) FROM member WHERE “ + column + “ LIKE ? “; Connection conn = null; // 每一个Connection对象表示一个数据库连接 PreparedStatement pstmt = null; // 数据库操作对象 Class.forName(DBDRIVER); // 加载驱动程序 conn = DriverManager.getConnection(DBURL, DBUSER, PASSWORD); pstmt = conn.prepareStatement(sql) ; // 执行了SQL pstmt.setString(1, “%” + keyWord + “%”); // 在执行之前设置内容 ResultSet rs = pstmt.executeQuery() ; // 查询操作 if (rs.next()) { // 一定会有内容返回 int count = rs.getInt(1) ; System.out.println(count); } pstmt.close(); // 关闭操作，如果不关闭操作，关闭连接也是一样的 conn.close(); // 关闭连接 } } 以上的几种就是JDBC在实际开发之中的基本操作，也是必须掌握的操作。 3.5、批处理及事务处理（理解） 以上的一些代码是属于JDBC1.0的时候就推出的功能，但是这些功能被新版本在一些bug进行了纠正。而最新的JDBC版本为4.0（没人使），因为从JDBC2.0之后增加了一些新功能：可滚动结果集、使用ResultSet更新数据、批处理，这之中批处理操作是唯一有点用的技术：所谓的批处理指的是数据库可以一次性的执行多条SQL语句。所以在JDBC2.0之后，对于Statement和PreparedStatement接口都有了一些新的方法： · Statement接口增加了两个方法： |- 增加一个执行的SQL：public void addBatch(String sql) throwsSQLException，没有执行； |- 一次性执行多条SQL：public int[] executeBatch() throws SQLException； · PreparedStatement接口增加了一个方法： |- 增加执行的SQL：public void addBatch() throws SQLException。 范例：为了方便起见，使用Statement执行一次批处理 package cn.mldn.demo; import java.sql.Connection; import java.sql.DriverManager; import java.sql.Statement; import java.util.Arrays; public class TestDemo { public static final String DBDRIVER = “oracle.jdbc.driver.OracleDriver”; public static final String DBURL = “jdbc:oracle:thin:@localhost:1521:mldn”; public static final String DBUSER = “scott”; public static final String PASSWORD = “tiger”; public static void main(String[] args) throws Exception { Connection conn = null; // 每一个Connection对象表示一个数据库连接 Statement stmt = null ; Class.forName(DBDRIVER); // 加载驱动程序 conn = DriverManager.getConnection(DBURL, DBUSER, PASSWORD); stmt = conn.createStatement() ; stmt.addBatch(“INSERT INTO member(mid,name) VALUES (myseq.nextval,’张三A’)”) ; stmt.addBatch(“INSERT INTO member(mid,name) VALUES (myseq.nextval,’张三B’)”) ; stmt.addBatch(“INSERT INTO member(mid,name) VALUES (myseq.nextval,’张三C’)”) ; stmt.addBatch(“INSERT INTO member(mid,name) VALUES (myseq.nextval,’张三D’)”) ; stmt.addBatch(“INSERT INTO member(mid,name) VALUES (myseq.nextval,’张三E’)”) ; int data [] = stmt.executeBatch() ; // 执行批处理 System.out.println(Arrays.toString(data)); conn.close(); // 关闭连接 } } 但是在这里面有一个小问题了，如果假设以上的五条更新SQL都属于同一个业务： · A、从罗先生帐户上转出5000W； · B、在我的帐户上增加5000W； 本步出错了 · C、交付转帐手续费50； · D、交付个人所得税：10。 在JDBC下，所有的事务处理都是自动提交的，这就意味着只要执行了SQL语句，那么都会自动的提交数据库的事务，而如果要想解决之前的问题，就必须手工处理事务，所有的事务处理操作命令都在Connection接口之中定义了，有如下的三个支持事务操作的方法： · 设置事务是否自动提交：public void setAutoCommit(boolean autoCommit) throwsSQLException； · 提交事务：public void commit() throws SQLException； · 回滚事务：public void rollback() throws SQLException。 范例：手工控制事务 package cn.mldn.demo; import java.sql.Connection; import java.sql.DriverManager; import java.sql.Statement; import java.util.Arrays; public class TestDemo { public static final String DBDRIVER = “oracle.jdbc.driver.OracleDriver”; public static final String DBURL = “jdbc:oracle:thin:@localhost:1521:mldn”; public static final String DBUSER = “scott”; public static final String PASSWORD = “tiger”; public static void main(String[] args) throws Exception { Connection conn = null; // 每一个Connection对象表示一个数据库连接 Statement stmt = null ; Class.forName(DBDRIVER); // 加载驱动程序 conn = DriverManager.getConnection(DBURL, DBUSER, PASSWORD); conn.setAutoCommit(false) ; // 取消自动提交 stmt = conn.createStatement() ; try { stmt.addBatch(“INSERT INTO member(mid,name) VALUES (myseq.nextval,’张三A’)”) ; stmt.addBatch(“INSERT INTO member(mid,name) VALUES (myseq.nextval,’张三B’)”) ; stmt.addBatch(“INSERT INTO member(mid,name) VALUES (myseq.nextval,’张三’C’)”) ; stmt.addBatch(“INSERT INTO member(mid,name) VALUES (myseq.nextval,’张三D’)”) ; stmt.addBatch(“INSERT INTO member(mid,name) VALUES (myseq.nextval,’张三E’)”) ; int data [] = stmt.executeBatch() ; // 执行批处理 System.out.println(Arrays.toString(data)); conn.commit() ; // 不出错提交 } catch (Exception e) { e.printStackTrace() ; conn.rollback() ;// 回滚事务 } conn.close(); // 关闭连接 } } 但是这些手工的事务处理，日后实际上也不需要用户自己完成，因为有容器帮助。 4、总结 1、 JDBC连接Oracle数据库； 2、 PreparedStatement接口实现数据的更新和查询操作。 5、作业 1、 巩固一下Java的基本概念，尤其是面向对象； 2、 代码： · 简单Java类和数据表映射； · 动物园程序，换成List接口； · 各个设计模式的组成：单例、工厂、代理； · 异常处理的标准格式； · 日期、基本类型、String的互相转换； · 正则表达式； · 文件拷贝、打印流、扫描流； · JDBC的PreparedStatement操作。","categories":[],"tags":[]},{"title":"","slug":"类集框架","date":"2020-08-10T14:21:51.338Z","updated":"2020-08-10T14:15:09.618Z","comments":true,"path":"2020/08/10/lei-ji-kuang-jia/","link":"","permalink":"https://kilitom.github.io/2020/08/10/lei-ji-kuang-jia/","excerpt":"","text":"3.1、认识类集（理解） 如果现在要想保存多个对象，肯定使用对象数组完成，但是对象数组本身有一个最大的问题在于其数据的长度，所以后来使用了链表完成了动态对象数组的开发，可是链表的开发难度实在是很大，而且如果一个链表要想真正去使用，只依靠之前所编写的还不够，还需要进行一些代码的调优。 而在JDK1.2之后正式引入了类集的概念，类集是一种动态的对象数组，属于各个数据结构的实现类，在整个类集之中主要的组成是一些核心的操作接口：Collection、List、Set、Map、Iterator、Enumeration。 3.2、单值保存的最大父接口：Collection（重点） 所谓的单值保存指的是每一次操作只会保存一个对象，就好像之前的链表程序一样，每一次只保存了一个对象，在Collection接口之中定义了如下的一些操作方法。 No. 方法名称 类型 描述 1 public boolean add(E e) 普通 数据增加 2 public void clear() 普通 清除数据 3 public boolean contains(Object o) 普通 查找数据是否存在 4 public boolean isEmpty() 普通 判断是否为空集合 5 public Iterator&lt;E&gt; iterator() 普通 为Iterator接口实例化 6 public boolean remove(Object o) 普通 删除数据 7 public int size() 普通 取得集合的个数 8 public Object[] toArray() 普通 将集合变为对象数组 在Collection接口之中一共定义了15个方法，在所有的方法之中，只有两个方法最为常用：add()、iterator()。不过从开发上讲，很少会去直接使用Collection，都会使用Collection的两个子接口：List、Set。 3.3、允许重复的子接口：List（重点，80%） List是Collection的一个最为常用的子接口，首先这个接口的定义如下： public interface List&lt;E&gt; extends Collection&lt;E&gt; 但是List接口对Collection接口进行了大量的扩充，但是扩充之后的主要方法： No. 方法名称 类型 描述 1 public E get(int index) 普通 取得指定索引位置上的数据 2 public E set(int index, E element) 普通 修改指定索引位置上的数据 3 public ListIterator&lt;E&gt; listIterator() 普通 为ListIterator接口实例化 但是以上的三个方法，只是针对于List接口起作用，而List接口有两个常用子类：ArrayList、Vector。 3.3.1、新的子类：ArrayList，95% ArrayList是List子接口使用最多的一个子类，而这个类的定义如下： public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable 按照面向对象的概念来讲，现在使用ArrayList主要的目的是为List接口实例化，所有的操作方法都以List接口为主。 范例：使用ArrayList进行List接口的功能验证 package cn.mldn.demo; import java.util.ArrayList; import java.util.List; public class TestDemo { public static void main(String[] args) throws Exception { List&lt;String&gt; all = new ArrayList&lt;String&gt;() ; all.add(“Hello”) ; all.add(“Hello”) ; // 内容重复了 all.add(“World”) ; for (int x = 0; x &lt; all.size(); x++) { String str = all.get(x) ; // get()方法只有List接口有 System.out.print(str + “、”); } } } 在使用代码的时候可以发现，List集合之中即使存在了重复数据，也可以正常的保存，而且数据保存的顺序就是存入数据的顺序。 范例：使用List集合修改之前的程序 package cn.mldn.demo; import java.util.ArrayList; import java.util.List; interface Animal { // 动物 public String getName() ; public int getAge() ; } class Zoo { private List&lt;Animal&gt; animals = new ArrayList&lt;Animal&gt;() ; // 多个动物 public void add(Animal ani) { // 增加动物 this.animals.add(ani) ; // 增加动物 } public void delete(Animal ani) { this.animals.remove(ani) ; // 需要equals() } public List&lt;Animal&gt; search(String keyWord) { List&lt;Animal&gt; result = new ArrayList&lt;Animal&gt;() ; for (int x = 0 ; x &lt; **this**.animals.size() ; x ++) { Animal ani = **this**.animals.get(x) ; **if** (ani.getName().contains(keyWord)) { // 满足 result.add(ani) ; } } **return** result ; } } **class** Dog **implements** Animal { **private** String name ; **private int** age ; **public** Dog(String name,**int** age) { **this**.name = name ; **this**.age = age ; } **public** String getName() { **return this**.name ; } **public int** getAge() { **return this**.age ; } **public boolean** equals(Object obj) { **if** (**this** == obj) { **return true** ; } **if** (obj == **null**) { **return false** ; } **if** (!(obj **instanceof** Dog)) { **return false** ; } Dog dog = (Dog) obj ; **if** (**this**.name.equals(dog.name) &amp;&amp; **this**.age == dog.age) { **return true** ; } **return false** ; } **public** String toString() { **return** “〖狗的信息〗名字：” + **this**.name + “，年龄：” + **this**.age ; } } **class** Tiger **implements** Animal { **private** String name ; **private int** age ; **public** Tiger(String name,**int** age) { **this**.name = name ; **this**.age = age ; } **public** String getName() { **return this**.name ; } **public int** getAge() { **return this**.age ; } **public boolean** equals(Object obj) { **if** (**this** == obj) { **return true** ; } **if** (obj == **null**) { **return false** ; } **if** (!(obj **instanceof** Tiger)) { **return false** ; } Tiger t = (Tiger) obj ; **if** (**this**.name.equals(t.name) &amp;&amp; **this**.age == t.age) { **return true** ; } **return false** ; } **public** String toString() { **return** “〖老虎的信息〗名字：” + **this**.name + “，年龄：” + **this**.age ; } } **public class** TestDemo { **public static void** main(String args[]) { Zoo zoo = **new** Zoo() ; // 动物园 zoo.add(**new** Dog(“花狗”,1)) ; zoo.add(**new** Dog(“黄狗”,1)) ; zoo.add(**new** Dog(“黑狗”,1)) ; zoo.add(**new** Dog(“斑点狗”,1)) ; zoo.add(**new** Tiger(“斑点虎”,2)) ; zoo.add(**new** Tiger(“黑虎”,2)) ; zoo.add(**new** Tiger(“花虎”,2)) ; zoo.delete(**new** Dog(“斑点狗”,1)) ; // 删除 List&lt;Animal&gt; result = zoo.search(“斑点”) ; for (int x = 0 ; x &lt; result.size() ; x ++) { System.out.println(result.get(x)) ; } } } 至少此时的程序不再需要自己去开发链表了，所有的链表的实现类都有了。 3.3.2、旧的子类：Vector，5% Vector类是在JDK1.0的时候就推出的一个最早的实现动态数组的操作类，实际上对于今天而言，有许多的类上依然还是在使用着Vector，不过从实际的开发来讲，现在设计的一些程序都是针对于接口的操作了。 package cn.mldn.demo; import java.util.List; import java.util.Vector; public class TestDemo { public static void main(String[] args) throws Exception { List&lt;String&gt; all = new Vector&lt;String&gt;() ; all.add(“Hello”) ; all.add(“Hello”) ; // 内容重复了 all.add(“World”) ; for (int x = 0; x &lt; all.size(); x++) { String str = all.get(x) ; // get()方法只有List接口有 System.out.print(str + “、”); } } } 因为所有的操作都是针对于接口完成的，接口定义的方法不变，子类随便变。 面试题：请解释ArrayList和Vector的区别？ No. 区别 ArrayList Vector 1 推出时间 JDK 1.2 JDK 1.0 2 性能 采用异步处理方式，性能更高 采用同步处理方式，性能相对较低 3 安全性 非线程安全 线程安全 4 输出 Iterator、ListIterator、foreach Iterator、ListIterator、foreach、Enumeration 从实际开发而言，几乎都是开发异步程序，所以首选的肯定是ArrayList子类。 3.4、不允许重复的子接口：Set（重点），20% Set也是一个Collection较为常用的子接口，这个接口的定义如下： public interface Set&lt;E&gt; extends Collection&lt;E&gt; 在Collection接口定义了15个方法，但是Set子接口并不像List子接口那样对Collection接口进行了大量的扩充，而是完整的继承了下来，那么就证明了在Set子接口之中是肯定无法使用get()方法的。 那么在Set子接口之中常用的两个子类：HashSet、TreeSet，下面分别说明。 3.4.1、散列存放的子类：HashSet，80% Hash（哈希）属于一种算法，这种算法的核心意义指的是找空保存算法，所以只要一看见hash第一反应就是说没有顺序的保存。 范例：观察Set接口使用 package cn.mldn.demo; import java.util.HashSet; import java.util.Set; public class TestDemo { public static void main(String[] args) throws Exception { Set&lt;String&gt; all = new HashSet&lt;String&gt;() ; all.add(“Hello”) ; all.add(“Hello”) ; // 内容重复了 all.add(“World”) ; System.out.println(all); } } 保存数据再输出之后可以发现，重复的数据没有了，并且其本身的保存也是没有任何顺序的。 3.4.2、排序存放的子类：TreeSet，20% 如果现在希望Set集合之中保存的数据有顺序，那么就通过TreeSet进行Set接口的实例化。 范例：使用TreeSet package cn.mldn.demo; import java.util.Set; import java.util.TreeSet; public class TestDemo { public static void main(String[] args) throws Exception { Set&lt;String&gt; all = new TreeSet&lt;String&gt;() ; all.add(“D”) ; all.add(“A”) ; // 内容重复了 all.add(“B”) ; all.add(“B”) ; all.add(“C”) ; System.out.println(all); } } 现在发现所有保存的数据没有重复且有序排列。 3.4.3、关于TreeSet排序的说明（重点） 通过之前的程序可以发现，使用TreeSet实例化Set接口之中，所有保存的数据都是有序的，那么在这种情况下，那么如果说使用的是一个自定义的类呢？ 那么这个时候如果这个类对象要进行排序的话，则这个类必须实现Comparable接口，设置比较规则。但是在这种情况下有一点必须注意：一旦使用了Comparable之后，类之中的所有属性都必须写进排序规则。 范例：自定义类排序 package cn.mldn.demo; import java.util.Set; import java.util.TreeSet; class Person implements Comparable&lt;Person&gt; { private String name ; private int age ; public Person(String name,int age) { this.name = name ; this.age = age ; } @Override public String toString() { return “姓名：” + this.name + “，年龄：” + this.age + “\\n” ; } @Override public int compareTo(Person o) { if (this.age &gt; o.age) { return 1 ; } else if (this.age &lt; o.age) { **return** -1 ; } **else** { **return this**.name.compareTo(o.name); } } } **public class** TestDemo { **public static void** main(String[] args) **throws** Exception { Set&lt;Person&gt; all = new TreeSet&lt;Person&gt;() ; all.add(new Person(“张三”,20)) ; all.add(new Person(“张三”,20)) ; // 全部重复 all.add(new Person(“李四”,20)) ; // 年龄重复 all.add(new Person(“王五”,19)) ; all.add(new Person(“赵六”,21)) ; System.out.println(all); }} TreeSet子类依靠Comparable中compareTo()方法的返回值是否为0来判断是否为重复元素。 3.4.4、关于重复元素的说明 那么TreeSet依靠Comparable进行重复元素判断，那么HashSet可以吗？发现以上的程序换为了HashSet之后，该有的重复还是有，因为从真正的意义上来讲，判断重复元素依靠的不是Comparable（只有排序的时候才依靠Comparable），所有的重复元素的判断依靠于Object类的两个方法： · hash码：public int hashCode()； · 对象比较：public boolean equals(Object obj)。 在进行对象比较的过程之中，首先会先使用hashCode()与已保存在集合之中的对象的hashCode()进行比较，如果代码相同，则再使用equals()方法进行属性的依次判断，如果全部相同，则为相同元素。 那么为了保证每一个对象的hashCode()不一样，需要设计一组数学公式才可以，会吗？ 范例：重复元素 package cn.mldn.demo; import java.util.HashSet; import java.util.Set; class Person { private String name ; private int age ; public Person(String name,int age) { this.name = name ; this.age = age ; } @Override public String toString() { return “姓名：” + this.name + “，年龄：” + this.age + “\\n” ; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Person other = (Person) obj; if (age != other.age) return false; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } } public class TestDemo { public static void main(String[] args) throws Exception { Set&lt;Person&gt; all = new HashSet&lt;Person&gt;() ; all.add(new Person(“张三”,20)) ; all.add(new Person(“张三”,20)) ; // 全部重复 all.add(new Person(“李四”,20)) ; // 年龄重复 all.add(new Person(“王五”,19)) ; all.add(new Person(“赵六”,21)) ; System.out.println(all); } } 至此，Object类之中的全部方法就讲解完成了。 3.5、集合的输出操作（重点） 在之前所介绍的都属于单值集合的基本操作，可是对于集合有一个最为重要的问题就是如何进行集合内容的输出操作，而这个问题在Java的类集框架之中给出了四种输出方式：Iterator、ListIterator、Enumeration、foreach。 3.5.1、迭代输出：Iterator（核心），95% Iterator是最为常用的集合输出接口，在这个接口中一共定义了三个方法，但只有两个有真正用处： · 判断是否有下一个元素：public boolean hasNext()； · 取得下一个元素：public E next()。 在Iterator接口之中存在了一个remove()方法，但是这个方法真没用。而且在之前学习的Scanner也是Iterator的子类。 但是如何取得Iterator接口的实例化对象呢？这一操作在Collection接口就已经明确定义了，因为Collection继承了一个Iterable接口，在这个接口下定义了一个方法：publicIterator&lt;T&gt;iterator()，取得Iterator接口的实例化对象，但是与之前在IO操作部分学习的一样，OutputStream实现了Closeable和Flushable两个接口，但是这两个接口属于新的接口，和这两个接口一样，Iterable接口也是在JDK1.5的时候出现的，那么基本上也不会去关心这两个接口，因为Collection接口中也已经明确定义了iterator()方法。 范例：使用Iterator输出集合数据 package cn.mldn.demo; import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class TestDemo { public static void main(String[] args) throws Exception { List&lt;String&gt; all = new ArrayList&lt;String&gt;(); all.add(“Hello”); all.add(“Hello”); // 内容重复了 all.add(“World”); Iterator&lt;String&gt; iter = all.iterator(); while (iter.hasNext()) { // 判断是否有下一个元素 String str = iter.next() ; System.out.print(str + “、”); } } } 以后只要是见到了集合的输出操作，永远都使用Iterator接口完成。 3.5.2、双向迭代输出：ListIterator（了解），0.09% Iterator可以完成的是由前向后的单向输出操作，如果现在希望可以完成由前向后，和由后向前输出的话，那么就可以利用ListIterator接口完成，此接口是Iterator的子接口，在ListIterator接口主要使用以下两个扩充方法： · 判断是否有前一个元素：public boolean hasPrevious()； · 取出前一个元素：public E previous()。 但是如果要想取得ListIterator接口的实例化对象，Collection没有这样的方法支持，这个方法在List接口之中存在：publicListIterator&lt;E&gt; listIterator()。 范例：执行双向迭代 package cn.mldn.demo; import java.util.ArrayList; import java.util.List; import java.util.ListIterator; public class TestDemo { public static void main(String[] args) throws Exception { List&lt;String&gt; all = new ArrayList&lt;String&gt;(); all.add(“Hello”); all.add(“Hello”); // 内容重复了 all.add(“World”); ListIterator&lt;String&gt; iter = all.listIterator(); System.out.print(“由前向后输出：”); while (iter.hasNext()) { // 判断是否有下一个元素 String str = iter.next() ; System.out.print(str + “、”); } System.out.print(“\\n由后向前输出：”); while (iter.hasPrevious()) { String str = iter.previous() ; System.out.print(str + “、”); } } } 但是对于由后向前的输出操作，在进行之前一定要首先发生由前向后的输出。由于此输出接口只有List可以使用，所以在开发之中几乎不会出现。 3.5.3、废弃的接口：Enumeration（重点），4.9% Enumeration是一个最早的输出接口，最早称为枚举输出，在JDK1.0的时候就已经推出了，并且在JDK1.5的时候将其功能进行了扩充，主要就是增加了泛型，在Enumeration接口里面只定义了两个方法： · 判断是否有下一个元素：public boolean hasMoreElements()； · 取得当前元素：public E nextElement()； 不过要想取得Enumeration的实例化对象，不能依靠Collection接口了，只能够依靠Vector类完成，在Vector子类之中定义了如下一个方法：publicEnumeration&lt;E&gt; elements()。 范例：使用Enumeration进行输出 package cn.mldn.demo; import java.util.Enumeration; import java.util.Vector; public class TestDemo { public static void main(String[] args) throws Exception { Vector&lt;String&gt; all = new Vector&lt;String&gt;(); all.add(“Hello”); all.add(“Hello”); // 内容重复了 all.add(“World”); Enumeration&lt;String&gt; enu = all.elements(); while (enu.hasMoreElements()) { String str = enu.nextElement(); System.out.print(str + “、”); } } } 从开发而言，首先考虑绝对不是Enumeration，考虑的肯定是Iterator，只有在必须使用的时候才用它。 3.5.4、JDK 1.5的支持：foreach（理解），0.01% 对于foreach输出除了可以进行数组内容的输出之外，也可以针对于集合完成输出。 范例：使用foreach package cn.mldn.demo; import java.util.ArrayList; import java.util.List; public class TestDemo { public static void main(String[] args) throws Exception { List&lt;String&gt; all = new ArrayList&lt;String&gt;(); all.add(“Hello”); all.add(“Hello”); // 内容重复了 all.add(“World”); for (String str : all) { System.out.print(str + “、”); } } } 使用foreach并不是一个被广泛认可的操作代码形式。 3.6、偶对象保存：Map接口（重点） 偶对象指的是一对对象，即：两个对象要同时保存。这两个对象是按照了“key=value”的形式进行定义的，即：可以通过key找到对应的value数据，就好象电话号码本一样，例如，电话号码本之中保存了如下的信息： · key = 张三，value = 123456； · key = 李四，value = 234567； 现在如果要想找到张三的电话，那么肯定根据张三的key，取得对应的value，，而如果现在要想找王五的电话，由于没有王五这个key，所以返回的结果就是null。 Map就是实现这样一种操作的数据结构，这个接口之中定义的主要操作方法如下。 No. 方法名称 类型 描述 1 public V put(K key, V value) 普通 向集合之中保存数据 2 public V get(Object key) 普通 通过指定的key取得对应的value 3 public Set&lt;K&gt; keySet() 普通 将Map中的所有key以Set集合的方式返回 4 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 普通 将Map集合变为Set集合 在Map接口之中有两个常用的子类：HashMap、Hashtable。 3.6.1、新的子类：HashMap，95% HashMap是Map接口之中使用最多的一个子类，这个子类的定义如下： public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 下面就直接通过HashMap演示Map接口中各个主要方法的作用。 范例：验证Map方法 package cn.mldn.demo; import java.util.HashMap; import java.util.Map; public class TestDemo { public static void main(String[] args) throws Exception { Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(); map.put(3, “张三”); map.put(null, “无名氏”); map.put(3, “李四”); // key重复，value会被新内容覆盖 map.put(1, “王五”); map.put(0, “赵六”); System.out.println(map.get(3)); System.out.println(map.get(null)); } } 通过这一代码可以发现，Map和Collection在操作上的不同： · Collection接口设置完的内容目的是为了输出； · Map接口设置完内容的目的是为了查找。 范例：取得全部的key，全部的key通过Set集合返回 package cn.mldn.demo; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set; public class TestDemo { public static void main(String[] args) throws Exception { Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(); map.put(3, “张三”); map.put(null, “无名氏”); map.put(3, “李四”); // key重复，value会被新内容覆盖 map.put(1, “王五”); map.put(0, “赵六”); Set&lt;Integer&gt; set = map.keySet() ;// 取得全部的key Iterator&lt;Integer&gt; iter = set.iterator() ; while (iter.hasNext()) { Integer key = iter.next() ; System.out.println(key + “ –&gt; “ + map.get(key)); } } } 3.6.2、旧的子类：Hashtable，5% Hashtable是在JDK 1.0的时候推出的一个数据结构类，在JDK1.2之后，让Hashtable实现了一个Map接口，所以用户在使用的时候依然采用子类为接口实例化的方法进行，那么只要接口的方法不变，实际上不管使用那一个子类都一样。 package cn.mldn.demo; import java.util.Hashtable; import java.util.Map; public class TestDemo { public static void main(String[] args) throws Exception { Map&lt;Integer, String&gt; map = new Hashtable&lt;Integer, String&gt;(); map.put(3, “张三”); map.put(3, “李四”); // key重复，value会被新内容覆盖 map.put(1, “王五”); map.put(0, “赵六”); System.out.println(map.get(3)); System.out.println(map.get(10)); } } 这个时候在使用Hashtable子类的时候，里面的数据不能有null。 面试题：请解释HashMap和Hashtable的区别？ No. 区别 HashMap Hashtable 1 推出时间 JDK 1.2 JDK 1.0 2 性能 采用异步处理方式，性能更高 采用同步处理方式，性能相对较低 3 安全性 非线程安全 线程安全 4 设置null 允许将key或value设置为null 不允许出现null，否则出现空指向异常 3.6.3、关于Map集合的输出问题（核心） 对于集合操作，在之前就一直强调：只要是集合的输出都使用Iterator完成，但是对于现在的Map集合就麻烦了，因为Map接口之中并没有提供像Collection接口那样的iterator()方法，所以如何使用Iterator输出Map集合呢？ 如果要想真正的去思考Map接口通过Iterator输出，那么首先需要来观察一个Map.Entry接口，此接口定义如下： public static interface Map**.**Entry&lt;K,V&gt; 很明显，这是一个在Map接口之中使用static定义的一个内部接口。而且通过Map接口的定义也可以发现此内部接口的存在。 而在Map.Entry这个内部接口之中还存在有以下的两个常用方法： · 取得当前的key：public K getKey()； · 取得当前的value：public V getValue()。 下面通过一个图形来对比一下Collection和Map接口保存的数据形式。 通过以上的对比可以发现，在Map集合和Collection集合之中保存的最大区别：Collection直接保存的是要操作对象，而Map集合是将保存的key和value变成了一个Map.Entry对象，通过这个对象包装了key和value后保存的，所以根据这一特征，就可以给出Map使用Iterator输出的操作步骤： · 使用Map接口中的entrySet()方法，将Map集合变为Set集合； · 取得了Set接口实例之后就可以利用iterator()方法取得Iterator的实例化对象； · 使用Iterator迭代找到每一个Map.Entry对象，并进行key和value的分离。 范例：使用Iterator输出Map集合 package cn.mldn.demo; import java.util.Hashtable; import java.util.Iterator; import java.util.Map; import java.util.Set; public class TestDemo { public static void main(String[] args) throws Exception { Map&lt;Integer, String&gt; map = new Hashtable&lt;Integer, String&gt;(); map.put(3, “张三”); map.put(3, “李四”); // key重复，value会被新内容覆盖 map.put(1, “王五”); map.put(0, “赵六”); Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set = map.entrySet(); Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iter = set.iterator(); while (iter.hasNext()) { Map.Entry&lt;Integer, String&gt; me = iter.next(); System.out.println(me.getKey() + “，” + me.getValue()); } } } 这种代码在日后的所有开发之中一定会出现，所以必须会。 面试题：现在在一个List集合之中保存了多个String对象，要求将这个List集合变为Set集合，而后再将这个Set集合之中的全部数据保存在Map集合的value里面，而Map集合的key使用UUID生成，最后将Map中的数据进行迭代输出。 相关说明： 1、 在Collection接口之中存在一个增加一组集合的方法：public booleanaddAll(Collection&lt;? extends E&gt; c)； 2、UUID是一种算法，在Java中有指定的类，这个类可以根据时间戳生成一个几乎不会重复的字符串； package cn.mldn.demo; import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; import java.util.UUID; public class TestDemo { public static void main(String[] args) throws Exception { List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(“Hello”); list.add(“Hello”); list.add(“World”); Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.addAll(list); // 将List集合加到Set之中 Map&lt;UUID, String&gt; map = new HashMap&lt;UUID, String&gt;(); Iterator&lt;String&gt; iter = set.iterator(); while (iter.hasNext()) { map.put(UUID.randomUUID(), iter.next()); } // 数据保存到Map集合 Iterator&lt;Map.Entry&lt;UUID, String&gt;&gt; iterMap = map.entrySet().iterator(); while (iterMap.hasNext()) { Map.Entry&lt;UUID, String&gt; me = iterMap.next(); System.out.println(me.getKey() + “ –&gt; “ + me.getValue()); } } } 就是把几个集合互相折腾了一番。 3.6.4、关于Map中保存key的说明 通过程序可以发现，之前的Map集合之中都是使用了系统类作为了Map的key，那么实际上用户也可以使用自定义的类作为key出现，可是如果要想作为key的类必须注意一点：因为key属于查找操作，所以要想找到符合的key，那么作为key所在的类就必须覆写Object类之中的两个方法：hashCode()、equals()。 范例：自定义类作为key package cn.mldn.demo; import java.util.HashMap; import java.util.Map; class Person { private String name; public Person(String name) { this.name = name; } @Override public String toString() { return “姓名：” + this.name; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Person other = (Person) obj; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } } public class TestDemo { public static void main(String[] args) throws Exception { Map&lt;Person, String&gt; map = new HashMap&lt;&gt;(); map.put(new Person(“张三”), new String(“zs”)); System.out.println(map.get(new Person(“张三”))); } } 但是这种程序也只是作为学习之中的概念出现，而在实际的开发之中，永远都是String作为key，因为最方便。 3.7、Stack类（理解） Stack是栈，栈是一种先进后出的数据结构，Stack类的定义如下： public class Stack&lt;E&gt; extends Vector&lt;E&gt; 可以发现Stack类属于Vector的子类，但是使用的时候却不使用Vector类定义的方法，而使用Stack类自己的方法： · 入栈操作：public E push(E item)； · 出栈操作：public E pop()； 范例：观察栈的基本操作 package cn.mldn.demo; import java.util.Stack; public class TestDemo { public static void main(String[] args) throws Exception { Stack&lt;String&gt; all = new Stack&lt;&gt;(); all.add(“A”); all.add(“B”); all.add(“C”); System.out.println(all.pop()); System.out.println(all.pop()); System.out.println(all.pop()); System.out.println(all.pop()); // 没数据了，出现EmptyStackException } } 对于栈这一概念在自己编写的代码之中使用不多，不过以后的学习都会出现栈的概念，例如：在Android开发之中，多个Activity之间的互相调用和返回就是利用了栈。 3.8、Collections类（了解） Collections是专门提供的一个集合的工具类，并没有实现Collection接口，但是在这个类之中，有许多的操作方法，可以方便的进行集合的操作（根本没用）。 package cn.mldn.demo; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class TestDemo { public static void main(String[] args) throws Exception { List&lt;String&gt; all = new ArrayList&lt;String&gt;(); Collections.addAll(all, “A”, “B”, “C”); System.out.println(all); Collections.reverse(all) ; System.out.println(all); } } 面试题：请解释Collection和Collections的区别？ · Collection是一个接口，用于定义集合操作的标准； · Collections是一个工具类，可以操作任意的集合对象。 3.9、属性操作类：Properties（理解） 属性一般都是指的是针对于字符串数据，并且所有的字符串数据都会按照“key =value”的形式保存，属性操作类主要是针对于属性文件完成的。Properties类本身是Hashtable的子类： public class Properties extends Hashtable&lt;Object,Object&gt; 但是在使用方法上操作的并不是由Map接口定义的方法，使用Properties自己的方法： · 设置属性：public Object setProperty(String key, String value)； · 取得属性：public String getProperty(String key)，如果没有指定的key返回null； · 取得属性：public String getProperty(String key, StringdefaultValue)，如果没有指定的key，返回默认值。 范例：观察属性的设置和取得 package cn.mldn.demo; import java.util.Properties; public class TestDemo { public static void main(String[] args) throws Exception { Properties pros = new Properties(); pros.setProperty(“BJ”, “ BeiJing “); pros.setProperty(“SH”, “上海”); System.out.println(pros.getProperty(“BJ”)); System.out.println(pros.getProperty(“TJ”)); System.out.println(pros.getProperty(“TJ”, “没有发现”)); } } 但是使用Properties类最方便的特点是可以直接将这些属性以OutputStream的方式或InputStream的方式输出或读取： · 向输出流中输出属性：public void store(OutputStream out, String comments)throws IOException； · 从输入流中读取属性：public void load(InputStream inStream) throwsIOException。 范例：将属性保存到文件之中，一般保存属性文件的后缀都是“*.properties” package cn.mldn.demo; import java.io.File; import java.io.FileOutputStream; import java.util.Properties; public class TestDemo { public static void main(String[] args) throws Exception { Properties pros = new Properties(); pros.setProperty(“BJ”, “ BeiJing “); pros.setProperty(“SH”, “上海”); pros.store(new FileOutputStream(new File(“D:” + File.separator + “area.properties”)), “Area Info”); } } 范例：通过属性文件读取内容 package cn.mldn.demo; import java.io.File; import java.io.FileInputStream; import java.util.Properties; public class TestDemo { public static void main(String[] args) throws Exception { Properties pros = new Properties(); pros.load(new FileInputStream(new File(“D:” + File.separator + “area.properties”))); System.out.println(pros.getProperty(“BJ”)); System.out.println(pros.getProperty(“TJ”)); System.out.println(pros.getProperty(“TJ”, “没有发现”)); } } 在日后的开发之中，一些框架会帮助用户自动的编写读取属性的操作，所以用户以后最关心的只是修改属性文件的工作，这一点在日后的Struts、Spring中都会见到。 4、总结 1、 Collection负责输出、Map负责查找； 2、 集合的输出就使用Iterator完成。","categories":[],"tags":[]},{"title":"","slug":"面向对象_05","date":"2020-08-10T14:21:51.338Z","updated":"2020-08-10T14:12:11.644Z","comments":true,"path":"2020/08/10/mian-xiang-dui-xiang-05/","link":"","permalink":"https://kilitom.github.io/2020/08/10/mian-xiang-dui-xiang-05/","excerpt":"","text":"3.1、继承性（重点）继承性是面向对象的第二大主要特征。 3.1.1、继承问题的引出任何的概念出现都有其自己的目的以及可以结局的问题范畴，那么下面首先编写两个程序：Person类、Student类。 Person.java： Student.java： class Person { private String name ; private int age ; public void setName(String name) { this.name = name ; } public void setAge(int age) { this.age = age ; } public String getName() { return this.name ; } public int getAge(){ return this.age ; } } class Student { private String name ; private int age ; private String school ; public void setName(String name) { this.name = name ; } public void setAge(int age) { this.age = age ; } public void setSchool(String school) { this.school = school ; } public String getName() { return this.name ; } public int getAge(){ return this.age ; } public String getSchool() { return this.school ; } } 以上两个程序所使用到的概念都是利用之前所学习过的知识点来完成，但是现在通过代码的比较就可以清楚的发现一点：代码之中存在了重复，而按照之前所学，这种重复是不可能消除的，在所有的代码之中，最具有重复意义的就是链表类，针对于每一个简单Java类或者是说其他的任何类，都编写一个链表程序，代码量庞大，而且不方便维护。 3.1.2、继承的概念继承性严格来讲就是指扩充一个类已有的功能。在Java之中，如果要实现继承的关系，可以使用如下的语法： class 子类 extends 父类 {} · 对于extends而言，应该翻译为扩充，但是为了理解方便，统一称为继承； · 子类又被称为派生类； · 父类又被称为超类（Super Class）。 范例：观察继承的基本实现 class Person { private String name ; private int age ; public void setName(String name) { this.name = name ; } public void setAge(int age) { this.age = age ; } public String getName() { return this.name ; } public int getAge(){ return this.age ; } } class Student extends Person { // Student类继承了Person类 } public class TestDemo { public static void main(String args[]) { Student stu = new Student() ; // 实例化的是子类 stu.setName(“张三”) ; // Person类定义 stu.setAge(20) ; // Person类定义 System.out.println(“姓名：” + stu.getName() + “，年龄：” + stu.getAge()) ; } } 现在通过代码就可以发现了，子类（Student）并没有定义任何的操作，而在主类之中所使用的全部操作都是由Person类定义的，就证明，子类即使不扩充父类，那么也属于维持功能的状态。 范例：在子类之中扩充父类的功能 class Person { private String name ; private int age ; public void setName(String name) { this.name = name ; } public void setAge(int age) { this.age = age ; } public String getName() { return this.name ; } public int getAge(){ return this.age ; } } class Student extends Person { // Student类继承了Person类 private String school ; // 子类的属性 public void setSchool(String school) { this.school = school ; } public String getSchool() { return this.school ; } } public class TestDemo { public static void main(String args[]) { Student stu = new Student() ; // 实例化的是子类 stu.setName(“张三”) ; // Person类定义 stu.setAge(20) ; // Person类定义 stu.setSchool(“清华大学”) ; // Student类扩充方法 System.out.println(“姓名：” + stu.getName() + “，年龄：” + stu.getAge() + “，学校：” + stu.getSchool()) ; } } 以上的代码，子类对于父类的功能进行了扩充（扩充了一个属性和两个方法）。但是思考一下：子类从外表看是扩充了父类的功能，但是对于以上的代码，子类还有一个特点：子类实际上是将父类定义的更加的具体化的一种手段。父类表示的范围大，而子类表示的范围小。 3.1.3、继承的限制虽然继承可以进行类功能的扩充，但是其在定义的时候也是会存在若干种限制的。 限制一：一个子类只能够继承一个父类，存在单继承局限 这个概念实际上是相对于其他语言而言，在其他语言之中，一个子类可以同时继承多个父类，就好比如下代码： 范例：错误的程序 class A {} class B {} class C extends A,B {} // 一个子类继承了两个父类 以上操作称为多重继承，实际上以上的做法就是希望一个子类，可以同时继承多个类的功能，但是以上的语法不支持而已，但是可以换种方式完成同样的操作。 范例：正确的程序 class A {} class B extends A {} class C extends B {} C实际上是属于（孙）子类，这样一来就相当于B类继承了A类的全部方法，而C类又继承了A和B类的方法，这种操作称为多层继承。结论：Java之中只允许多层继承，不允许多重继承，Java存在单继承局限。 严格来讲，按照以上的代码格式，可以一直无限制的继承下去，但是从实际来讲，应该不超过三层。 限制二：在一个子类继承的时候，实际上会继承父类之中的所有操作（属性、方法），但是需要注意的是，对于所有的非私有（noprivate）操作属于显式继承（可以直接利用对象操作），而所有的私有操作属于隐式继承（间接完成）。 class A { private String msg ; public void setMsg(String msg) { this.msg = msg ; } public String getMsg() { return this.msg ; } } class B extends A { public void print() { System.out.println(msg) ; // 错误: msg可以在A中访问private } } public class Test { public static void main(String args[]) { B b = new B() ; b.setMsg(“张三”) ; System.out.println(b.getMsg()) ; } } 此时对于A类之中的msg这个私有属性发现无法直接进行访问，但是却发现可以通过setter、getter方法间接的进行操作。 限制三：在继承关系之中，如果要实例化子类对象，会默认先调用父类构造，为父类之中的属性初始化，之后再调用子类构造，为子类之中的属性初始化，即：默认情况下，子类会找到父类之中的无参构造方法。 class A { public A() { // 父类无参构造 System.out.println(“*************************“) ; } } class B extends A { public B() { // 子类构造 System.out.println(“#########################“); } } public class Test { public static void main(String args[]) { B b = new B() ; // 实例化子类对象 } } 这个时候虽然实例化的是子类对象，但是发现它会默认先执行父类构造，调用父类构造的方法体执行，而后再实例化子类对象，调用子类的构造方法。而这个时候，对于子类的构造而言，就相当于隐含了一个super()的形式。 class B extends A { public B() { // 子类构造 super() ; // 调用父类构造 System.out.println(“#########################“); } } 现在默认调用的是无参构造，而如果这个时候父类没有无参构造，则子类必须通过super()调用指定参数的构造方法。 class A { public A(String msg) { // 父类构造 System.out.println(“*************************“) ; } } class B extends A { public B() { // 子类构造 super(“Hello”) ; // 调用父类构造 System.out.println(“#########################“); } } public class Test { public static void main(String args[]) { B b = new B() ; // 实例化子类对象 } } 在任何的情况下，子类都逃不出父类构造的调用，但是，既然super()可以调用父类构造，那么这个语法和this()很相似，那么很明显了，super调用父类构造的时候，一定要放在构造方法的首行上。 疑问？有没有可能性，不让子类去调用父类构造？ 既然super()和this()都是调用构造方法，而且都要放在构造方法的首行上，那么如果说this()出现了，那么super()应该就不会出现了，所以他编写了如下的程序： class A { public A(String msg) { // 父类构造 System.out.println(“*************************“) ; } } class B extends A { public B(String msg) { this(msg,10) ; // 调用本类构造 } public B(String msg,int age) { // 子类构造 this(msg) ; // 调用本类构造 System.out.println(“#########################“); } } public class Test { public static void main(String args[]) { B b = new B(“”,20) ; // 实例化子类对象 } } 在之前讲解this关键字的时候强调过一句话：如果一个类之中有多个构造方法之间使用this()互相调用的话，那么至少要保留有一个构造方法作为出口，而这个出口就一定会去调用父类构造。 此时在某种程度上来讲，有一个问题解释了一半：一个简单Java类一定要保留有一个无参构造方法。 3.2、覆写（重点）既然现在出现了继承的关系，那么就存在了子类和父类的联系，而在子类之中有可能定义和父类完全相同的方法或属性的名称，这个时候就称为覆写了。 3.2.1、方法的覆写当子类定义了和父类在方法名称、返回值类型、参数类型及个数完全相同的方法的时候，称为方法的覆写。 范例：没有覆写的操作 class A { public void print() { System.out.println(“Hello World .”) ; } } class B extends A { } public class Test { public static void main(String args[]) { B b = new B() ; b.print() ; // 方法从父类继承而来 } } 这个时候实例化的是子类对象，但是在子类之中，没有print()方法，那么就使用从父类之中继承而来的pritn()方法。 范例：实现覆写 class A { public void print() { System.out.println(“Hello World .”) ; } } class B extends A { public void print() { // 方法名称、参数类型及个数、返回值全相同 System.out.println(“世界，你好！”) ; } } public class Test { public static void main(String args[]) { B b = new B() ; b.print() ; // 方法从父类继承而来 } } 当一个类之中的方法被覆写之后，如果实例化的是这个子类对象，则调用的方法就是被覆写过的方法。 但是在进行方法覆写的时候有一个点需要注意：被子类所覆写的方法不能拥有比父类更严格的访问控制权限，对于访问控制权限现在已经接触过三种：private&lt; default（不写） &lt; public； 如果此时父类之中的方法是default权限，那么子类覆写的时候只能是default或public权限，而如果父类的方法是public，那么子类之中方法的访问权限只能是public。 范例：错误的操作 class A { public void print() { System.out.println(“Hello World .”) ; } } class B extends A { void print() { System.out.println(“世界，你好！”) ; } } 提示一下：别没事干自己给自己找事，以后只要是方法都是public，99.9999%可以解决问题。 当一个子类覆写了一个父类方法的时候，那么在这种情况下，子类要想调用父类的被覆写过的方法，则在方法前要加上“super”。 class A { public void print() { System.out.println(“Hello World .”) ; } } class B extends A { public void print() { super.print() ; System.out.println(“世界，你好！”) ; } } public class Test { public static void main(String args[]) { B b = new B() ; b.print() ; // 方法从父类继承而来 } } 在以后一定要记住操作范围： · this.方法()：先从本类查找是否存在指定的方法，如果没有找到，则调用父类操作； · super.方法()：直接由子类调用父类之中的指定方法，不再找子类。 提问：请问以下的操作是覆写吗？ class A { private void print() { System.out.println(“Hello World .”) ; } public void fun() { this.print() ; } } class B extends A { public void print() { // 不叫覆写 System.out.println(“世界，你好！”) ; } } public class Test { public static void main(String args[]) { B b = new B() ; b.fun() ; // 方法从父类继承而来 } } 首先从覆写的概念上来讲：现在父类的权限是private，而子类是public，的确是扩大了权限，而且方法的参数名称及个数、返回值类型都一样。这种情况在开发之中是绝对不会出现的，即：使用了private定义的操作都无法真正覆写。 3.2.2、属性的覆盖（别了解了）当一个子类定义了和父类重名的属性名称的时候，就表示属性的覆盖了。 class A { public String msg = “Hello World .” ; } class B extends A { public int msg = 100 ; // 属性同名 public void print() { System.out.println(“msg = “ + this.msg) ; System.out.println(“msg = “ + super.msg) ; } } public class Test { public static void main(String args[]) { B b = new B() ; b.print() ; // 方法从父类继承而来 } } 这种操作几乎没有意义，因为从开发来讲，属性一定要封装，封装之后就没有覆盖这一概念了。 面试题：请解释一下this和super的区别？ No. 区别 this super 1 定义 表示本类对象 表示父类对象 2 使用 本类操作：this.属性、this.方法()、this() 父类操作：super.属性、super.方法()、super() 3 调用构造 调用本类构造，要放在首行 子类调用父类构造，放在首行 4 查找范围 先从本类查找，找不到查找父类 直接由子类查找父类 5 特殊 表示当前对象 - 面试题：请解释一下方法重载与覆写的区别？当方法重载的时候能否改变其返回值类型？ No. 区别 重载 覆写 1 英文单词 Overloading Override 2 定义 方法名称相同、参数的类型及个数不同 方法名称、参数类型及个数、返回值类型完全相同 3 权限 没有权限要求 被子类所覆写的方法不能拥有比父类更严格的访问控制权限 4 范围 发生在一个类之中 发生在继承关系类之中 方法重载的时候可以改变返回值类型，一般设计的时候不会这样去做。 3.3、思考题（总结，核心）现在要求定义一个整型数组的操作类，数组的大小由外部决定，用户可以向数组之中增加数据，以及取得数组中的全部数据，也可以根据外部提供的数组的增长大小，在原本的数组之上扩充指定的容量，另外，在此类上派生两个子类： · 排序类：取得的数组内容是经过排序出来的结果； · 反转类：取得的数组内容是反转出来的结果； 首先要完成的是定义父类，根本就不需要考虑子类。 范例：定义了父类 —— Array class Array { // 数组操作类 private int [] data ; private int foot = 0 ; // 控制脚标 public Array(int len) { // 由外部传递大小 if (len &gt; 0) { this.data = new int [len] ; } else { this.data = new int [1] ; // 维持一个大小 } } public boolean add(int num) { if (this.foot &lt; this.data.length) { // 有位置 this.data[this.foot ++] = num ; // 保存数据 return true ; } return false ; } public int [] getData() { return this.data ; } public void increment(int num) { int [] newArr = new int [this.data.length + num] ; System.arraycopy(this.data,0,newArr,0,this.data.length) ; this.data = newArr ; // 改变引用 } } public class Test { public static void main(String args[]) { Array arr = new Array(5) ; System.out.println(arr.add(8)) ; System.out.println(arr.add(10)) ; System.out.println(arr.add(2)) ; System.out.println(arr.add(5)) ; System.out.println(arr.add(3)) ; System.out.println(arr.add(9)) ; arr.increment(3) ; System.out.println(arr.add(20)) ; System.out.println(arr.add(10)) ; System.out.println(arr.add(30)) ; int result [] = arr.getData() ; for (int x = 0 ; x &lt; result.length ; x ++) { System.out.println(result[x]) ; } } } 范例：定义排序类 class SortArray extends Array { public SortArray (int len) { super(len) ; // 调用父类的有参构造 } public int [] getData() { java.util.Arrays.sort(super.getData()) ; return super.getData() ; } } public class Test { public static void main(String args[]) { SortArray arr = new SortArray(5) ; System.out.println(arr.add(8)) ; System.out.println(arr.add(10)) ; System.out.println(arr.add(2)) ; System.out.println(arr.add(5)) ; System.out.println(arr.add(3)) ; System.out.println(arr.add(9)) ; arr.increment(3) ; System.out.println(arr.add(20)) ; System.out.println(arr.add(10)) ; System.out.println(arr.add(30)) ; int result [] = arr.getData() ; for (int x = 0 ; x &lt; result.length ; x ++) { System.out.println(result[x]) ; } } } 由于所有的操作方法是以父类操作为主，所以在使用的时候此处只是换了一个类的名称，其他的地方都没有改变。 范例：定义反转子类 class ReverseArray extends Array { public ReverseArray(int len) { super(len) ; } public int [] getData() { // 覆写 int head = 0 ; int tail = super.getData().length - 1 ; int center = super.getData().length / 2 ; for (int x = 0 ; x &lt; center ; x ++) { int temp = super.getData()[head] ; super.getData()[head] = super.getData()[tail] ; super.getData()[tail] = temp ; head ++ ; tail – ; } return super.getData() ; } } public class Test { public static void main(String args[]) { ReverseArray arr = new ReverseArray(5) ; System.out.println(arr.add(8)) ; System.out.println(arr.add(10)) ; System.out.println(arr.add(2)) ; System.out.println(arr.add(5)) ; System.out.println(arr.add(3)) ; System.out.println(arr.add(9)) ; arr.increment(3) ; System.out.println(arr.add(20)) ; System.out.println(arr.add(10)) ; System.out.println(arr.add(30)) ; int result [] = arr.getData() ; for (int x = 0 ; x &lt; result.length ; x ++) { System.out.println(result[x]) ; } } } 在整个程序的开发之中，可以明显感觉到，所有的操作都是围绕着父类功能的扩充进行的，但是方法并没有改变，所以在开发之中，父类的设计是最重要的，子类最好的继承或者说是覆写操作，都应该以父类的方法为主。 3.4、final关键字（重点） 在Java中，final关键字表示的是一个终结器的概念，使用final可以定义类、方法、变量。 1、 使用final定义的类不能有子类，太监类 final class A { } class B extends A { } 2、 使用final定义的方法不能被子类所覆写 class A { public final void print() {} } class B extends A { public void print() {} } 3、使用final定义的变量，就表示常量，常量在定义的时候必须设置默认值，并且无法修改 class A { final String INFO = “hello world” ; // 常量 public final void print() { INFO = “world” ; // 无法修改 } } 而如果说现在使用了public static来定义的常量，那么这个常量就称为全局常量。 public static final String INFO = “hello world” ; // 全局常量 而对于以上final关键字定义的三个操作，只有全局常量的概念是被开发之中所使用的，像类或方法定义上使用final的情况，几乎是不会在我们自己编写的代码过程之中出现。定义final常量的时候每个单词的字母都要大写。 3.5、构造方法私有化（重点）在讲解本操作之前，首先来观察如下的程序。 class Singleton { // 定义一个类 public void print() { System.out.println(“Hello World .”) ; } } public class Test { public static void main(String args[]) { Singleton inst = null ; // 声明对象 inst = new Singleton() ; // 实例化对象 inst.print() ; // 调用方法 } } 在以上的程序之中，Singleton类里面是存在构造方法的（因为如果一个类之中没有明确的定义一个构造方法的话，则会自动生成一个无参的，什么都不做的构造方法），但是下面要将构造方法改变一下。 class Singleton { // 定义一个类 private Singleton() {} // 构造方法私有化 public void print() { System.out.println(“Hello World .”) ; } } 现在发现在实例化Singleton类对象的时候，程序出现了编译错误，因为构造方法被私有化了，无法在外部调用，即：无法在外部实例化Singleton类的对象。 那么现在就需要思考：在保证Singleton类之中的构造方法不修改不增加，以及print()方法不修改的情况下，如何操作，才可以让类的外部通过实例化对象再去调用print()方法？ 思考过程一：使用private访问权限定义的操作只能被本类所访问，外部无法调用，那么现在既然构造方法被私有化了，就证明，这个类的构造方法只能被本类所调用，即：现在在本类之中产生本类实例化对象。 class Singleton { // 定义一个类 Singleton instance = new Singleton() ; private Singleton() {} // 构造方法私有化 public void print() { System.out.println(“Hello World .”) ; } } 思考过程二：对于一个类之中的普通属性，默认情况下一定要在本类存在了实例化对象之后才可以进行调用，可是现在在Singleton类的外部无法产生实例化对象，那么必须想一个办法，让Singleton类中的instance属性可以在没有Singleton类实例化对象的时候来进行调用，可以使用static完成，static定义的属性特点：由类名称直接调用，并且在没有实例化对象的时候也可以调用。 class Singleton { // 定义一个类 static Singleton instance = new Singleton() ; private Singleton() {} // 构造方法私有化 public void print() { System.out.println(“Hello World .”) ; } } public class Test { public static void main(String args[]) { Singleton inst = null ; // 声明对象 inst = Singleton.instance ; // 实例化对象 inst.print() ; // 调用方法 } } 思考过程三：类之中的全部属性都应该封装，所以以上的instance属性应该进行封装，而封装之后要想取得属性要编写getter方法，只不过这个时候的getter方法应该也由类名称直接调用，定义为static型。 class Singleton { // 定义一个类 private static Singleton instance = new Singleton() ; private Singleton() {} // 构造方法私有化 public void print() { System.out.println(“Hello World .”) ; } public static Singleton getInstance() { return instance ; } } public class Test { public static void main(String args[]) { Singleton inst = null ; // 声明对象 inst = Singleton.getInstance() ; // 实例化对象 inst.print() ; // 调用方法 } } 思考过程四：这样做的目的？此时程序之中的instance属性，属于static，那么表示所有Singleton类的对象，不管有多少个都共同拥有同一个instance属性，那么既然是有同一个，那么又有什么意义呢？ 现在做一个简单的思考：如果说现在一个类只希望有唯一的一个实例化对象出现，应该控制构造方法，如果构造方法对外部不可见了，那么现在肯定无法执行对象的实例化操作，必须将构造方法隐藏，使用private隐藏。 既然清楚了这个目的，不过本程序依然有一个问题。 public static Singleton getInstance() { instance = new Singleton() ; return instance ; } 本操作语法没有错误，也不需要考虑是否有意义，但是现在的代码是允许这样做的，而这样做发现之前表示唯一一个实例化对象的所有努力就白费了，那么必须想办法废除掉这种做法，可以在定义instance的时候增加一个final关键字。 class Singleton { // 定义一个类 private static final Singleton INSTANCE = new Singleton() ; private Singleton() {} // 构造方法私有化 public void print() { System.out.println(“Hello World .”) ; } public static Singleton getInstance() { return INSTANCE ; } } public class Test { public static void main(String args[]) { Singleton inst = null ; // 声明对象 inst = Singleton.getInstance() ; // 实例化对象 inst.print() ; // 调用方法 } } 这样的设计在设计模式上讲就称为单例设计模式（Singleton）。 面试题：请编写一个Singleton程序，并说明其主要特点？ class Singleton { // 定义一个类 private static final Singleton INSTANCE = new Singleton() ; private Singleton() {} // 构造方法私有化 public void print() { System.out.println(“Hello World .”) ; } public static Singleton getInstance() { return INSTANCE ; } } public class Test { public static void main(String args[]) { Singleton inst = null ; // 声明对象 inst = Singleton.getInstance() ; // 实例化对象 inst.print() ; // 调用方法 } } 特点：构造方法被私有化，只能够通过getInstance()方法取得Singleton类的实例化对象，这样不管外部如何操作，最终也只有一个实例化对象，在单例设计模式之中，一定会存在一个static方法，用于取得本类的实例化对象。 对于单例设计模式，在日后的开发之中，只会用到此概念，但是具体的代码很少去编写。 扩展（可以不会）： 对于单例设计模式按照设计模式的角度而言，分为两种： · 饿汉式：之前写的程序就属于饿汉式，因为在类之中的INSNTACE属性是在定义属性的时候直接实例化； · 懒汉式：在第一次使用一个类实例化对象的时候才去实例化。 范例：观察懒汉式 class Singleton { // 定义一个类 private static Singleton instance ; private Singleton() {} // 构造方法私有化 public void print() { System.out.println(“Hello World .”) ; } public static Singleton getInstance() { if (instance == null) { // 没有实例化 instance = new Singleton() ; // 实例化 } return instance ; } } 这些概念清楚就行了，对于单例设计再次强调：记清楚代码的结构以及操作的特点，以后这种代码虽然不会由你自己去写，但是概念一定会用到。 3.6、多例设计模式（理解）单例设计模式只留有一个类的一个实例化对象，而多例设计模式，会定义出多个对象，例如：定义一个表示星期X的类，这个类的对象只有7个取值，定义一个表示性别的类，只有2个取值，定义一个表示颜色基色的操作类，颜色只有三个：红、绿、蓝，这种情况下，这样的类就不应该由用户无限制的去创造实例化对象，应该只使用有限的几个，这个就属于多例设计，但不管是单例设计还是多例设计，有一个核心不可动摇—— 构造方法私有化。 class Sex { private static final Sex MALE = new Sex(“男”) ; private static final Sex FEMALE = new Sex(“女”) ; private String title ; private Sex(String title) { // 构造方法私有化 this.title = title ; } public static Sex getInstance(String msg) { switch(msg) { case “male” : return MALE ; case “female” : return FEMALE ; default : return null ; } } public String getTitle() { return this.title ; } } public class Test { public static void main(String args[]) { Sex male = Sex.getInstance(“male”) ; System.out.println(male.getTitle()) ; } } 构造方法的封装是实现所有操作的基础，但是在我们所编写的代码过程之中，首先考虑的不是构造方法的封装。 3.7、多态性（重点）多态是面向对象的最后一个主要特征，它本身主要分为两个方面： · 方法的多态性：重载与覆写 |- 重载：同一个方法名称，根据不同的参数类型及个数可以完成不同的功能； |- 覆写：同一个方法，根据操作的子类不同，所完成的功能也不同。 · 对象的多态性：父子类对象的转换。 |- 向上转型：子类对象变为父类对象，格式：父类 父类对象 = 子类实例，自动； |- 向下转型：父类对象变为子类对象，格式：子类 子类对象 = (子类)父类实例，强制； 范例：编写一个简单的程序，观察程序输出 class A { public void print() { System.out.println(“A、public void print(){}”) ; } } class B extends A { public void print() { // 方法覆写 System.out.println(“B、public void print(){}”) ; } } public class Test { public static void main(String args[]) { B b = new B() ; // 实例化子类对象 b.print() ; } } 这种操作主要观察两点： · 看new的是那一个类； · 看new的这个类之中是否被覆写了父类要调用的方法。 范例：向上转型 public class Test { public static void main(String args[]) { A a = new B() ; // 向上转型 a.print() ; } } 范例：向下转型 public class Test { public static void main(String args[]) { A a = new B() ; // 向上转型 B b = (B) a ; // 向下转型 b.print() ; } } 范例：观察如下程序 public class Test { public static void main(String args[]) { A a = new A() ; // 没有转型 B b = (B) a ; // 向下转型，java.lang.ClassCastException: A cannot be cast to B b.print() ; } } 以上的程序在编译的时候没有发生任何的错误信息，但是在执行的时候出现了“ClassCastException”错误提示，表示的是类转换异常，即：两个没有关系的类互相发生了对象的强制转型。 在整个故事之中可以发现： · 如果两个人真的有关系，可以分配遗产； · 如果两个人真的没有关系，不能分配遗产。 转型因素： ·在实际的工作之中，对象的向上转型为主要使用，80%，向上转型之后，所有的方法以父类的方法为主，但是具体的实现，还是要看子类是否覆写了此方法； ·向下转型，10%，因为在进行向下转型操作之前，一定要首先发生向上转型，以建立两个对象之间的联系，如果没有这种联系，是不可能发生向下转型的，一旦发生了运行中就会出现“ClassCastException”，当需要调用子类自己特殊定义方法的时候，才需要向下转型； · 不转型，10%，在一些资源较少的时候，例如：移动开发。 class A { public void print() { System.out.println(“A、public void print(){}”) ; } } class B extends A { public void print() { // 方法覆写 System.out.println(“B、public void print(){}”) ; } public void getB() { System.out.println(“B、getB()”) ; } } public class Test { public static void main(String args[]) { A a = new B() ; // 向上转型 B b = (B) a ; // 向下转型 b.getB() ; // 父类没有的操作，只能通过子类对象调用 } } 既然在发生向下转型的操作之中会存在一些问题，那么能不能想判断一下再转型呢？如果要想判断某一个对象是否是某一个类的实例，只需要使用instanceof关键字即可，此操作的语法如下： 对象 instanceof 类 返回boolean型 范例：观察instanceof验证 public class Test { public static void main(String args[]) { A a = new A() ; System.out.println(a instanceof A) ; System.out.println(a instanceof B) ; if (a instanceof B) { B b = (B) a ; b.getB() ; } } } 为了日后的操作方便，在编写代码的时候，尽量不要去执行向下转型操作。子类尽量不要去扩充新的方法名称（父类没有的方法名称），依据父类定义的操作完善方法。 范例：观察完善的操作 class Person { private String name ; private int age ; public Person(String name,int age) { this.name = name ; this.age = age ; } public String getInfo() { return “姓名：” + this.name + “，年龄：” + this.age ; } } class Student extends Person { // Student类继承了Person类 private String school ; // 子类的属性 public Student(String name,int age,String school) { super(name,age) ; this.school = school ; } public String getInfo() { return super.getInfo() + “，学校：” + this.school ; } } public class TestDemo { public static void main(String args[]) { Person per = new Student(“张三”,20,”清华大学”) ; System.out.println(per.getInfo()) ; } } 一切的操作标准都要以父类为主，这是向上转型的意义所在，另外，除了以上的意义之外，向上转型还可以解决一个最为麻烦的问题。例如： class A { public void print() { System.out.println(“A、public void print(){}”) ; } } 现在要求定义一个方法，这个方法可以接收A类的任意子类对象。 实现方式一：不使用对象转型 class A { public void print() { System.out.println(“A、public void print(){}”) ; } } class B extends A { public void print() { // 方法覆写 System.out.println(“B、public void print(){}”) ; } } class C extends A { public void print() { // 方法覆写 System.out.println(“C、public void print(){}”) ; } } public class Test { public static void main(String args[]) { fun(new B()) ; fun(new C()) ; } public static void fun(B b) { b.print() ; } public static void fun(C c) { c.print() ; } } 但是，如果真的依靠了以上的方式进行代码开发的话，最为严重的事情：如果A类有5000W个子类，方法重载5000W次，并且一旦有新的子类产生，那么方法都要被重复的修改，这样不现实。 实现方式二：利用对象向上转型完成 public class Test { public static void main(String args[]) { fun(new B()) ; fun(new C()) ; } public static void fun(A a) { a.print() ; } } 这样一来，参数的类型就得到了统一，就算有再多的子类出现，方法或者是类也不需要进行修改了，但是在这块必须强调的是：子类操作的过程之中，尽量向父类靠拢。 class A { public void print() { System.out.println(“A、public void print(){}”) ; } } class B extends A { public void print() { // 方法覆写 this.getB() ; System.out.println(“B、public void print(){}”) ; } public void getB() { System.out.println(“B、getB()”) ; } } class C extends A { public void print() { // 方法覆写 this.getC() ; System.out.println(“C、public void print(){}”) ; } public void getC() { System.out.println(“C、getC()”) ; } } public class Test { public static void main(String args[]) { fun(new B()) ; fun(new C()) ; } public static void fun(A a) { a.print() ; } } 以后所有的代码之中，都会存在对象的转型问题，并且向上转型居多。 在日后的所有开发之中，像之前程序那样，一个类去继承另外一个已经实现好的类的情况，是不可能出现的。即：一个类不能去继承一个已经实现好的类，只能继承抽象类或实现接口。对于抽象类和接口如果要想真正的清楚其概念，需要一段很长的时间，今天讲解它们的基本语法、定义形式、使用方式，给出一些代码的结构。 3.8、抽象类（核心）3.8.1、抽象类的基本概念普通类就是一个完善的功能类，可以直接产生对象并且可以使用，里面的方法都是带有方法体的，而抽象类之中最大的特点是包含了抽象方法，而抽象方法是只声明而未实现（没有方法体）的方法，而抽象方法定义的时候要使用abstract关键字完成，而抽象方法一定要在抽象类之中，抽象类要使用abstract关键字声明。 范例：定义一个抽象类 abstract class A { private String info = “Hello World .” ; public void print() { System.out.println(info) ; } public abstract void get() ; // 只声明没有方法体 } 范例：错误的使用 —— 直接实例化对象 public class Test { public static void main(String args[]) { A a = new A () ; // Test.java:10: 错误: A是抽象的; 无法实例化 } } 思考：为什么抽象类对象不能够直接new？ 一个类的对象实例化之后，可以调用类中的属性和方法，但是抽象类之中的抽象方法没有方法体，如果这样直接调用，那么不就乱了吗。 抽象类的使用原则： · 抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类； · 子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法； · 抽象类对象可以使用对象的向上转型方式，通过子类来进行实例化操作。 范例：使用抽象类 abstract class A { private String info = “Hello World .” ; public void print() { System.out.println(info) ; } public abstract void get() ; // 只声明没有方法体 } class Impl extends A { public void get() { System.out.println(“Hello MLDN .”) ; } } public class Test { public static void main(String args[]) { A a = new Impl() ; // 向上转型 a.print() ; // 自己类定义 a.get() ; // 子类负责实现 } } 通过以上的一个程序，现在就可以清楚的发现，与之前类的继承不一样的是，抽象类定义出了子类必须要覆写的方法，而之前的类子类可以有选择性的来决定是否需要覆写。而且可以发现，抽象类实际上就比普通类多了一些抽象方法而已，其他的定义和普通类完全一样。如果把普通类比喻成一盘炒熟的菜，那么抽象类就是一盘半成品。 关于抽象类的若干种疑问？ · 抽象类能否使用final定义？ 不能，因为抽象类必须有子类，final定义的类太监类，不能有子类； · 抽象类之中能否包含构造方法？ 可以，因为抽象类之中除了包含抽象方法之外，还包含了普通方法和属性，而属性一定要在构造方法执行完毕之后才可以进行初始化操作； · 抽象类之中能否不包含抽象方法？ 可以，抽象类之中可以没有抽象方法，但是反过来讲，如果有抽象方法，则一定是抽象类，即使抽象类之中没有抽象方法，也不能够被直接实例化； · 抽象类能否使用static声明？ abstract class A { private String info = “Hello World .” ; static abstract class B {// 外部类 public abstract void print() ; } } class Impl extends A.B { public void print() { System.out.println(“Hello MLDN .”) ; } } public class Test { public static void main(String args[]) { A.B b = new Impl() ; b.print() ; } } 如果定义的是外部抽象类，则不能够使用static声明，可是如果定义的是内部抽象类，那么这个内部的抽象类使用了static声明之后，就表示是一个外部的抽象类。 3.8.2、抽象类的应用 —— 模板设计模式（体会）下面首先通过一个简单的程序来分析一下，例如：现在有三种类型：狗、机器人、人； · 狗具备三种功能：吃、睡、跑； · 机器人具备两个功能：吃、工作； · 人具备四个功能：吃、睡、跑、工作。 现在就要求设计一个程序，可以让这三类不同的类型，进行工作。现在给出的三个类实际上并没有任何的联系，唯一的联系就是在于一些行为上。 abstract class Action { public static final int EAT = 1 ; public static final int SLEEP = 3 ; public static final int WORK = 5 ; public static final int RUN = 7 ; public void order(int flag) { switch (flag) { case EAT : this.eat() ; break ; case SLEEP: this.sleep() ; break ; case WORK : this.work() ; break ; case RUN : this.run() ; break ; case EAT + SLEEP + RUN : this.eat() ; this.sleep() ; this.run() ; break ; case EAT + WORK : this.eat() ; this.work() ; break ; case EAT + SLEEP + RUN + WORK : this.eat() ; this.sleep() ; this.run() ; this.work() ; break ; } } public abstract void eat() ; public abstract void sleep() ; public abstract void run() ; public abstract void work() ; } class Dog extends Action { public void eat() { System.out.println(“小狗在吃。”) ; } public void sleep() { System.out.println(“小狗在睡。”) ; } public void run() { System.out.println(“小狗在跑步。”) ; } public void work() {} } class Robot extends Action { public void eat() { System.out.println(“机器人喝油。”) ; } public void sleep() {} public void run() {} public void work() { System.out.println(“机器人在工作。”) ; } } class Person extends Action { public void eat() { System.out.println(“人在吃饭。”) ; } public void sleep() { System.out.println(“人在睡觉。”) ; } public void run() { System.out.println(“人在跑步。”) ; } public void work() { System.out.println(“人在工作。”) ; } } public class Test { public static void main(String args[]) { Action act1 = new Dog() ; act1.order(Action.EAT + Action.SLEEP + Action.RUN) ; Action act2 = new Robot() ; act2.order(Action.EAT + Action.WORK) ; } } 所有的子类如果要想正常的完成操作，必须按照指定的方法进行覆写才可以，而这个时候抽象类所起的功能就是一个类定义模板的功能。 3.9、接口（重点）3.9.1、接口的基本概念接口属于一种特殊的类，如果一个类定义的时候全部由抽象方法和全局常量所组成的话，那么这种类就称为接口，但是接口是使用interface关键字进行定义的。 interface A { // 定义接口 public static final String INFO = “Hello World .” ; public abstract void print() ; } interface B { public abstract void get() ; } 那么在接口之中，也同样存在了抽象方法，很明显，接口对象无法直接进行对象的实例化操作，那么接口的使用原则如下： · 每一个接口必须定义子类，子类使用implements关键字实现接口； · 接口的子类（如果不是抽象类）则必须覆写接口之中所定义的全部抽象方法； · 利用接口的子类，采用对象的向上转型方式，进行接口对象的实例化操作。 下面给出子类实现接口的语法格式： class 子类 [extends 父类] [implemetns 接口1,接口2,…] {} 通过格式可以发现，每一个子类可以同时实现多个接口，但是只能继承一个父类。 范例：让子类实现接口 interface A { // 定义接口 public static final String INFO = “Hello World .” ; public abstract void print() ; } interface B { public abstract void get() ; } class X implements A,B { // 同时实现了两个接口 public void print() { // 方法覆写 System.out.println(“Hello World .”) ; } public void get() { System.out.println(INFO) ; } } public class Test { public static void main(String args[]) { A a = new X() ; B b = new X() ; a.print() ; b.get() ; } } 那么如果一个类现在即要实现接口又要继承抽象类的话，则应该采用先继承后实现的方式完成。 interface A { // 定义接口 public static final String INFO = “Hello World .” ; public abstract void print() ; } interface B { public abstract void get() ; } abstract class C { public abstract void fun() ; } class X extends C implements A,B { // 同时实现了两个接口 public void print() { // 方法覆写 System.out.println(“Hello World .”) ; } public void get() { System.out.println(INFO) ; } public void fun() { System.out.println(“世界，你好！”) ; } } public class Test { public static void main(String args[]) { A a = new X() ; B b = new X() ; C c = new X() ; a.print() ; b.get() ; c.fun() ; } } 但是需要说明的是：接口之中的全部组成就是抽象方法和全局常量，那么在开发之中以下的两种定义接口的最终效果是完全一样的： 完整定义： 简化定义： interface A { // 定义接口 public static final String INFO = “Hello World .” ; public abstract void print() ; } interface A { // 定义接口 public String INFO = “Hello World .” ; public void print() ; } 接口之中的访问权限只有一种：public，即：定义接口方法的时候就算没有写上public，那么最终也是public。 在Java之中每一个抽象类都可以实现多个接口，但是反过来讲，一个接口却不能继承抽象类，可是Java之中，一个接口却可以同时继承多个接口，以实现接口的多继承操作。 interface A { public void printA() ; } interface B { public void printB() ; } interface C extends A,B { // 一个接口继承了多个接口 public void printC() ; } class X implements C { public void printA() {} public void printB() {} public void printC() {} } 而在开发之中，内部类是永远不会受到概念限制的，在一个类中可以定义内部类，在一个抽象类之中也可以定义抽象内部类，在一个接口里面也可以定义内部抽象类或内部接口，但是从实际的开发来讲，用户自己去定义内部抽象类或内部接口的时候是比较少见的（Android开发中见过内部接口），而且在定义内部接口的时候如果使用了static，表示是一个外部接口。 interface A { public void printA() ; static interface B { // 外部接口 public void printB() ; } } class X implements A.B { public void printB() { System.out.println(“Hello World .”) ; } } public class Test { public static void main(String args[]) { A.B temp = new X() ; temp.printB() ; } } 以上对于接口的概念并不是很难理解，但是需要强调的是，在实际的开发之中，接口有三大主要功能： · 制订操作标准； · 表示一种能力； · 将服务器端的远程方法视图暴露给客户端。 3.9.2、使用接口定义标准在日常的生活之中，接口这一名词经常听到的，例如：USB接口、打印接口、充电接口等等。 现在假设每一个USB设备只有两个功能：安装驱动程序、工作。 范例：定义出一个USB的标准 interface USB { // 操作标准 public void install() ; public void work() ; } 范例：在电脑上应用此接口 class Computer { public void plugin(USB usb) { usb.install() ; usb.work() ; } } 范例：定义USB设备 class Phone implements USB { public void install() { System.out.println(“安装手机驱动程序。”) ; } public void work() { System.out.println(“手机与电脑进行工作。”) ; } } 范例：定义USB设备 class Print implements USB { public void install() { System.out.println(“安装打印机驱动程序。”) ; } public void work() { System.out.println(“进行文件打印。”) ; } } 范例：连接 interface USB { // 操作标准 public void install() ; public void work() ; } class Computer { public void plugin(USB usb) { usb.install() ; usb.work() ; } } class Phone implements USB { public void install() { System.out.println(“安装手机驱动程序。”) ; } public void work() { System.out.println(“手机与电脑进行工作。”) ; } } class Print implements USB { public void install() { System.out.println(“安装打印机驱动程序。”) ; } public void work() { System.out.println(“进行文件打印。”) ; } } public class Test { public static void main(String args[]) { Computer c = new Computer() ; c.plugin(new Phone()) ; // USB usb = new Phone() ; c.plugin(new Print()) ; } } 按照这种方式开发下去的话，不管有多少个USB接口的子类，都可以在电脑上使用。 3.9.3、接口的实际作用 —— 工厂设计模式（Factory）下面首先来观察如下的程序代码。 interface Fruit { public void eat() ; } class Apple implements Fruit { public void eat() { System.out.println(“吃苹果。”) ; } } class Orange implements Fruit { public void eat() { System.out.println(“吃橘子。”) ; } } public class Test { public static void main(String args[]) { Fruit f = new Apple() ; f.eat() ; } } 本程序非常简单就是通过接口的子类为接口对象实例化，但是本操作存在什么样的问题呢？ 之前一直在强调，主方法或者是主类是一个客户端，客户端的操作应该越简单越好。但是现在的程序之中，有一个最大的问题：客户端之中，一个接口和一个固定的子类绑在一起了。 在本程序之中，最大的问题在于耦合上，发现在主方法之中，一个接口和一个子类紧密耦合在一起，这种方式比较直接，可以简单的理解为由：AB，但是这种紧密的方式不方便于维护，所以后来使用了A CB，中间经历了一个过渡，这样一来B去改变，C去改变，但是A不需要改变，就好比JAVA的JVM一样：程序JVM 操作系统。 范例：修改代码 interface Fruit { public void eat() ; } class Apple implements Fruit { public void eat() { System.out.println(“吃苹果。”) ; } } class Orange implements Fruit { public void eat() { System.out.println(“吃橘子。”) ; } } class Factory { public static Fruit getInstance(String className) { if (“apple”.equals(className)) { return new Apple() ; } if (“orange”.equals(className)) { return new Orange () ; } return null ; } } public class Test { public static void main(String args[]) { Fruit f = Factory.getInstance(args[0]) ; f.eat() ; } } 这个时候发现客户端不再和一个具体的子类耦合在一起了，就算以后增加了新的子类，那么只需要修改Factory类即可实现。 3.9.4、接口的实际作用 —— 代理设计模式（Proxy）张金宇的不幸人生。。。555555。 interface Subject { // 操作主题 public void get() ; // 要银子 } class RealSubject implements Subject { // 真正的要银子 public void get() { System.out.println(“真实业务主题”) ; } } class ProxySubject implements Subject { private Subject sub = null ; public ProxySubject(Subject sub) { this.sub = sub ; } public void prepare() { System.out.println(“准备操作。”) ; } public void destroy() { System.out.println(“收尾操作。”) ; } public void get() { this.prepare() ; this.sub.get() ; this.destroy() ; } } public class Test { public static void main(String args[]) { Subject sub = new ProxySubject(new RealSubject()) ; sub.get() ; } } 通过以上的分析就可以得出结论：代理负责完成与真实业务有关的所有辅助性操作。 3.9.5、抽象类和接口的区别（面试题）通过如上的分析，感觉抽象类和接口在使用上似乎区别不大，那么下面就通过一个表格给出这两者的区别。 （面试题：请解释抽象类和接口的区别？） No. 区别 抽象类 接口 1 定义关键字 abstract class interface 2 组成 常量、变量、抽象方法、普通方法、构造方法 全局常量、抽象方法 3 权限 可以使用各种权限 只能是public 4 关系 一个抽象类可以实现多个接口 接口不能够继承抽象类，却可以继承多接口 5 使用 子类使用extends继承抽象类 子类使用implements实现接口 抽象类和接口的对象都是利用对象多态性的向上转型，进行接口或抽象类的实例化操作 6 设计模式 模板设计模式 工厂设计模式、代理设计模式 7 局限 一个子类只能够继承一个抽象类 一个子类可以实现多个接口 通过上面的分析可以得出结论：在开发之中，抽象类和接口实际上都是可以使用的，并且使用那一个都没有明确的限制，可是抽象类有一个最大的缺点——一个子类只能够继承一个抽象类，存在单继承的局限，所以当遇到抽象类和接口都可以使用的情况下，优先考虑接口，避免单继承局限。 到此时已经学习过了：对象、类、抽象类、接口、继承、实现等等，这些都属于什么样的关系呢？ 接口就是在类的基础之上的进一步具体的抽象。 4、总结1、 继承性用于扩充类的功能； 2、 方法的覆写与对象多态性的联系； 3、 final关键字的使用； 4、 单例设计模式； 5、 对象的多态性，转型问题； 6、 抽象类和接口的概念； 7、 今天的三个设计模式（背下结构）：单例、工厂、代理。 5、预习任务匿名内部类、Object类、异常的捕获及处理、包及访问控制权限。 6、作业 No. 表达式 描述 1 2 3 4 5 6 7 8 9 No. 方法名称 类型 描述 1 2 3 4 5 6 7 8 9","categories":[],"tags":[]},{"title":"","slug":"面向对象_04","date":"2020-08-10T14:21:51.338Z","updated":"2020-08-10T14:13:30.501Z","comments":true,"path":"2020/08/10/mian-xiang-dui-xiang-04/","link":"","permalink":"https://kilitom.github.io/2020/08/10/mian-xiang-dui-xiang-04/","excerpt":"","text":"3.1、链表（理解） 链表是一种最基本的数据结构，但是对于数据结构的部分，强调以下几点： ·在整个Java开发领域之中，没有一本真正去讲解数据结构的书，只能去看C语言的数据结构； ·在所有的开发之中，都会存在数据结构的身影，可以这样去解释：数据结构的精通与否，完全决定于以后； · 数据结构的核心：引用数据类型操作。 3.1.1、链表的基本概念 链表实际上可以理解为一串数据，或者按照专业性的说法，可以理解为动态的对象数组，对象数组最大优点：是表示出多的概念，例如：多个雇员。但是传统的对象数组有一个最大的问题在于，里面保存的数据的长度是固定的。 思考：如果说现在要想扩大一个对象数组的范围？ ·建立一个新的对象数组，而后将原本的内容拷贝到新数组之中，再改变原数组的引用方式。 public class TestDemo { public static void main(String args[]) { String [] str = new String[] {“Hello”,”World”,”MLDN”} ; String [] newStr = new String[6] ; System.arraycopy(str,0,newStr,0,str.length) ; str = newStr ; // 改变引用，存在垃圾 str [3] = “你好” ; str [4] = “世界” ; for (int x = 0 ; x &lt; str.length ; x ++) { System.out.println(str[x]) ; } } } 通过以上的分析，可以发现，对象数组所有的对象元素被数组的索引控制，可以说是自动完成的控制，但是链表需要人为进行关系的设置，而且每个操作设置的时候，除了要保存“对象”之外，还要再多保留一个引用。 这个引用就和之前讲解的领导是一样的：一个雇员的领导还是雇员，雇员领导的领导也是雇员。 范例：先给出链表的基本操作结构 class Node { private String data ; // 假设要保存的数据类型是字符串 private Node next ; public Node(String data) { this.data = data ; } public String getData() { return this.data ; } public void setNext(Node next) { this.next = next ; } public Node getNext() { return this.next ; } } 范例：挂节点 public class TestDemo { public static void main(String args[]) { // 1、设置数据 Node n1 = new Node(“火车头”) ; Node n2 = new Node(“车厢A”) ; Node n3 = new Node(“车厢B”) ; n1.setNext(n2) ; n2.setNext(n3) ; // 2、取出数据 Node currentNode = n1 ; // 设置每一个当前节点 while(currentNode != null) { // 有节点存在 System.out.println(currentNode.getData()) ; // 当前节点内容 currentNode = currentNode.getNext() ; } } } 但是这样的方式来输出所有的节点的配置过程，发现并不是特别好，这种输出的操作，应该采用递归合适。 public class TestDemo { public static void main(String args[]) { // 1、设置数据 Node n1 = new Node(“火车头”) ; Node n2 = new Node(“车厢A”) ; Node n3 = new Node(“车厢B”) ; n1.setNext(n2) ; n2.setNext(n3) ; // 2、取出数据 print(n1) ; } public static void print(Node node) { // 取出节点内容 System.out.println(node.getData()) ; if (node.getNext() != null) { // 后面还有货 print(node.getNext()) ; // 向下 } } } 可以发现，整个一链表的关键是在于Node节点的关系匹配上。 3.1.2、链表的基本雏形 通过之前的分析，可以发现链表的最大作用的类就是Node，但是以上程序都是由用户自己去匹配节点关系的，但是这些节点的匹配工作不应该由用户完成，应该由一个程序专门负责。 那么专门负责这个节点操作的类，就称为链表类 ——Link，负责处理节点关系，而用户不需要关心节点问题，只需要关心Link的处理操作即可。 范例：开发Link类 class Node { private String data ; // 假设要保存的数据类型是字符串 private Node next ; public Node(String data) { this.data = data ; } public String getData() { return this.data ; } public void setNext(Node next) { this.next = next ; } public Node getNext() { return this.next ; } public void addNode(Node newNode) { // 操作的是节点关系 if (this.next == null) { // 当前节点的next为null this.next = newNode ; // 保存新节点 } else { this.next.addNode(newNode) ; } } public void printNode() { System.out.println(this.data) ; if (this.next != null) { // 还有下一个节点 this.next.printNode() ; } } } class Link { // 处理节点关系 private Node root ; // 根节点 public void add(String data) { // 处理数据保存 if (data == null) { // 没有数据 return ; // 直接返回 } // 每一个数据如果要想保存在链表之中，必须将其封装为节点 // 这一操作的过程外部（用户）不需要知道 Node newNode = new Node(data) ; if (this.root == null) { // 现在没有根节点 this.root = newNode ; // 第一个作为根节点 } else { this.root.addNode(newNode) ; } } public void print() { if (this.root != null) { // 现在有根节点 this.root.printNode() ; // Node类处理 } } } public class TestDemo { public static void main(String args[]) { Link all = new Link() ; all.add(“Hello”) ; all.add(“World”) ; all.add(“MLDN”) ; all.print() ; } } 通过以上的代码可以发现，Link类处理节点的操作，而Node类负责节点的具体顺序的操作，但是客户端，不关心节点，只关心Link类即可。 3.1.3、开发可用链表3.1.3.1、增加数据：public String add(数据 对象)通过上面的程序分析，可以发现，对于链表实现，Node类是整个操作的关键，但是首先来研究一下之前程序的问题：Node是一个单独的类，那么这样的类是可以被用户直接使用的，但是这个类由用户直接去使用，没有任何的意义，即：这个类有用，但是不能让用户去用，只能让Link类去使用，内部类完成。 class Link { // 用户唯一关注的是此类 // 使用内部类的最大好处是可以和外部类进行私有操作的互相访问 private class Node { // 处理节点关系 private String data ; // 要保存的数据 private Node next ; // 下一个节点 public Node(String data){ this.data = data ; } public void addNode(Node newNode) { // 增加节点 if (this.next == null) { // 当前节点之后没有节点 this.next = newNode ; // 保存新节点 } else { // 当前节点之后有节点了 this.next.addNode(newNode) ; // 向下继续判断 } } } private Node root ; // 根节点，第一个保存元素 public boolean add(String data) { // 增加数据 if (data == null) { // 如果保存的是一个空数据 return false ; // 增加失败 } // 将数据封装为节点，目的：节点有next可以处理关系 Node newNode = new Node(data) ; // 链表的关键就在于根节点 if (this.root == null) { // 现在没有根节点 this.root = newNode ; // 第一个作为根节点 } else { // 根节点有了，新的节点要保留在合适的位置 this.root.addNode(newNode) ; // Node类负责处理 } return true ; // 增加成功 } } 使用内部类可以发现比之前的代码要节省一些，而且访问也方便了。 3.1.3.2、增加多个数据：public boolean addAll(数据 对象 [] )以上的操作是每次增加了一个对象，那么如果现在要求增加多个对象呢，例如：增加对象数组。可以采用循环数组的方式，每次调用add()方法。 public boolean addAll(String data[]) { // 一组数据 for (int x = 0 ; x &lt; data.length ; x ++) { if (!this.add(data[x])) { // 保存不成功 return false ; } } return true ; } 3.1.3.3、统计数据个数：public int size()在一个链表之中，会保存多个数据（每一个数据都被封装为Node类对象），那么要想取得这些保存元素的个数，可以增加一个size()方法完成。 应该在Link类之中增加一个统计的属性：count： private int count ; // 统计个数 当用户每一次调用add()方法增加新数据的时候应该做出统计： public boolean add(String data) { // 增加数据 if (data == null) { // 如果保存的是一个空数据 return false ; // 增加失败 } // 将数据封装为节点，目的：节点有next可以处理关系 Node newNode = new Node(data) ; // 链表的关键就在于根节点 if (this.root == null) { // 现在没有根节点 this.root = newNode ; // 第一个作为根节点 } else { // 根节点有了，新的节点要保留在合适的位置 this.root.addNode(newNode) ; // Node类负责处理 } this.count ++ ; // 保存数据量增加 return true ; // 增加成功 } 而在size()方法就是简单的将count这个变量的内容返回： public int size() { return this.count ; } 3.1.3.4、判断是否是空链表：public boolean isEmpty()所谓的空链表指的是链表之中不保存任何的数据，实际上这个null可以通过两种方式判断：一种判断链表的根节点是否为null，另外一个是判断保存元素的个数是否为0。 public boolean isEmpty() { return this.count == 0 ; } 3.1.3.5、查找数据是否存在：public boolean contains(数据 对象)现在如果要想查询某个数据是否存在，那么基本的操作原理：逐个盘查，盘查的具体实现还是应该交给Node类去处理，但是在盘查之前必须有一个前提：有数据存在。 在Link类之中，增加查询的操作： public boolean contains(String data) { // 查找数据 // 根节点没有数据，查找的也没有数据 if (this.root == null || data == null) { return false ; // 不需要进行查找了 } return this.root.containsNode(data) ; // 交给Node类处理 } 在Node类之中，完成具体的查询，查询的流程： · 判断当前节点的内容是否满足于查询内容，如果满足返回true； · 如果当前节点的内容不满足，则向后继续查，如果已经没有后续节点了，则返回false。 public boolean containsNode(String data) { // 查找数据 if (data.equals(this.data)) { // 与当前节点数据吻合 return true ; } else { // 与当前节点数据不吻合 if (this.next != null) { // 还有下一个节点 return this.next.containsNode(data) ; } else { // 没有后续节点 return false ; // 查找不到 } } } 3.1.3.6、删除数据：public void remove(数据 对象)对于链表之中的内容，之前完成的是增加操作和查询操作，但是从链表之中也会存在删除数据的操作，可是删除数据的操作需要分两种情况讨论： · 情况一：删除的数据不是根节点，使用：要删除节点的上一个节点.next =要删除节点.next； · 情况二：删除的数据是根节点，根节点 = 根节点.next。 范例：修改Link类的删除操作 public void remove(String data) { // 要删除的节点 if (! this.contains(data)) { // 要删除的数据不存在 return ; // 直接返回被调用处，下面代码不执行了 } if (data.equals(this.root.data)) { // 要删除的是根节点 this.root = this.root.next ; // 根节点的下一个 } else { // 要删除的不是根节点 this.root.next.removeNode(this.root,data) ; } this.count – ; // 修改个数 } 范例：修改Node类的删除操作 // 传入两个参数：上一个节点，另外一个表示要删除的数据 public void removeNode(Node previous,String data) { if (this.data.equals(data)) { // 当前节点的数据吻合删除条件 previous.next = this.next ; // 空出当前节点 } else { this.next.removeNode(this,data) ; // 向后继续删除 } } 3.1.3.7、取出全部数据：public 数据 [] toArray()对于链表的这种数据结构，最为关键的是两个操作：删除、取得全部数据。 在Link类之中需要定义一个操作数组的脚标： private int foot = 0 ; // 操作返回数组的脚标 要把数据保存的数组，Link类和Node类都需要使用，那么可以在Link类中定义返回数组，必须以属性的形式出现，只有这样，Node类才可以访问这个数组并进行操作。 private String [] retData ; // 返回数组 在Link类之中增加toArray()的方法。 public String [] toArray() { if (this.count == 0) { return null ; // 没有数据 } this.foot = 0 ; // 清零 this.retData = new String [this.count] ; // 开辟数组大小 this.root.toArrayNode() ; return this.retData ; } 修改Node类的操作，增加toArrayNode()方法。 public void toArrayNode() { Link.this.retData[Link.this.foot ++] = this.data ; if (this.next != null) { this.next.toArrayNode() ; } } 不过，按照以上的方式进行开发，每一次调用toArray()方法，都要重复的进行数据的遍历，如果在数据没有修改的情况下，这种做法是一种非常差的做法，最好的做法是增加一个修改标记，如果发现数据增加了或删除的话，表示要重新遍历数据。 private boolean changeFlag = true ; // changeFlag == true：数据被更改了，则需要重新遍历 // changeFlag == false：数据没有更改，不需要重新遍历 当增加或删除数据的时候，这个标记必须要进行修改。 public String [] toArray() { if (this.count == 0) { return null ; // 没有数据 } this.foot = 0 ; // 清零 if (this.changeFlag == true) { // 内容被修改了，需要重新取 this.retData = new String [this.count] ; // 开辟数组大小 this.root.toArrayNode() ; } return this.retData ; } 3.1.3.8、根据索引位置取得数据：public 数据 get(int index)在一个链表之中会有多个节点保存数据，现在要求可以取得指定节点位置上的数据。但是在进行这一操作的过程之中，有一个小问题：如果要取得数据的索引超过了数据的保存个数，那么是无法取得的。 在Link类之中，增加一个get()方法。 public String get(int index) { if (index &gt; this.count) { // 超过个数 return null ; // 返回null } this.foot = 0 ; // 操作foot来定义脚标 return this.root.getNode(index) ; } 在Node类之中配置getNode()方法。 public String getNode(int index) { if (Link.this.foot ++ == index) { // 当前索引为查找数值 return this.data ; } else { return this.next.getNode(index) ; } } 3.1.3.9、清空链表：public void clear()所有的链表被root拽着，这个时候如果root为null，那么后面的数据都会断开，就表示都成了垃圾。 public void clear() { this.root = null ; this.count = 0 ; } 在整个程序之中，对于代码的开发部分不要求可以从无到有编写，但是需要清楚其操作原理，并且可以修改，而在整个链表工具类之中的方法： No. 方法名称 类型 描述 1 public String add(数据 对象) 普通 向链表之中增加一个数据 2 public boolean addAll(数据 对象 [] ) 普通 向链表之中增加一组数据 3 public int size() 普通 取得链表之中的元素个数 4 public boolean isEmpty() 普通 判断链表是否为空 5 public boolean contains(数据 对象) 普通 从链表之中查询数据，依靠对象比较 6 public void remove(数据 对象) 普通 从链表中删除数据，依靠对象比较 7 public 数据 [] toArray() 普通 将链表之中保存的数据以对象数组的方式返回 8 public 数据 get(int index) 普通 根据索引位置取得指定的对象 9 public void clear() 普通 清空链表 以上的九个方法的作用，一定要清楚。 3.1.4、保存多个对象之前的链表程序保存的都是String型数据，但是现在也可以是一个用户自己定义的类。 如果是自定义的类，那么一定要考虑到对象比较的方法，因为在链表之中的，contains()、remove()两个方法都调用了字符串内容的比较操作，而如果是一个自定义的Java类呢？需要编写compare()方法（对象比较）。 在之前学习了关系模型：dept –emp的操作，那么按照这个思路的话，链表可以针对于Emp使用，在一个部门有多个雇员，只要是多个就是对象数组，但是对象数组肯定以动态对象数组为主，那么一定就是链表的应用。 3.2、第四个代码模型的练习（重点） 重申：关于链表的掌握程度。 · 奢侈的想法：每个人可以自己独立的编写链表； · 实际的想法：可以使用链表，修改链表为自己的类型（类型、对象比较操作）。 3.2.1、第一道练习，一对多 商品表：名称、价格、描述。 class Link { // 用户唯一关注的是此类 // 使用内部类的最大好处是可以和外部类进行私有操作的互相访问 private class Node { // 处理节点关系 private Product data ; // 要保存的数据 private Node next ; // 下一个节点 public Node(Product data){ this.data = data ; } public void addNode(Node newNode) { // 增加节点 if (this.next == null) { // 当前节点之后没有节点 this.next = newNode ; // 保存新节点 } else { // 当前节点之后有节点了 this.next.addNode(newNode) ; // 向下继续判断 } } public boolean containsNode(Product data) { // 查找数据 if (data.compare(this.data)) { // 与当前节点数据吻合 return true ; } else { // 与当前节点数据不吻合 if (this.next != null) { // 还有下一个节点 return this.next.containsNode(data) ; } else { // 没有后续节点 return false ; // 查找不到 } } } // 传入两个参数：上一个节点，另外一个表示要删除的数据 public void removeNode(Node previous,Product data) { if (this.data.compare(data)) { // 当前节点的数据吻合删除条件 previous.next = this.next ; // 空出当前节点 } else { this.next.removeNode(this,data) ; // 向后继续删除 } } public void toArrayNode() { Link.this.retData[Link.this.foot ++] = this.data ; if (this.next != null) { this.next.toArrayNode() ; } } public Product getNode(int index) { if (Link.this.foot ++ == index) { // 当前索引为查找数值 return this.data ; } else { return this.next.getNode(index) ; } } } private Node root ; // 根节点，第一个保存元素 private int count = 0 ; // 统计个数 private int foot = 0 ; // 操作返回数组的脚标 private Product [] retData ; // 返回数组 private boolean changeFlag = true ; // changeFlag == true：数据被更改了，则需要重新遍历 // changeFlag == false：数据没有更改，不需要重新遍历 public boolean add(Product data) { // 增加数据 if (data == null) { // 如果保存的是一个空数据 return false ; // 增加失败 } // 将数据封装为节点，目的：节点有next可以处理关系 Node newNode = new Node(data) ; // 链表的关键就在于根节点 if (this.root == null) { // 现在没有根节点 this.root = newNode ; // 第一个作为根节点 } else { // 根节点有了，新的节点要保留在合适的位置 this.root.addNode(newNode) ; // Node类负责处理 } this.count ++ ; // 保存数据量增加 this.changeFlag = true ; // 被修改了 return true ; // 增加成功 } public boolean addAll(Product data[]) { // 一组数据 for (int x = 0 ; x &lt; data.length ; x ++) { if (!this.add(data[x])) { // 保存不成功 return false ; } } return true ; } public int size() { return this.count ; } public boolean isProductty() { return this.count == 0 ; } public boolean contains(Product data) { // 查找数据 // 根节点没有数据，查找的也没有数据 if (this.root == null || data == null) { return false ; // 不需要进行查找了 } return this.root.containsNode(data) ; // 交给Node类处理 } public void remove(Product data) { // 要删除的节点 if (! this.contains(data)) { // 要删除的数据不存在 return ; // 直接返回被调用处，下面代码不执行了 } if (data.equals(this.root.data)) { // 要删除的是根节点 this.root = this.root.next ; // 根节点的下一个 } else { // 要删除的不是根节点 this.root.next.removeNode(this.root,data) ; } this.changeFlag = true ; // 被修改了 this.count – ; // 修改个数 } public Product [] toArray() { if (this.count == 0) { return null ; // 没有数据 } this.foot = 0 ; // 清零 if (this.changeFlag == true) { // 内容被修改了，需要重新取 this.retData = new Product [this.count] ; // 开辟数组大小 this.root.toArrayNode() ; } return this.retData ; } public Product get(int index) { if (index &gt; this.count) { // 超过个数 return null ; // 返回null } this.foot = 0 ; // 操作foot来定义脚标 return this.root.getNode(index) ; } public void clear() { this.root = null ; this.count = 0 ; } } class ProductGroup { private int pgid ; private String title ; private String note ; private Link products = new Link(); public ProductGroup() {} public ProductGroup(int pgid,String title,String note) { this.pgid = pgid ; this.title = title ; this.note = note ; } public void setProducts(Link products) { this.products = products ; } public Link getProducts() { return this.products ; } public String getProductGroupInfo() { return “商品组编号：” + this.pgid + “，名称：” + this.title + “，描述：” + this.note ; } } class Product { private int pid ; private String title ; private double price ; private String note ; private ProductGroup group ; public Product(){} public Product(int pid,String title,double price,String note){ this.pid = pid ; this.title = title ; this.price = price ; this.note = note ; } public boolean compare(Product product) { if (this == product) { return true ; } if (product == null) { return false ; } if (this.pid == product.pid &amp;&amp; this.title.equals(product.title) &amp;&amp; this.price == product.price &amp;&amp; this.note.equals(product.note)) { return true ; } return false ; } public void setGroup(ProductGroup group) { this.group = group ; } public ProductGroup getGroup() { return this.group ; } public String getProductInfo() { return “商品编号：” + this.pid + “，名称：” + this.title + “，价格：” + this.price + “，描述：” + this.note ; } } public class TestDemo { public static void main(String args[]) { // 一层设置关系 ProductGroup group = new ProductGroup(1,”生活用品”,”你懂的。。。。”) ; group.getProducts().add(new Product(10,”毛巾”,1.0,”你懂的。”)) ; group.getProducts().add(new Product(11,”香皂”,1.5,”你懂的。”)) ; group.getProducts().add(new Product(12,”牙刷”,0.3,”你懂的。”)) ; System.out.println(group.getProductGroupInfo()) ; Product prod [] = group.getProducts().toArray() ; for (int x = 0 ; x &lt; prod.length ; x ++) { System.out.println(prod[x].getProductInfo()) ; } } } 3.2.2、第二道练习，一对多 要求1：根据一个用户找到他的所有定单； 要求2：根据一个定单找到其下单的用户； class Link { // 用户唯一关注的是此类 // 使用内部类的最大好处是可以和外部类进行私有操作的互相访问 private class Node { // 处理节点关系 private Orders data ; // 要保存的数据 private Node next ; // 下一个节点 public Node(Orders data){ this.data = data ; } public void addNode(Node newNode) { // 增加节点 if (this.next == null) { // 当前节点之后没有节点 this.next = newNode ; // 保存新节点 } else { // 当前节点之后有节点了 this.next.addNode(newNode) ; // 向下继续判断 } } public boolean containsNode(Orders data) { // 查找数据 if (data.compare(this.data)) { // 与当前节点数据吻合 return true ; } else { // 与当前节点数据不吻合 if (this.next != null) { // 还有下一个节点 return this.next.containsNode(data) ; } else { // 没有后续节点 return false ; // 查找不到 } } } // 传入两个参数：上一个节点，另外一个表示要删除的数据 public void removeNode(Node previous,Orders data) { if (this.data.compare(data)) { // 当前节点的数据吻合删除条件 previous.next = this.next ; // 空出当前节点 } else { this.next.removeNode(this,data) ; // 向后继续删除 } } public void toArrayNode() { Link.this.retData[Link.this.foot ++] = this.data ; if (this.next != null) { this.next.toArrayNode() ; } } public Orders getNode(int index) { if (Link.this.foot ++ == index) { // 当前索引为查找数值 return this.data ; } else { return this.next.getNode(index) ; } } } private Node root ; // 根节点，第一个保存元素 private int count = 0 ; // 统计个数 private int foot = 0 ; // 操作返回数组的脚标 private Orders [] retData ; // 返回数组 private boolean changeFlag = true ; // changeFlag == true：数据被更改了，则需要重新遍历 // changeFlag == false：数据没有更改，不需要重新遍历 public boolean add(Orders data) { // 增加数据 if (data == null) { // 如果保存的是一个空数据 return false ; // 增加失败 } // 将数据封装为节点，目的：节点有next可以处理关系 Node newNode = new Node(data) ; // 链表的关键就在于根节点 if (this.root == null) { // 现在没有根节点 this.root = newNode ; // 第一个作为根节点 } else { // 根节点有了，新的节点要保留在合适的位置 this.root.addNode(newNode) ; // Node类负责处理 } this.count ++ ; // 保存数据量增加 this.changeFlag = true ; // 被修改了 return true ; // 增加成功 } public boolean addAll(Orders data[]) { // 一组数据 for (int x = 0 ; x &lt; data.length ; x ++) { if (!this.add(data[x])) { // 保存不成功 return false ; } } return true ; } public int size() { return this.count ; } public boolean isOrdersty() { return this.count == 0 ; } public boolean contains(Orders data) { // 查找数据 // 根节点没有数据，查找的也没有数据 if (this.root == null || data == null) { return false ; // 不需要进行查找了 } return this.root.containsNode(data) ; // 交给Node类处理 } public void remove(Orders data) { // 要删除的节点 if (! this.contains(data)) { // 要删除的数据不存在 return ; // 直接返回被调用处，下面代码不执行了 } if (data.equals(this.root.data)) { // 要删除的是根节点 this.root = this.root.next ; // 根节点的下一个 } else { // 要删除的不是根节点 this.root.next.removeNode(this.root,data) ; } this.changeFlag = true ; // 被修改了 this.count – ; // 修改个数 } public Orders [] toArray() { if (this.count == 0) { return null ; // 没有数据 } this.foot = 0 ; // 清零 if (this.changeFlag == true) { // 内容被修改了，需要重新取 this.retData = new Orders [this.count] ; // 开辟数组大小 this.root.toArrayNode() ; } return this.retData ; } public Orders get(int index) { if (index &gt; this.count) { // 超过个数 return null ; // 返回null } this.foot = 0 ; // 操作foot来定义脚标 return this.root.getNode(index) ; } public void clear() { this.root = null ; this.count = 0 ; } } class User { private String userid ; private String password ; private String email ; private String mobile ; private int points ; private Link orders = new Link() ; public User() {} public User(String userid,String password,String email,String mobile,int points) { this.userid = userid ; this.password = password ; this.email = email ; this.mobile = mobile ; this.points = points ; } public void setOrders(Link orders) { this.orders = orders ; } public Link getOrders() { return this.orders ; } public String getUserInfo() { return “用户ID：” + this.userid + “，密码：” + this.password + “，email：” + this.email + “，电话：” + this.mobile + “，积分：” + this.points ; } } class Orders { private int oid ; private double allPrice ; private User user ; public Orders() {} public Orders(int oid,double allPrice) { this.oid = oid ; this.allPrice = allPrice ; } public void setUser(User user) { this.user = user ; } public User getUser() { return this.user ; } public boolean compare(Orders orders) { if (this == orders) { return true ; } if (orders == null) { return false ; } if (this.oid == orders.oid &amp;&amp; this.allPrice == orders.allPrice) { return true ; } return false ; } public String getOrdersInfo() { return “定单编号：” + this.oid + “，总价：” + this.allPrice ; } } public class TestDemo { public static void main(String args[]) { User user = new User(“mldn”,”nihao”,”mldnqa@163.com”,”110”,10) ; Orders o1 = new Orders(10,100.0) ; Orders o2 = new Orders(11,200.0) ; Orders o3 = new Orders(12,300.0) ; user.getOrders().add(o1) ; user.getOrders().add(o2) ; user.getOrders().add(o3) ; o1.setUser(user) ; o2.setUser(user) ; o3.setUser(user) ; System.out.println(user.getUserInfo()) ; System.out.println(user.getOrders().toArray()[0].getOrdersInfo()) ; System.out.println(user.getOrders().toArray()[0].getUser().getUserInfo()) ; }} 3.2.3、第三道练习，简单多对多（了解） 多对多的映射关系在开发之中是存在两种的： ·情况一：关系表之中，只存在关联字段，不存在任何的其他字段，留的题目属于简单多对多； · 情况二：关系表之中，存在着其他的操作字段，数据模型：一个学生可以参加多门课程，每门课程可以有多个学生参加，每个学生针对于每门课程有一个成绩，在关系表中存在了一个成绩字段； 多对多 = 两个一对多。 管理员-管理员组-权限，简单多对多； 要求1：根据一个管理员的信息可以找到这个管理员所在的所有管理员组，并且列出每个管理员组的权限； 要求2：根据一个管理员组可以列出这个管理员组的权限，以及所有的管理员； 要求3：根据一个权限可以找到具备此权限的所有管理员组，并且列出每个管理员组的所有管理员。 class AdminLink { // 用户唯一关注的是此类 // 使用内部类的最大好处是可以和外部类进行私有操作的互相访问 private class Node { // 处理节点关系 private Admin data ; // 要保存的数据 private Node next ; // 下一个节点 public Node(Admin data){ this.data = data ; } public void addNode(Node newNode) { // 增加节点 if (this.next == null) { // 当前节点之后没有节点 this.next = newNode ; // 保存新节点 } else { // 当前节点之后有节点了 this.next.addNode(newNode) ; // 向下继续判断 } } public boolean containsNode(Admin data) { // 查找数据 if (data.compare(this.data)) { // 与当前节点数据吻合 return true ; } else { // 与当前节点数据不吻合 if (this.next != null) { // 还有下一个节点 return this.next.containsNode(data) ; } else { // 没有后续节点 return false ; // 查找不到 } } } // 传入两个参数：上一个节点，另外一个表示要删除的数据 public void removeNode(Node previous,Admin data) { if (this.data.compare(data)) { // 当前节点的数据吻合删除条件 previous.next = this.next ; // 空出当前节点 } else { this.next.removeNode(this,data) ; // 向后继续删除 } } public void toArrayNode() { AdminLink.this.retData[AdminLink.this.foot ++] = this.data ; if (this.next != null) { this.next.toArrayNode() ; } } public Admin getNode(int index) { if (AdminLink.this.foot ++ == index) { // 当前索引为查找数值 return this.data ; } else { return this.next.getNode(index) ; } } } private Node root ; // 根节点，第一个保存元素 private int count = 0 ; // 统计个数 private int foot = 0 ; // 操作返回数组的脚标 private Admin [] retData ; // 返回数组 private boolean changeFlag = true ; // changeFlag == true：数据被更改了，则需要重新遍历 // changeFlag == false：数据没有更改，不需要重新遍历 public boolean add(Admin data) { // 增加数据 if (data == null) { // 如果保存的是一个空数据 return false ; // 增加失败 } // 将数据封装为节点，目的：节点有next可以处理关系 Node newNode = new Node(data) ; // 链表的关键就在于根节点 if (this.root == null) { // 现在没有根节点 this.root = newNode ; // 第一个作为根节点 } else { // 根节点有了，新的节点要保留在合适的位置 this.root.addNode(newNode) ; // Node类负责处理 } this.count ++ ; // 保存数据量增加 this.changeFlag = true ; // 被修改了 return true ; // 增加成功 } public boolean addAll(Admin data[]) { // 一组数据 for (int x = 0 ; x &lt; data.length ; x ++) { if (!this.add(data[x])) { // 保存不成功 return false ; } } return true ; } public int size() { return this.count ; } public boolean isAdminty() { return this.count == 0 ; } public boolean contains(Admin data) { // 查找数据 // 根节点没有数据，查找的也没有数据 if (this.root == null || data == null) { return false ; // 不需要进行查找了 } return this.root.containsNode(data) ; // 交给Node类处理 } public void remove(Admin data) { // 要删除的节点 if (! this.contains(data)) { // 要删除的数据不存在 return ; // 直接返回被调用处，下面代码不执行了 } if (data.equals(this.root.data)) { // 要删除的是根节点 this.root = this.root.next ; // 根节点的下一个 } else { // 要删除的不是根节点 this.root.next.removeNode(this.root,data) ; } this.changeFlag = true ; // 被修改了 this.count – ; // 修改个数 } public Admin [] toArray() { if (this.count == 0) { return null ; // 没有数据 } this.foot = 0 ; // 清零 if (this.changeFlag == true) { // 内容被修改了，需要重新取 this.retData = new Admin [this.count] ; // 开辟数组大小 this.root.toArrayNode() ; } return this.retData ; } public Admin get(int index) { if (index &gt; this.count) { // 超过个数 return null ; // 返回null } this.foot = 0 ; // 操作foot来定义脚标 return this.root.getNode(index) ; } public void clear() { this.root = null ; this.count = 0 ; } } class GroupLink { // 用户唯一关注的是此类 // 使用内部类的最大好处是可以和外部类进行私有操作的互相访问 private class Node { // 处理节点关系 private Group data ; // 要保存的数据 private Node next ; // 下一个节点 public Node(Group data){ this.data = data ; } public void addNode(Node newNode) { // 增加节点 if (this.next == null) { // 当前节点之后没有节点 this.next = newNode ; // 保存新节点 } else { // 当前节点之后有节点了 this.next.addNode(newNode) ; // 向下继续判断 } } public boolean containsNode(Group data) { // 查找数据 if (data.compare(this.data)) { // 与当前节点数据吻合 return true ; } else { // 与当前节点数据不吻合 if (this.next != null) { // 还有下一个节点 return this.next.containsNode(data) ; } else { // 没有后续节点 return false ; // 查找不到 } } } // 传入两个参数：上一个节点，另外一个表示要删除的数据 public void removeNode(Node previous,Group data) { if (this.data.compare(data)) { // 当前节点的数据吻合删除条件 previous.next = this.next ; // 空出当前节点 } else { this.next.removeNode(this,data) ; // 向后继续删除 } } public void toArrayNode() { GroupLink.this.retData[GroupLink.this.foot ++] = this.data ; if (this.next != null) { this.next.toArrayNode() ; } } public Group getNode(int index) { if (GroupLink.this.foot ++ == index) { // 当前索引为查找数值 return this.data ; } else { return this.next.getNode(index) ; } } } private Node root ; // 根节点，第一个保存元素 private int count = 0 ; // 统计个数 private int foot = 0 ; // 操作返回数组的脚标 private Group [] retData ; // 返回数组 private boolean changeFlag = true ; // changeFlag == true：数据被更改了，则需要重新遍历 // changeFlag == false：数据没有更改，不需要重新遍历 public boolean add(Group data) { // 增加数据 if (data == null) { // 如果保存的是一个空数据 return false ; // 增加失败 } // 将数据封装为节点，目的：节点有next可以处理关系 Node newNode = new Node(data) ; // 链表的关键就在于根节点 if (this.root == null) { // 现在没有根节点 this.root = newNode ; // 第一个作为根节点 } else { // 根节点有了，新的节点要保留在合适的位置 this.root.addNode(newNode) ; // Node类负责处理 } this.count ++ ; // 保存数据量增加 this.changeFlag = true ; // 被修改了 return true ; // 增加成功 } public boolean addAll(Group data[]) { // 一组数据 for (int x = 0 ; x &lt; data.length ; x ++) { if (!this.add(data[x])) { // 保存不成功 return false ; } } return true ; } public int size() { return this.count ; } public boolean isGroupty() { return this.count == 0 ; } public boolean contains(Group data) { // 查找数据 // 根节点没有数据，查找的也没有数据 if (this.root == null || data == null) { return false ; // 不需要进行查找了 } return this.root.containsNode(data) ; // 交给Node类处理 } public void remove(Group data) { // 要删除的节点 if (! this.contains(data)) { // 要删除的数据不存在 return ; // 直接返回被调用处，下面代码不执行了 } if (data.equals(this.root.data)) { // 要删除的是根节点 this.root = this.root.next ; // 根节点的下一个 } else { // 要删除的不是根节点 this.root.next.removeNode(this.root,data) ; } this.changeFlag = true ; // 被修改了 this.count – ; // 修改个数 } public Group [] toArray() { if (this.count == 0) { return null ; // 没有数据 } this.foot = 0 ; // 清零 if (this.changeFlag == true) { // 内容被修改了，需要重新取 this.retData = new Group [this.count] ; // 开辟数组大小 this.root.toArrayNode() ; } return this.retData ; } public Group get(int index) { if (index &gt; this.count) { // 超过个数 return null ; // 返回null } this.foot = 0 ; // 操作foot来定义脚标 return this.root.getNode(index) ; } public void clear() { this.root = null ; this.count = 0 ; } } class PrivilegeLink { // 用户唯一关注的是此类 // 使用内部类的最大好处是可以和外部类进行私有操作的互相访问 private class Node { // 处理节点关系 private Privilege data ; // 要保存的数据 private Node next ; // 下一个节点 public Node(Privilege data){ this.data = data ; } public void addNode(Node newNode) { // 增加节点 if (this.next == null) { // 当前节点之后没有节点 this.next = newNode ; // 保存新节点 } else { // 当前节点之后有节点了 this.next.addNode(newNode) ; // 向下继续判断 } } public boolean containsNode(Privilege data) { // 查找数据 if (data.compare(this.data)) { // 与当前节点数据吻合 return true ; } else { // 与当前节点数据不吻合 if (this.next != null) { // 还有下一个节点 return this.next.containsNode(data) ; } else { // 没有后续节点 return false ; // 查找不到 } } } // 传入两个参数：上一个节点，另外一个表示要删除的数据 public void removeNode(Node previous,Privilege data) { if (this.data.compare(data)) { // 当前节点的数据吻合删除条件 previous.next = this.next ; // 空出当前节点 } else { this.next.removeNode(this,data) ; // 向后继续删除 } } public void toArrayNode() { PrivilegeLink.this.retData[PrivilegeLink.this.foot ++] = this.data ; if (this.next != null) { this.next.toArrayNode() ; } } public Privilege getNode(int index) { if (PrivilegeLink.this.foot ++ == index) { // 当前索引为查找数值 return this.data ; } else { return this.next.getNode(index) ; } } } private Node root ; // 根节点，第一个保存元素 private int count = 0 ; // 统计个数 private int foot = 0 ; // 操作返回数组的脚标 private Privilege [] retData ; // 返回数组 private boolean changeFlag = true ; // changeFlag == true：数据被更改了，则需要重新遍历 // changeFlag == false：数据没有更改，不需要重新遍历 public boolean add(Privilege data) { // 增加数据 if (data == null) { // 如果保存的是一个空数据 return false ; // 增加失败 } // 将数据封装为节点，目的：节点有next可以处理关系 Node newNode = new Node(data) ; // 链表的关键就在于根节点 if (this.root == null) { // 现在没有根节点 this.root = newNode ; // 第一个作为根节点 } else { // 根节点有了，新的节点要保留在合适的位置 this.root.addNode(newNode) ; // Node类负责处理 } this.count ++ ; // 保存数据量增加 this.changeFlag = true ; // 被修改了 return true ; // 增加成功 } public boolean addAll(Privilege data[]) { // 一组数据 for (int x = 0 ; x &lt; data.length ; x ++) { if (!this.add(data[x])) { // 保存不成功 return false ; } } return true ; } public int size() { return this.count ; } public boolean isPrivilegety() { return this.count == 0 ; } public boolean contains(Privilege data) { // 查找数据 // 根节点没有数据，查找的也没有数据 if (this.root == null || data == null) { return false ; // 不需要进行查找了 } return this.root.containsNode(data) ; // 交给Node类处理 } public void remove(Privilege data) { // 要删除的节点 if (! this.contains(data)) { // 要删除的数据不存在 return ; // 直接返回被调用处，下面代码不执行了 } if (data.equals(this.root.data)) { // 要删除的是根节点 this.root = this.root.next ; // 根节点的下一个 } else { // 要删除的不是根节点 this.root.next.removeNode(this.root,data) ; } this.changeFlag = true ; // 被修改了 this.count – ; // 修改个数 } public Privilege [] toArray() { if (this.count == 0) { return null ; // 没有数据 } this.foot = 0 ; // 清零 if (this.changeFlag == true) { // 内容被修改了，需要重新取 this.retData = new Privilege [this.count] ; // 开辟数组大小 this.root.toArrayNode() ; } return this.retData ; } public Privilege get(int index) { if (index &gt; this.count) { // 超过个数 return null ; // 返回null } this.foot = 0 ; // 操作foot来定义脚标 return this.root.getNode(index) ; } public void clear() { this.root = null ; this.count = 0 ; } } class Admin { private String adminid ; private String password ; private GroupLink groups = new GroupLink() ; public Admin() {} public Admin(String adminid,String password) { this.adminid = adminid ; this.password = password ; } public GroupLink getGroups() { return this.groups ; } public String getAdminInfo() { return “管理员ID：” + this.adminid + “，密码：” + this.password ; } public boolean compare(Admin admin) { if (this == admin) { return true ; } if (admin == null) { return false ; } if (this.adminid.equals(admin.adminid) &amp;&amp; this.password.equals(admin.password)) { return true ; } return false ; } } class Group { private int groupid ; private String title ; private String note ; private AdminLink admins = new AdminLink() ; private PrivilegeLink privileges = new PrivilegeLink() ; public Group() {} public Group(int groupid,String title,String note) { this.groupid = groupid ; this.title = title ; this.note = note ; } public AdminLink getAdmins() { return this.admins ; } public PrivilegeLink getPrivileges() { return this.privileges ; } public String getGroupInfo() { return “管理员组ID：” + this.groupid + “，名称：” + this.title + “，描述：” + this.note ; } public boolean compare(Group group) { if (this == group) { return true ; } if (group == null) { return false ; } if (this.groupid == group.groupid &amp;&amp; this.title.equals(group.title) &amp;&amp; this.note.equals(group.note)) { return true ; } return false ; } } class Privilege { private int pid ; private String title ; private String note ; private GroupLink groups = new GroupLink() ; public Privilege() {} public Privilege(int pid,String title,String note) { this.pid = pid ; this.title = title ; this.note = note ; } public GroupLink getGroups() { return this.groups ; } public String getPrivilegeInfo() { return “权限ID：” + this.pid + “，名称：” + this.title + “，描述：” + this.note ; } public boolean compare(Privilege privilege) { if (this == privilege) { return true ; } if (privilege == null) { return false ; } if (this.pid == privilege.pid &amp;&amp; this.title.equals(privilege.title) &amp;&amp; this.note.equals(privilege.note)) { return true ; } return false ; } } public class TestDemo { public static void main(String args[]) { // 一层配置关系 Admin adminA = new Admin(“admininstrator”,”admin”) ; Admin adminB = new Admin(“hello”,”hello”) ; Admin adminC = new Admin(“jijiyiyi”,”jy”) ; Admin adminD = new Admin(“yushi”,”yushi”) ; Admin adminE = new Admin(“world”,”world”) ; Group groupA = new Group(10,”超级管理员组”,”你懂的。”) ; Group groupB = new Group(11,”系统维护管理员组”,”你懂的。”) ; Group groupC = new Group(12,”信息发布管理员组”,”你懂的。”) ; Privilege p1 = new Privilege(101,”增加管理员”,”-“) ; Privilege p2 = new Privilege(102,”增加用户”,”-“) ; Privilege p3 = new Privilege(103,”权限分配”,”-“) ; Privilege p4 = new Privilege(104,”增加新闻”,”-“) ; Privilege p5 = new Privilege(105,”生成统计报表”,”-“) ; Privilege p6 = new Privilege(106,”删除用户”,”-“) ; Privilege p7 = new Privilege(107,”评论维护”,”-“) ; Privilege p8 = new Privilege(108,”修改新闻”,”-“) ; Privilege p9 = new Privilege(109,”审核发布”,”-“) ; // 配置管理员和管理员组关系 adminA.getGroups().add(groupA) ; adminA.getGroups().add(groupB) ; adminB.getGroups().add(groupA) ; adminB.getGroups().add(groupB) ; adminB.getGroups().add(groupC) ; adminC.getGroups().add(groupA) ; adminC.getGroups().add(groupC) ; adminD.getGroups().add(groupB) ; adminE.getGroups().add(groupB) ; groupA.getAdmins().add(adminA) ; groupA.getAdmins().add(adminB) ; groupA.getAdmins().add(adminC) ; groupB.getAdmins().add(adminA) ; groupB.getAdmins().add(adminB) ; groupB.getAdmins().add(adminD) ; groupB.getAdmins().add(adminE) ; groupC.getAdmins().add(adminB) ; groupC.getAdmins().add(adminC) ; // 配置管理员组和权限 groupA.getPrivileges().add(p1) ; groupA.getPrivileges().add(p2) ; groupA.getPrivileges().add(p3) ; groupA.getPrivileges().add(p4) ; groupA.getPrivileges().add(p5) ; groupB.getPrivileges().add(p1) ; groupB.getPrivileges().add(p2) ; groupB.getPrivileges().add(p3) ; groupB.getPrivileges().add(p4) ; groupB.getPrivileges().add(p5) ; groupB.getPrivileges().add(p6) ; groupB.getPrivileges().add(p7) ; groupB.getPrivileges().add(p8) ; groupB.getPrivileges().add(p9) ; groupC.getPrivileges().add(p4) ; groupC.getPrivileges().add(p5) ; groupC.getPrivileges().add(p6) ; groupC.getPrivileges().add(p7) ; groupC.getPrivileges().add(p8) ; groupC.getPrivileges().add(p9) ; p1.getGroups().add(groupA) ; p1.getGroups().add(groupB) ; p2.getGroups().add(groupA) ; p2.getGroups().add(groupB) ; p3.getGroups().add(groupA) ; p3.getGroups().add(groupB) ; p4.getGroups().add(groupA) ; p4.getGroups().add(groupB) ; p4.getGroups().add(groupC) ; p5.getGroups().add(groupA) ; p5.getGroups().add(groupB) ; p5.getGroups().add(groupC) ; p6.getGroups().add(groupB) ; p6.getGroups().add(groupC) ; p7.getGroups().add(groupB) ; p7.getGroups().add(groupC) ; p8.getGroups().add(groupB) ; p8.getGroups().add(groupC) ; p9.getGroups().add(groupB) ; p9.getGroups().add(groupC) ; // 要求1：根据一个管理员的信息可以找到这个管理员所在的所有管理员组，并且列出每个管理员组的权限； { System.out.println(adminA.getAdminInfo()) ; Group group [] = adminA.getGroups().toArray() ; for (int x = 0 ; x &lt; group.length ; x ++) { System.out.println(“\\t〖管理员组〗” + group[x].getGroupInfo()) ; Privilege pri [] = group[x].getPrivileges().toArray() ; for (int y = 0 ; y &lt; pri.length ; y ++) { System.out.println(“\\t\\t【权限】” + pri[y].getPrivilegeInfo()) ; } } System.out.println(“**************************************************************************“) ; } // 要求2：根据一个管理员组可以列出这个管理员组的权限，以及所有的管理员； { System.out.println(groupA.getGroupInfo()) ; Admin admin [] = groupA.getAdmins().toArray() ; for (int x = 0 ; x &lt; admin.length ; x ++) { System.out.println(“\\t〖管理员〗” + admin[x].getAdminInfo()) ; } Privilege pri [] = groupA.getPrivileges().toArray() ; for (int x = 0 ; x &lt; pri.length ; x ++) { System.out.println(“\\t【权 限】” + pri[x].getPrivilegeInfo()) ; } System.out.println(“**************************************************************************“) ; } // 要求3：根据一个权限可以找到具备此权限的所有管理员组，并且列出每个管理员组的所有管理员。 { System.out.println(p3.getPrivilegeInfo()) ; Group group [] = p3.getGroups().toArray() ; for (int x = 0 ; x &lt; group.length ; x ++) { System.out.println(“\\t〖管理员组〗” + group[x].getGroupInfo()) ; Admin admin [] = group[x].getAdmins().toArray() ; for (int y = 0 ; y &lt; admin.length ; y ++) { System.out.println(“\\t\\t【管理员】” + admin[y].getAdminInfo()) ; } } } } } 4、总结 1、 链表可以不会，但是必须会使； 2、 链表这个数据结构的增加、和输出操作必须会； 3、 数据模型的建立，第四个代码模型的完善。 5、预习任务 继承、final关键字、方法覆写、对象多态性、抽象类和接口。","categories":[],"tags":[]},{"title":"","slug":"Eclipse开发工具","date":"2020-08-10T14:21:51.322Z","updated":"2020-08-10T14:10:27.379Z","comments":true,"path":"2020/08/10/eclipse-kai-fa-gong-ju/","link":"","permalink":"https://kilitom.github.io/2020/08/10/eclipse-kai-fa-gong-ju/","excerpt":"","text":"3、具体内容 Eclipse本身是一个工具，但是对于开发工具，个人认为：程序代码会写了，再去使工具。 3.1、Eclipse历史 Eclipse中文翻译为日蚀，指的是吞没一切的光芒，那么这个极其具备挑衅意味的名字实际上是针对于SUN公司。在2000年之后一直处于互联网低潮，而SUN公司自从这一低潮之后就再也没有起来过，而后SUN公司最为尴尬的事，他在硬件上没有过多的收益，而且软件的编程语言Java也不是SUN的赚钱工具，它只是变成了一个出卖版权的公司了。 对于Java的IDE（集成开发环境）本身也是经过了一些历史的调整： ·1995年的时候，Java诞生，但是SUN公司却高调宣布，我们自己不生成IDE，给其他第三方公司生产； · 在Java产生之后，Borland公司开始入手Java的IDE生产，所以后来的JBuilder就成为了Java开发的唯一选择（不选择JBuilder都使用记事本，IDEA、JCREATOR、EDITPLUS…），后来一直到了JBuilder X之后才正常； · 2003年之后有了Eclipse，在2004年之后有了SUN自己的开发工具 —— NetBeans。 而从整个国内的Java开发模式上也一直在发生着改变： · 豪华级架构：操作系统 + 数据库 + 中间件 + 开发工具； |- IBM体系：AIX + IBM DB2 + Websphere Application Server + WSAD； |- 超级杂牌军体系：UNIX + Oracle + BEA WebLogic + JBuilder； · 免费架构：Linux + MySQL + Tomcat / JBoss + Eclipse； 而对于开发工具最早的霸主就是JBuilder，但是遗憾的是，在2006年的时候Borland倒闭了，倒闭的原因是因为没有赶上所谓的开源风潮，因为有许多的学习者，他可能并不需要如此专业的工具，所以当时Borland公司的市场就出现了问题，于是倒闭就成为了显示，最后Borland技术部单独成立了一家技术公司，继续从事于JBuilder的研究，但是今天的JBuilder已经基本上无法去问津了，完全被Eclipse取代了。 Eclipse是由IBM开发的，之后将其转送给了今天的Eclipse组织，进行开源项目的推广，而Eclipse的前身是IBMVisualAge，而后IBM根据Eclipse的1.0模型，产生后来的WSAD开发工具，Eclipse本身是免费的，但是其是靠插件收费（中国连插件都不需要收费），其本身有以下几个基本组成：JDT、JUNIT测试工具、CVS客户端、插件开发。用户可以直接登陆“www.eclipse.org”下载Eclipse的最新版，JUNO（朱诺，小行星的名字）版，而且Eclipse现在可以直接解压缩后使用，不再需要单独啊安装，是一个纯粹的绿色版。 分析原因：可能是由于电脑上本身存在了Oracle，所以Eclipse找不到正确该使用的JDK1.7，那么现在可以在环境属性之中增加一个JAVA_HOME环境属性，让其定义在JDK的安装目录。 此时很郁闷的是，Eclipse有一个bug，也许以后可以解决。在eclipse的安装目录下有一个eclipse.ini的文件，修改一下，把256修改为128。 -startup plugins/org.eclipse.equinox.launcher_ 1.3.0 .v20120522-1813.jar –launcher.library plugins/org.eclipse.equinox.launcher.win32.win32.x86_1.1.200.v20120522-1813 -product org.eclipse.epp.package.java.product –launcher.defaultAction openFile –launcher.XXMaxPermSize 128M -showsplash org.eclipse.platform –launcher.XXMaxPermSize 128m –launcher.defaultAction openFile -vmargs -Dosgi.requiredJavaVersion=1.5 -Dhelp.lucene.tokenizer=standard -Xms 40m -Xmx 512m Eclipse启动之后，会出现一个对话框，这个对话框的主要目的是询问是否建立一个项目的工作区，在Eclipse之中，每一个工作区之中可以包含多个Java项目。 现在将工作区建立在d:\\myeclipsews目录之中。 3.2、JDT使用 启动了Eclipse之后，下面建立一个新的Java项目：MyJavaProject。 之后输入的项目名称：MyJavaProject。 当Java项目建立完成之后，可以在项目的目录下发现两个文件夹： · src：是保存所有的*.java程序，都是按照包名称进行保存的； · bin：保存所有生成的*.class文件，按照包名称进行保存的。 下面建立一个新的类：TestDemo.java。 使用Eclipse本身最大的好处是在于方便的进行随笔提示，并且在每一次*.java程序保存的时候，会由Eclipse自动的将其编译为*.class文件。 另外在Eclipse之中还可以存在一些代码的生成工具，例如：现在有如下一个简单的类： package cn.mldn.vo; public class Person { private String name ; private int age ; } 这个类肯定是作为简单Java类出现，那么现在很明显简单Java类的开发原则： · 所有属性封装，已经封装； · 生成setter、getter方法，〖Source〗 〖生成getter和setter方法〗 · 构造方法，必须要有无参构造，〖Source〗 生成构造方法。 · 覆写Object类之中的一些操作方法，〖Source〗 〖覆写或实现方法〗。 或则使用JUNO版的新功能，自动生成toString()； 不过，除了以上的生成方式，还可以通过快捷键生成代码。 · ALT + /：代码自动补充提示； · CTRL + 1：进行错误代码纠正提示； · CTRL + D：删除当前行代码； · CTRL + SHIFT + O：组织导入所需要的包.类； · CTRL + SHIFT + F：格式化代码显示； · CTRL + /：注释或者取消注释当前行代码； · CTRL + SHIFT + L：所有快捷键列表； · CTRL + H：强搜索代码； 项目也可以进行删除操作，但是在删除项目的时候有两种方式： · 方式一：是从项目的工作区之中删除项目，以后可以恢复； · 方式二：彻底从硬盘上删除项目，彻底删除。 如果要想导入一个项目，则可以使用导入的方式完成。 之后选择项目文件所在的路径。 以上是通过导入的方式完成了项目的导入，而现在也可以利用导出的方式，将一个项目之中的所有*.class文件自动生成*.jar文件。 但是如果一个项目之中，需要使用其他的jar包的话，那么不能依靠之前的classpath配置，需要在Eclipse之中单独配置jar包，找到项目属性的构建路径完成。 在Eclipse之中，为了方便用户的开发，还提供了DEBUG功能，可以利用此功能进行项目的调试操作，而如果要想进行调试，那么首先需要设置断点：断点指的是程序执行到此处的时候，自动停止，而后交由人工控制执行。 范例：定义要调试的程序 package cn.mldn.demo; class TestMath { public static int div(int x, int y) throws Exception { int result = 0; result = x / y; return result; } } public class TestDemo { public static void main(String[] args) throws Exception { int tempX = 10; int tempY = 2; int res = TestMath.div(tempX, tempY); // 在此行的左边空栏上双击鼠标左键 System.out.println(“计算结果：” + res); } } 这个时候会自动的出现一个断点（Blue Point），而后以Debug的方式启动程序。 随后会出现一个信息提示，询问：是否要切换到调试视图上，选择“yes”，进入到调试视图。 进入到调试视图之后，可以通过以下的四个方式进行代码调试： · 单步跳入（F5）：进入到代码之中，观察代码的执行； · 单步跳过（F6）：不关心代码之中的执行，只关心最终的结果； · 单步返回（F7）：返回到单步跳过的状态； · 恢复执行（F8）：不再调试，直接将程序运行完成。 在每一个Java程序运行的时候都可以设置一些初始化的配置参数，Eclipse也可以，但是麻烦一些，例如：下面建立一个新的类：PrintParam package cn.mldn.demo; public class PrintParam { public static void main(String[] args) { for (int x = 0; x &lt; args.length; x++) { System.out.println(args[x]); } } } 如果要想配置初始化参数，则进入到运行时配置，可是如果要想真正配置，必须保证要配置的程序先执行一次。 3.3、JUNIT测试工具 软件测试行业：2003年 ~2006年之间，各个公司一直都在招聘软件测试人员，而且都是外包到IBM或微软的公司进行测试。但是，看今天的软件测试来讲，这个行业已经很难了。 软件测试是一个黄金职位，对于软件测试是需要有一套完整测试理论和数据设计的，而如果学习过软件工程应该知道软件测试分为两类： ·黑盒测试：主要是测试功能，例如一些xx版，是不接触代码的，但是公司会提供测试工具； · 白盒测试：指的性能测试，或者是算法调整。 而这几年随着行业的发展，实际上又给出了一种新的测试职位 —— UseCase（用例）测试工程师，对于这种职位而言，国内的平均待遇是程序员的3~5倍，如果按照正常的一个程序员的工资是8000来算，那么这种人的平均月薪就是：2~ 5W，但是人很难找。一般而言，此类人员在行业之中需要具备8 ~10年的项目经验，并且精通业务。 一般而言，年龄在28岁以下的人员，找工作都是凭着技术，而业务是随着项目走的，28岁~35岁之间，干代码是可以干，但是基本上拼不起了，30岁之后你靠的行业业务和管理能力。 JUNIT是一个比较常用的测试工具，专门可以进行UseCase测试的，在日后所开发的程序里面都要写大量的JUNIT测试程序。 范例：定义要测试的程序 package cn.mldn.util; public class MyMath { public static int add(int x, int y) { return x + y; } public static int sub(int x, int y) { return x - y; } public static int mul(int x, int y) { return x * y; } public static int div(int x, int y) { return x / y; } } 下面如果要想测试的话，则需要建立一个新的JUNIT测试端。 建立JUNIT测试的时候有两种形式： · JUNIT Test Case：表示一个测试用例，主要完成一个业务的测试； · JUNIT Test Suite：一组测试用例，包含了多个Test Case。 由于JUNIT属于第三方的程序包，那么在使用的时候需要配置相关的*.jar文件，此处会提示用户是否需要自动进行配置，选择OK即可。 范例：编写测试程序 package cn.mldn.util; import junit.framework.TestCase; import org.junit.Test; public class MyMathTest { @Test public void testAdd() { TestCase.assertEquals(MyMath.add(10, 20), 30); } @Test public void testSub() { TestCase.assertEquals(MyMath.sub(20, 10), 10); } @Test public void testMul() { TestCase.assertEquals(MyMath.mul(20, 10), 200); } @Test public void testDiv() { TestCase.assertEquals(MyMath.div(20, 10), 2); } } 对于JUNIT的测试结果来讲，一共分为两类： · GREEN BAR：测试通过； · RED BAR：测试失败。 在日后的所有开发之中，一定要进行程序的分层，其中业务层的测试工具就通过JUNIT完成，包括日后学习课程之中，也一样要编写测试用例。 工具本身不麻烦，难就难在，如何编写测试用例，数据如何设计？ 项目经理只管理三个原则：时间、成本、利润。 正常思路：付先生的一生 · 21 ~ 22岁大学毕业：小工（开发团队：5个人，PM，老大，带着几个小工）； · 23 ~25岁之后：如果在一个公司时间长了，慢慢成为主力了，当组长，半个老大，带领新人开发； · 25 ~ 26岁之后：如果有一定的管理能力、有一定的文档能力，当个PM； · 26 ~ 30岁之间，积累业务能力，同时阔宽人脉； · 30岁之后靠你的业务能力存活。 4、总结 1、 Eclipse傻子才不会； 2、 JUNIT不是关键，关键是业务。 5、预习任务 JDK 1.5的新特性、多线程。 6、作业 1、 把六个开发模型都熟悉一遍； 2、 总结问题。","categories":[],"tags":[]},{"title":"","slug":"DAO设计模式","date":"2020-08-10T14:21:51.322Z","updated":"2020-08-10T14:10:02.991Z","comments":true,"path":"2020/08/10/dao-she-ji-mo-shi/","link":"","permalink":"https://kilitom.github.io/2020/08/10/dao-she-ji-mo-shi/","excerpt":"","text":"3、具体内容 之前的所有内容都在本处进行总结，而且对于之前的一些概念不清楚的东西（代码会写）那么都可以不用去看了，把本次程序弄会了，一切就都会了，后面也就都会了。 3.1、程序分层（理解） 在一个完整的项目之中，对程序进行合理的分层，可以让开发变得更加的方便，也更加的具备层次感，每一层有每一层的开发人员，例如：可以简单的理解为美工 程序相分离。而实际上的分层操作，可以这样参考： 如果按照含金量来讲，首先把握住业务层是整个程序的实现关键，但是对于前台显示更加的重要。今天的主要任务是观察业务层和数据层的开发，而到了JavaWEB之后，才开始实现显示层和控制层的开发。 在项目之中后台的建立直接有着重要的地位，但是不同层之间最为重要的连接组成部分就是接口，所以整个代码开发之中，对于后台代码就一定要有两个组成接口（业务层接口，给以后的控制层使用、数据层接口，给以后的业务层使用）。 · 数据层（数据访问层，Data AccessObject）：指的是执行数据的具体操作，而现在的开发之中，大多数都是针对于数据库的开发，所以在数据层之中的主要任务是负责完成数据的CRUD，而在java之中，如果要想进行数据的CRUD实现，肯定使用java.sql.PreparedStatement接口； · 业务层（业务对象，BusinessObject，BO，又或者将其称为Service，服务层），服务层的主要目的是根据业务需求进行数据层的操作，一个业务层要包含多个数据层的操作。 清楚了基本概念之后，那么新的问题就该出现了，如何去区分业务层或者是数据层？下面以玉史先生吃饭为例，说明一下。 如果说现在某一个项目业务非常复杂，可能分为若干个子业务，那么就还需要一个总的业务层操作。 3.2、实例分析（重点） 下面以emp数据表（empno、ename、job、hiredate、sal、comm，都是基本字段）为例分析一个操作，客户要求可以实现如下的几个功能： · 【业务层】增加一个新雇员信息； |- 〖数据层〗要根据增加的雇员编号查看此雇员是否存在； |- 〖数据层〗如果雇员不存在则执行插入操作，如果存在则不插入； · 【业务层】修改一个雇员的信息； |- 〖数据层〗直接传入新的数据即可，如果没有修改返回的更新行数是0； · 【业务层】删除一个雇员的信息； |- 〖数据层〗直接传入要删除的雇员编号即可，如果没有此雇员信息返回的是0； · 【业务层】根据编号查询一个雇员的信息； |- 〖数据层〗返回一个雇员的完整信息； · 【业务层】取得全部雇员的信息，要求可以实现模糊查询和分页显示，查询结果除了返回数据之外，还要求知道模糊或全部查询时所返回的全部数据量： |- 〖数据层〗模糊或查询全部满足条件的雇员数据，多个数据； |- 〖数据层〗使用COUNT()进行满足条件的数据统计。 3.3、准备阶段（重点） 3.3.1、VO类：负责数据的传输与包装 但是现在有一个最为严重的问题出现了，不同层之间（这些层除了数据层要操作SQL之外，那么其他层操作的数据都应该是对象），所以应该有一个负责传输的数据对象，这个对象可以称为ValueObject（VO，POJO、TO、PO）。 但是，现在对于简单Java类的开发原则也发生了一些变化： · 类名称要和表名称保持一致； · 为了日后类的操作方便，所有的简单Java类必须实现java.io.Serializable接口； · 类中不允许出现任何的基本数据类型，只能使用包装类； · 类之中的所有属性都必须封装，必须都编写setter、getter； · 类之中一定要提供有无参构造方法。 在DAO的开发之中，所有的名称都有严格规定，假设现在的项目的总包名称为：cn.mldn.oracle，那么现在这个VO类的保存包名称就应该是cn.mldn.oracle.vo。 范例：定义cn.mldn.oracle.vo.Emp类 package cn.mldn.oracle.vo; import java.io.Serializable; import java.util.Date; @SuppressWarnings(“serial”) public class Emp implements Serializable { private Integer empno ; private String ename ; private String job ; private Date hiredate ; private Double sal ; private Double comm ; // setter、getter略，自己补充 } 3.3.2、DatabaseConnection类：负责数据库连接 既然现在要完成数据层的开发，那么就一定需要数据库的连接与关闭操作，可是如果将数据库的连接和关闭都写在每一个数据层之中，这样代码过于重复，而且也不方便维护，那么为了方便起见，现在定义一个DatabaseConnection的类，这个类专门负责取得和关闭数据库连接。而这个类定义在cn.mldn.oracle.dbc包之中。 范例：定义cn.mldn.oracle.dbc.DatabaseConnection package cn.mldn.oracle.dbc; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; /** * 本类的主要功能是负责数据库的连接与关闭的 * @author MLDN */ public class DatabaseConnection { private static final String DBDRIVER = “oracle.jdbc.driver.OracleDriver” ; private static final String DBURL = “jdbc:oracle:thin:@localhost:1521:MLDN” ; private static final String DBUSER = “scott” ; private static final String PASSWORD = “tiger” ; private Connection conn = null ; // 保存连接对象 /** * 构造方法的主要目的是进行数据库连接，只要在程序之中实例化了DatabaseConnection对象 * 那么就表示要进行数据库的连接操作了，所以在构造方法之中连接数据库 * 在本构造方法之中，如果出现了异常，将直接输出异常信息，因为如果数据库连接都没有了，根本就无法操作 */ public DatabaseConnection() { try { Class.forName(DBDRIVER); this.conn = DriverManager.getConnection(DBURL, DBUSER, PASSWORD); } catch (Exception e) { e.printStackTrace(); } } /** * 取得一个数据库连接对象，这个对象在构造方法中取得 * @return Connection接口对象 */ public Connection getConnection() { return this.conn ; } /** * 关闭连接，不管是否连接上，执行此操作都不会出错 */ public void close() { if (this.conn != null) { // 取得了连接 try { // 关闭连接 this.conn.close() ; } catch (SQLException e) { e.printStackTrace(); } } } } 如果在实际的工作之中，按照DAO最早提出的标准，对于数据层的实现类还需要实现数据库的移植操作。即：对于数据库连接类应该变为一个专门负责连接的接口，就好象以下的形式一样： public interface DatabaseConnection { public Connection getConnection() ; public void close() ; } 而后如果一个项目可能在Oracle或DB2下运行，那么针对于这两种数据库分别定义一个接口实现类，以对应两个不同的数据库连接。但是这种开发已经和现在的模式有些出入了，而且特别的麻烦，所以在本次为了和日后的开发可以更好的联系在一起，只是定义了一个类而已。 3.4、开发数据层（重点） 3.4.1、定义IEmpDAO接口：数据层开发标准 不同层之间的操作依靠的是接口，所以数据层的开发首先要定义出来的就是标准。那么既然是标准就需要定义的是一个接口，现在很明显针对的是emp表，所以这个接口的名称就应该为“表名称DAO”，即：EmpDAO，但是这里有一个问题了，接口和类的命名要求是一致的，所以为了从名称上区分出接口或者是类，则建议在接口名称前增加一个字母“I”，表示Interface的含义，即：emp这张实体表的操作标准的接口名称为：IEmpDAO，而且这个接口应该保存在cn.mldn.oracle.dao包之中。 那么对于这个接口的开发主要是针对于数据的两种操作（更新、查询），所以从开发标准上对于命名也有着严格的要求，而且必须遵守，基本标准如下： · 更新操作：以“doXxx()”的方式命名，例如：doCreate()、doUpdate()、doRemvoe()； · 查询操作，因为查询操作分为两类： |-数据查询：以“findXxx()”或“findByXxx()”为主，例如：findAll()、findById()、findByJob()； |-统计查询：以“getXxx()”或“getByXxx()”为主，例如：getAllCount()、getByJobCount()。 范例：编写IEmpDAO接口的操作标准 package cn.mldn.oracle.dao; import java.util.List; import cn.mldn.oracle.vo.Emp; public interface IEmpDAO { /** * 执行数据的增加操作 * @param vo 包含所要增加的数据的VO对象 * @return 如果增加数据成功返回true，否则返回false * @throws Exception 操作之中出现了异常，返回给被调用处执行处理 */ public boolean doCreate(Emp vo) throws Exception ; /** * 执行数据的更新操作 * @param vo 包含了新数据的VO对象 * @return 如果修改成功返回true，否则返回false * @throws Exception 操作之中出现了异常，返回给被调用处执行处理 */ public boolean doUpdate(Emp vo) throws Exception ; /** * 删除一个雇员的信息 * @param id 要删除的雇员编号 * @return 如果删除成功返回true，否则返回false * @throws Exception 操作之中出现了异常，返回给被调用处执行处理 */ public boolean doRemove(int id) throws Exception ; /** * 根据雇员编号查询一个雇员的完整信息 * @param id 要查询的雇员编号 * @return 如果没有指定的雇员编号，返回值为null，&lt;br&gt; * 如果有指定的雇员信息，则将所有的雇员信息包装到Emp实例化对象之中返回。 * @throws Exception 操作之中出现了异常，返回给被调用处执行处理 */ public Emp findById(int id) throws Exception ; /** * 查询全部的雇员信息 * @return 多个雇员信息使用List返回，如果List集合的size()长度为0，则表示没有数据返回 * @throws Exception 操作之中出现了异常，返回给被调用处执行处理 */ public List&lt;Emp&gt; findAll() throws Exception ; /** * 分页显示所有雇员的信息，同时可以完成模糊查询 * @param column 要模糊查询的字段名称 * @param keyWord 要模糊查询的数据，如果为空字符串（isEmpty()判断为true，表示空字符串），则表示查询全部 * @param currentPage 当前所在的页 * @param lineSize 没页显示的记录长度 * @return 多个雇员信息使用List返回，如果List集合的size()长度为0，则表示没有数据返回 * @throws Exception 操作之中出现了异常，返回给被调用处执行处理 */ public List&lt;Emp&gt; findAll(String column, String keyWord, int currentPage, int lineSize) throws Exception; /** * 统计模糊查询的数据结果，使用COUNT()函数进行统计 * @param column 要模糊查询的字段名称 * @param keyWord 要模糊查询的数据，如果为空字符串（isEmpty()判断为true，表示空字符串），则表示查询全部 * @return 会根据数据量的多少返回数据的长度，如果没有数据返回0 * @throws Exception 操作之中出现了异常，返回给被调用处执行处理 */ public int getAllCount(String column, String keyWord) throws Exception; } 现在开发的标准只是满足于程序需求的提出需要。 3.4.2、定义IEmpDAO接口的实现类 既然在接口中已经定义了数据层的操作标准，那么对于实现类只需要遵循数据层的CRUD操作即可，但是对于DAO接口的实现类需要有明确的定义，要求将其定义在：cn.mldn.oracle.dao.impl包之中。 范例：定义EmpDAOImpl子类 · 现在有如下一种的子类实现接口方式： @Override public boolean doCreate(Emp vo) throws Exception { DatabaseConnection dbc = new DatabaseConnection(); String sql = “INSERT INTO emp (empno,ename,job,hiredate,sal,comm) VALUES (?,?,?,?,?,?)”; PreparedStatement pstmt = dbc.getConnection().prepareStatement(sql); pstmt.setInt(1, vo.getEmpno()); pstmt.setString(2, vo.getEname()); pstmt.setString(3, vo.getJob()); pstmt.setDate(4, new java.sql.Date(vo.getHiredate().getTime())); pstmt.setDouble(5, vo.getSal()); pstmt.setDouble(6, vo.getComm()); if (pstmt.executeUpdate() &gt; 0) { return true ; } dbc.close() ; return false; } 如果真的按照这种方式实现的程序，有两个重要问题： · 对于数据层之中给出的若干方法，由服务层调用，一个服务层要执行N个数据层，那么每次执行的时候打开一次关闭一次数据库？ · 按照异常的处理机制，如果现在执行的过程之中出现了错误，那么顺着throws就结束调用了，数据库就再也无法关闭了。 按照之前的分析，一个业务要进行多个数据层操作，所以数据库连接与关闭交给业务层做最合适，而数据层只需要有一个Connection对象就可以操作了，它不需要关心这个对象是从那里来的，怎么来的，只关心能不能使用。 package cn.mldn.oracle.dao.impl; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.util.ArrayList; import java.util.List; import cn.mldn.oracle.dao.IEmpDAO; import cn.mldn.oracle.vo.Emp; public class EmpDAOImpl implements IEmpDAO { private Connection conn; private PreparedStatement pstmt; public EmpDAOImpl(Connection conn) { this.conn = conn; } @Override public boolean doCreate(Emp vo) throws Exception { String sql = “INSERT INTO emp (empno,ename,job,hiredate,sal,comm) VALUES (?,?,?,?,?,?)”; this.pstmt = this.conn.prepareStatement(sql); this.pstmt.setInt(1, vo.getEmpno()); this.pstmt.setString(2, vo.getEname()); this.pstmt.setString(3, vo.getJob()); this.pstmt.setDate(4, new java.sql.Date(vo.getHiredate().getTime())); this.pstmt.setDouble(5, vo.getSal()); this.pstmt.setDouble(6, vo.getComm()); if (this.pstmt.executeUpdate() &gt; 0) { return true; } return false; } @Override public boolean doUpdate(Emp vo) throws Exception { String sql = “UPDATE emp SET ename=?,job=?,hiredate=?,sal=?,comm=? WHERE empno=?”; this.pstmt = this.conn.prepareStatement(sql); this.pstmt.setString(1, vo.getEname()); this.pstmt.setString(2, vo.getJob()); this.pstmt.setDate(3, new java.sql.Date(vo.getHiredate().getTime())); this.pstmt.setDouble(4, vo.getSal()); this.pstmt.setDouble(5, vo.getComm()); this.pstmt.setInt(6, vo.getEmpno()); if (this.pstmt.executeUpdate() &gt; 0) { return true; } return false; } @Override public boolean doRemove(int id) throws Exception { String sql = “DELETE FROM emp WHERE empno=?”; this.pstmt = this.conn.prepareStatement(sql); this.pstmt.setInt(1, id); if (this.pstmt.executeUpdate() &gt; 0) { return true; } return false; } @Override public Emp findById(int id) throws Exception { Emp emp = null; String sql = “SELECT empno,ename,job,hiredate,sal,comm FROM emp WHERE empno=?”; this.pstmt = this.conn.prepareStatement(sql); this.pstmt.setInt(1, id); ResultSet rs = this.pstmt.executeQuery(); if (rs.next()) { emp = new Emp(); emp.setEmpno(rs.getInt(1)); emp.setEname(rs.getString(2)); emp.setJob(rs.getString(3)); emp.setHiredate(rs.getDate(4)); emp.setSal(rs.getDouble(5)); emp.setComm(rs.getDouble(6)); } return emp; } @Override public List&lt;Emp&gt; findAll() throws Exception { List&lt;Emp&gt; all = new ArrayList&lt;Emp&gt;(); String sql = “SELECT empno,ename,job,hiredate,sal,comm FROM emp”; this.pstmt = this.conn.prepareStatement(sql); ResultSet rs = this.pstmt.executeQuery(); while (rs.next()) { Emp emp = new Emp(); emp.setEmpno(rs.getInt(1)); emp.setEname(rs.getString(2)); emp.setJob(rs.getString(3)); emp.setHiredate(rs.getDate(4)); emp.setSal(rs.getDouble(5)); emp.setComm(rs.getDouble(6)); all.add(emp); } return all; } @Override public List&lt;Emp&gt; findAll(String column, String keyWord, int currentPage, int lineSize) throws Exception { List&lt;Emp&gt; all = new ArrayList&lt;Emp&gt;(); String sql = “SELECT * FROM (“ + “SELECT empno,ename,job,hiredate,sal,comm,ROWNUM rn FROM emp WHERE “ + column + “ LIKE ? AND ROWNUM&lt;=?) temp “ + “ WHERE temp.rn&gt;? “; this.pstmt = this.conn.prepareStatement(sql); this.pstmt.setString(1, “%” + keyWord + “%”); this.pstmt.setInt(2, currentPage * lineSize); this.pstmt.setInt(3, (currentPage - 1) * lineSize); ResultSet rs = this.pstmt.executeQuery(); while (rs.next()) { Emp emp = new Emp(); emp.setEmpno(rs.getInt(1)); emp.setEname(rs.getString(2)); emp.setJob(rs.getString(3)); emp.setHiredate(rs.getDate(4)); emp.setSal(rs.getDouble(5)); emp.setComm(rs.getDouble(6)); all.add(emp); } return all; } @Override public int getAllCount(String column, String keyWord) throws Exception { String sql = “SELECT COUNT(empno) FROM emp WHERE “ + column + “ LIKE ?”; this.pstmt = this.conn.prepareStatement(sql) ; this.pstmt.setString(1, “%” + keyWord + “%”); ResultSet rs = this.pstmt.executeQuery() ; if (rs.next()) { return rs.getInt(1) ; } return 0; } } 3.4.3、定义DAO工厂类 由于不同层之间只能依靠接口取得对象，所以就一定需要定义工厂操作类，工厂类定义在cn.mldn.oracle.factory包之中，名称为DAOFactory。 范例：定义工厂类 package cn.mldn.oracle.factory; import java.sql.Connection; import cn.mldn.oracle.dao.IEmpDAO; import cn.mldn.oracle.dao.impl.EmpDAOImpl; public class DAOFactory { public static IEmpDAO getIEmpDAOInstance(Connection conn) { return new EmpDAOImpl(conn) ; } } 3.5、开发业务层（重点） 3.5.1、开发业务层标准 业务层以后也是需要留给其他层进行调用的，所以业务层定义的时候也需要首先定义出操作标准，而这个标准也依然使用接口完成，对于业务层，接口命名要求：表名称 Service，例如：IEmpService，表示操作Emp表的业务。 范例：在cn.mldn.oracle.service包中定义IEmpService接口 package cn.mldn.oracle.service; import java.util.Map; import cn.mldn.oracle.vo.Emp; public interface IEmpService { /** * 调用数据库的增加操作，操作流程如下：&lt;br&gt; * &lt;li&gt;首先要使用IEmpDAO接口中的findById()方法，根据要增加的id查看指定的雇员信息是否存在； * &lt;li&gt;如果要增加的雇员信息不存在，则执行IEmpDAO接口的doCreate()方法，并将结果返回； * @param vo 包装数据的对象 * @return 如果增加成功，返回true，如果雇员编号存在或者是增加失败，返回false * @throws Exception 有异常交给被调用处处理 */ public boolean insert(Emp vo) throws Exception; /** * 执行数据的更新操作，操作的时候直接调用IEmpDAO接口的doUpdate()方法，并将更新结果返回 * @param vo 包装数据的对象 * @return 如果修改成功，返回true，如果数据不存在或修改失败，返回false * @throws Exception 有异常交给被调用处处理 */ public boolean update(Emp vo) throws Exception ; /** * 执行数据的删除操作，删除操作的时候调用IEmpDAO接口的doRemove()方法 * @param id 要删除雇员的id * @return 如果删除成功，返回true，如果数据不存在或删除失败，则返回false * @throws Exception 有异常交给被调用处处理 */ public boolean delete(int id) throws Exception ; /** * 根据雇员的编号取得全部的信息 * @param id 雇员编号 * @return 如果雇员存在则将数据包装为Emp对象返回，如果数据不存在则返回null * @throws Exception 有异常交给被调用处处理 */ public Emp get(int id) throws Exception ; /** * 查询全部或者是模糊查询全部数据，查询的同时可以返回满足此查询的数据量，在调用的时候需要执行以下操作：&lt;br&gt; * &lt;li&gt;查询全部的雇员信息：需要IEmpDAO接口的findAll()方法； * &lt;li&gt;查询满足条件的雇员数量：使用IEmpDAO接口的getAllCount()方法操作； * @param column 模糊查询的字段 * @param keyWord 模糊查询的关键字 * @param currentPage 当前所在页 * @param lineSize 每页显示的数据长度 * @return 由于在进行数据返回的时候，此方法要返回两类数据：List&lt;Emp&gt;、int，使用Map返回：&lt;br&gt; * &lt;li&gt;返回值1：key = allEmps，value = findAll()； * &lt;li&gt;返回值2：key = empCount，value = getAllCount()； * @throws Exception 有异常交给被调用处处理 */ public Map&lt;String, Object&gt; list(String column, String keyWord, int currentPage, int lineSize) throws Exception; } 3.5.2、定义业务层标准的实现类 如果现在要想实现业务层的标准，必须有一个原则先把握住：一个业务层的方法操作要调用多个数据层，同时每个业务要处理数据库的打开和关闭。 范例：定义标准实现类 —— cn.mldn.oracle.service.impl.EmpServiceImpl package cn.mldn.oracle.service.impl; import java.sql.Connection; import java.util.HashMap; import java.util.Map; import cn.mldn.oracle.dao.IEmpDAO; import cn.mldn.oracle.dbc.DatabaseConnection; import cn.mldn.oracle.factory.DAOFactory; import cn.mldn.oracle.service.IEmpService; import cn.mldn.oracle.vo.Emp; public class EmpServiceImpl implements IEmpService { private DatabaseConnection dbc = new DatabaseConnection() ; @Override public boolean insert(Emp vo) throws Exception { try { Connection conn = this.dbc.getConnection() ; // 取得连接 IEmpDAO dao = DAOFactory.getIEmpDAOInstance(conn) ; // 取得DAO接口对象 if (dao.findById(vo.getEmpno()) == null) { // 没有要查询的雇员信息 return dao.doCreate(vo) ; // 返回DAO的结果 } return false; // 数据存在，直接返回false } catch (Exception e) { throw e; } finally { this.dbc.close(); } } @Override public boolean update(Emp vo) throws Exception { try { return DAOFactory.getIEmpDAOInstance(this.dbc.getConnection()) .doUpdate(vo); } catch (Exception e) { throw e; } finally { this.dbc.close(); } } @Override public boolean delete(int id) throws Exception { try { return DAOFactory.getIEmpDAOInstance(this.dbc.getConnection()) .doRemove(id); } catch (Exception e) { throw e; } finally { this.dbc.close(); } } @Override public Emp get(int id) throws Exception { try { return DAOFactory.getIEmpDAOInstance(this.dbc.getConnection()) .findById(id); } catch (Exception e) { throw e; } finally { this.dbc.close(); } } @Override public Map&lt;String, Object&gt; list(String column, String keyWord, int currentPage, int lineSize) throws Exception { try { Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;() ; map.put(“allEmps”, DAOFactory.getIEmpDAOInstance(this.dbc.getConnection()) .findAll(column, keyWord, currentPage, lineSize)); map.put(“empCount”, DAOFactory.getIEmpDAOInstance(this.dbc.getConnection()) .getAllCount(column, keyWord)); return map; } catch (Exception e) { throw e; } finally { this.dbc.close(); } } } 3.5.3、定义Service工厂类 如果要取得IEmpService接口对象，一定也需要使用工厂类，避免耦合问题。 范例：定义cn.mldn.oracle.factory.ServiceFactory工厂类 package cn.mldn.oracle.factory; import cn.mldn.oracle.service.IEmpService; import cn.mldn.oracle.service.impl.EmpServiceImpl; public class ServiceFactory { public static IEmpService getIEmpServiceInstance() { return new EmpServiceImpl() ; } } 3.6、定义测试类 一切的程序完成之后，下面就需要编写测试程序，对于测试程序现在有两种方法完成： · 方式一：可以直接编写主方法，自己根据它的返回值结果进行判断是否成功； · 方式二：利用JUNIT完成，这样的做法标准，而且也方便日后调试。 如果要使用JUNIT则就需要建立一个个的TestCase（测试用例），而且现在再进行测试的时候，应该首先选择的是服务层接口，因为选择不是针对于接口测试，而是针对于方法测试，方法就可以不用自己去编写了。 范例：编写测试程序类 package cn.mldn.oracle.test; import java.util.Date; import java.util.Iterator; import java.util.List; import java.util.Map; import junit.framework.TestCase; import org.junit.Test; import cn.mldn.oracle.factory.ServiceFactory; import cn.mldn.oracle.vo.Emp; public class IEmpServiceTest { @Test public void testInsert() { Emp vo = new Emp(); vo.setEmpno(9988); vo.setEname(“张三”); vo.setJob(“清洁工”); vo.setSal(300.0); vo.setComm(200.0); vo.setHiredate(new Date()); try { TestCase.assertTrue(ServiceFactory.getIEmpServiceInstance().insert( vo)); } catch (Exception e) { e.printStackTrace(); } } @Test public void testUpdate() { Emp vo = new Emp(); vo.setEmpno(8888); vo.setEname(“张三”); vo.setJob(“清洁工”); vo.setSal(1000.0); vo.setComm(600.0); vo.setHiredate(new Date()); try { TestCase.assertTrue(ServiceFactory.getIEmpServiceInstance().update( vo)); } catch (Exception e) { e.printStackTrace(); } } @Test public void testDelete() { try { TestCase.assertTrue(ServiceFactory.getIEmpServiceInstance() .delete(8888)); } catch (Exception e) { e.printStackTrace(); } } @Test public void testGet() { try { Emp vo = ServiceFactory.getIEmpServiceInstance().get(7369); TestCase.assertNotNull(vo); System.out.println(vo.getEname()); } catch (Exception e) { e.printStackTrace(); } } @Test public void testList() { try { Map&lt;String, Object&gt; map = ServiceFactory.getIEmpServiceInstance() .list(“ename”, “”, 1, 5); TestCase.assertNotNull(map); System.out.println(“总记录数：” + map.get(“empCount”)); @SuppressWarnings(“unchecked”) List&lt;Emp&gt; all = (List&lt;Emp&gt;) map.get(“allEmps”) ; Iterator&lt;Emp&gt; iter = all.iterator() ; while (iter.hasNext()) { Emp emp = iter.next() ; System.out.println(emp.getEname() + “，” + emp.getJob()); } } catch (Exception e) { e.printStackTrace(); } } } 3.7、完成dept操作 完成了Emp操作之后，下面继续完成dept表的操作，那么对dept的操作现在有如下的要求： · 【业务层】增加一个新部门； |- 〖数据层〗判断增加的部门编号是否存在； |- 〖数据层〗增加部门数据； · 【业务层】修改一个部门信息； |- 〖数据层〗调用修改操作； · 【业务层】删除一个部门信息； |- 〖数据层〗调用删除操作； · 【业务层】根据部门编号取得一个部门的信息；、 |- 〖数据层〗调用根据id查询的操作； · 【业务层】查询全部的部门信息； |- 〖数据层〗查询全部。 1、 开发DatabaseConnection.java类，已经开发完成； 2、 开发Dept的vo类： package cn.mldn.oracle.vo; import java.io.Serializable; @SuppressWarnings(“serial”) public class Dept implements Serializable { private Integer deptno ; private String dname ; private String loc; } 3、 开发IDeptDAO接口： package cn.mldn.oracle.dao; import java.util.List; import cn.mldn.oracle.vo.Dept; public interface IDeptDAO { public boolean doCreate(Dept vo) throws Exception; public boolean doUpdate(Dept vo) throws Exception; public boolean doRemove(int id) throws Exception; public Dept findById(int id) throws Exception; public List&lt;Dept&gt; findAll() throws Exception; } 这个时候所编写的接口，第一反应发现除了参数不一样之外，和IEmpDAO一样，而且就算现在有几百张表，对于一些基本操作：插入数据、更新全部、删除数据、根据ID查询数据、查询全部数据、带分页查询、统计分页的数据量。没有必要重复编写，各个表不同的只有两块：VO类、ID类型。所以现在对于接口就必须重新设计了。 范例：定义一个公共的IDAO接口 package cn.mldn.oracle.dao; import java.util.List; /** * 公共的DAO操作接口 * @author MLDN * @param &lt;K&gt;要操作的数据表的主键类型； * @param &lt;V&gt;要操作的VO类型 */ public interface IDAO&lt;K, V&gt; { /** * 执行数据的增加操作 * @param vo 包含所要增加的数据的VO对象 * @return 如果增加数据成功返回true，否则返回false * @throws Exception 操作之中出现了异常，返回给被调用处执行处理 */ public boolean doCreate(V vo) throws Exception ; /** * 执行数据的更新操作 * @param vo 包含了新数据的VO对象 * @return 如果修改成功返回true，否则返回false * @throws Exception 操作之中出现了异常，返回给被调用处执行处理 */ public boolean doUpdate(V vo) throws Exception ; /** * 删除一个雇员的信息 * @param id 要删除的雇员编号 * @return 如果删除成功返回true，否则返回false * @throws Exception 操作之中出现了异常，返回给被调用处执行处理 */ public boolean doRemove(K id) throws Exception ; /** * 根据雇员编号查询一个雇员的完整信息 * @param id 要查询的雇员编号 * @return 如果没有指定的雇员编号，返回值为null，&lt;br&gt; * 如果有指定的雇员信息，则将所有的雇员信息包装到Emp实例化对象之中返回。 * @throws Exception 操作之中出现了异常，返回给被调用处执行处理 */ public V findById(K id) throws Exception ; /** * 查询全部的雇员信息 * @return 多个雇员信息使用List返回，如果List集合的size()长度为0，则表示没有数据返回 * @throws Exception 操作之中出现了异常，返回给被调用处执行处理 */ public List&lt;V&gt; findAll() throws Exception ; /** * 分页显示所有雇员的信息，同时可以完成模糊查询 * @param column 要模糊查询的字段名称 * @param keyWord 要模糊查询的数据，如果为空字符串（isEmpty()判断为true，表示空字符串），则表示查询全部 * @param currentPage 当前所在的页 * @param lineSize 没页显示的记录长度 * @return 多个雇员信息使用List返回，如果List集合的size()长度为0，则表示没有数据返回 * @throws Exception 操作之中出现了异常，返回给被调用处执行处理 */ public List&lt;V&gt; findAll(String column, String keyWord, int currentPage, int lineSize) throws Exception; /** * 统计模糊查询的数据结果，使用COUNT()函数进行统计 * @param column 要模糊查询的字段名称 * @param keyWord 要模糊查询的数据，如果为空字符串（isEmpty()判断为true，表示空字符串），则表示查询全部 * @return 会根据数据量的多少返回数据的长度，如果没有数据返回0 * @throws Exception 操作之中出现了异常，返回给被调用处执行处理 */ public int getAllCount(String column, String keyWord) throws Exception; } 而每一张数据表，除了以上的基本功能之外，还会包括一些自己的独特功能，所以可以在子接口中完成。 范例：定义IDeptDAO接口 package cn.mldn.oracle.dao; import cn.mldn.oracle.vo.Dept; public interface IDeptDAO extends IDAO&lt;Integer, Dept&gt; { } 4、 开发DAO接口的实现类； package cn.mldn.oracle.dao.impl; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.util.ArrayList; import java.util.List; import cn.mldn.oracle.dao.IDeptDAO; import cn.mldn.oracle.vo.Dept; public class DeptDAOImpl implements IDeptDAO { private Connection conn ; private PreparedStatement pstmt ; public DeptDAOImpl(Connection conn) { this.conn = conn ; } @Override public boolean doCreate(Dept vo) throws Exception { String sql = “INSERT INTO dept(deptno,dname,loc) VALUES (?,?,?)” ; this.pstmt = this.conn.prepareStatement(sql) ; this.pstmt.setInt(1, vo.getDeptno()) ; this.pstmt.setString(2, vo.getDname()) ; this.pstmt.setString(3, vo.getLoc()) ; if (this.pstmt.executeUpdate() &gt; 0) { return true ; } return false; } @Override public boolean doUpdate(Dept vo) throws Exception { String sql = “UPDATE dept SET dname=?,loc=? WHERE deptno=?” ; this.pstmt = this.conn.prepareStatement(sql) ; this.pstmt.setString(1, vo.getDname()) ; this.pstmt.setString(2, vo.getLoc()) ; this.pstmt.setInt(3, vo.getDeptno()) ; if (this.pstmt.executeUpdate() &gt; 0) { return true ; } return false; } @Override public boolean doRemove(Integer id) throws Exception { String sql = “DELETE FROM dept WHERE deptno=?” ; this.pstmt = this.conn.prepareStatement(sql) ; this.pstmt.setInt(1, id); if (this.pstmt.executeUpdate() &gt; 0) { return true ; } return false; } @Override public Dept findById(Integer id) throws Exception { Dept dept = null ; String sql = “SELECT deptno,dname,loc FROM dept WHERE deptno=?” ; this.pstmt = this.conn.prepareStatement(sql) ; this.pstmt.setInt(1, id); ResultSet rs = this.pstmt.executeQuery() ; if (rs.next()) { dept = new Dept() ; dept.setDeptno(rs.getInt(1)) ; dept.setDname(rs.getString(2)) ; dept.setLoc(rs.getString(3)) ; } return dept; } @Override public List&lt;Dept&gt; findAll() throws Exception { List&lt;Dept&gt; all = new ArrayList&lt;&gt;() ; String sql = “SELECT deptno,dname,loc FROM dept” ; this.pstmt = this.conn.prepareStatement(sql) ; ResultSet rs = this.pstmt.executeQuery() ; while (rs.next()) { Dept dept = new Dept() ; dept.setDeptno(rs.getInt(1)) ; dept.setDname(rs.getString(2)) ; dept.setLoc(rs.getString(3)) ; all.add(dept) ; } return all; } @Override public List&lt;Dept&gt; findAll(String column, String keyWord, int currentPage, int lineSize) throws Exception { throw new Exception(“此方法未实现！”) ; } @Override public int getAllCount(String column, String keyWord) throws Exception { throw new Exception(“此方法未实现！”) ; } } 5、 在DAOFactory类之中，增加新的方法，取得IDeptDAO接口实现类对象； 6、 开发服务层接口； package cn.mldn.oracle.service; import java.util.List; import cn.mldn.oracle.vo.Dept; public interface IDeptService { public boolean insert(Dept vo) throws Exception; public boolean update(Dept vo) throws Exception; public boolean delete(int id) throws Exception; public Dept get(int id) throws Exception; public List&lt;Dept&gt; list() throws Exception; } 7、 开发服务层接口实现类； 8、 在ServiceFactory接口之中增加新的方法，可以取得IDeptService接口对象； 3.8、使用mgr字段操作 在emp表中的mgr字段，表示的是每一个雇员的领导，如果现在要想加入上这种操作关系，需要做如下的几步。 1、 在Emp类之中表示出领导的关系，增加一个mgr属性； private Emp mgr ; public void setMgr(Emp mgr) { this.mgr = mgr; } public Emp getMgr() { return mgr; } 2、 修改DAO实现类，因为现在操作数据的时候要考虑mgr字段了 3.9、使用deptno字段操作 Emp表中的deptno字段是一个每一个雇员所属的部门编号，所以在这之中就会发生如下的两类关系： · 关系一：一个雇员属于一个部门； · 关系二：一个部门有多个雇员。 1、 首先在Emp类之中增加一个Dept的操作 private Dept dept ; public void setDept(Dept dept) { this.dept = dept; } public Dept getDept() { return dept; } 2、 修改EmpDAOImpl的实现子类上； 4、总结 1、 程序的分层操作一定要掌握； 2、 基本操作，要求对于单表的CRUD灵活编写，半小时写完一个； 3、 对于表之间的关系，必须会，能都会最好。 5、作业 1、 emp表的基本字段CRUD、分页，5遍； 2、 dept表的基本字段CRUD，5遍； 以上在下周一的时候交。 3、 挑字段写，以下在元旦之后交。 以下的字段必须全写，不是挑字段了。 作业要求录视频编写，每一个都要求有视频，有编写完的代码； 写的时候，包名称写上你自己姓名的拼音。 cn.mldn.fuyunsong.dao 所有的视频凡是以不能录象为理由的，或者是没有录象，后者是丢失的，或者是XX原因的一概算没有完成。 至少有2 ~ 3遍是可以在半个小时内写完的。","categories":[],"tags":[]}],"categories":[],"tags":[]}